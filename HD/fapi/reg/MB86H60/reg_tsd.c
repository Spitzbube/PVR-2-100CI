/*
********************************************************************************
**
** \file      ./fapi/reg/src/MB86H60/reg_tsd.c
**
** \brief     TSD access functions
**
** \attention THIS SAMPLE CODE IS PROVIDED AS IS. FUJITSU MICROELECTRONICS
**            ACCEPTS NO RESPONSIBILITY OR LIABILITY FOR ANY ERRORS OR
**            OMMISSIONS.
**
** \note      Do not modify this file as it is generated automatically.
**
** (C) Copyright 2006-2009 by Fujitsu Microelectronics Europe GmbH
**
********************************************************************************
*/
#define FREG_TSD_C

#include <stdint.h>
#include "reg_tsd.h"

/*
********************************************************************************
**
** Mirror variables for write-only registers
**
********************************************************************************
*/
volatile uint32_t FREG_TSD0_PidValueMirror[13] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_PidConfig_1Mirror[32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_PidConfig_2Mirror[32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_DscOddKeyUpperMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_DscOddKeyLowerMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_DscEvenKeyUpperMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_DscEvenKeyLowerMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_PidValueMirror[13] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_PidConfig_1Mirror[32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_PidConfig_2Mirror[32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_DscOddKeyUpperMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_DscOddKeyLowerMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_DscEvenKeyUpperMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_DscEvenKeyLowerMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_LinPacket0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_LinPacket1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_LinPacket2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_LinPacket3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_LinPacket0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_LinPacket1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_LinPacket2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_LinPacket3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_LinPacketAuto0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_LinPacketAuto1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_LinPacketAuto2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_LinPacketAuto3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_LinPacketAuto0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_LinPacketAuto1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_LinPacketAuto2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_LinPacketAuto3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_Packet0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_Packet1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_Packet2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_Packet3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_Packet0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_Packet1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_Packet2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_Packet3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD01_IrqClearMirror = 0;
volatile uint32_t FREG_TSD0_SfTargetsMirror[256] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD0_SfPtrMirror[128] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_SfTargetsMirror[256] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD1_SfPtrMirror[128] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_PidValueMirror[13] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_PidConfig_1Mirror[32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_PidConfig_2Mirror[32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_DscOddKeyUpperMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_DscOddKeyLowerMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_DscEvenKeyUpperMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_DscEvenKeyLowerMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_PidValueMirror[13] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_PidConfig_1Mirror[32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_PidConfig_2Mirror[32] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_DscOddKeyUpperMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_DscOddKeyLowerMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_DscEvenKeyUpperMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_DscEvenKeyLowerMirror[8] = {
    0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_LinPacket0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_LinPacket1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_LinPacket2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_LinPacket3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_LinPacket0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_LinPacket1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_LinPacket2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_LinPacket3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_LinPacketAuto0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_LinPacketAuto1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_LinPacketAuto2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_LinPacketAuto3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_LinPacketAuto0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_LinPacketAuto1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_LinPacketAuto2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_LinPacketAuto3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_Packet0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_Packet1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_Packet2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_Packet3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_Packet0Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_Packet1Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_Packet2Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_Packet3Mirror[47] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD23_IrqClearMirror = 0;
volatile uint32_t FREG_TSD2_SfTargetsMirror[256] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD2_SfPtrMirror[128] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_SfTargetsMirror[256] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
volatile uint32_t FREG_TSD3_SfPtrMirror[128] = {
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidChannelActive".
**
** This function writes the given value to the index-th entry of the register
** array PidChannelActive.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_1"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_1" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_1")))
#endif

void FREG_TSD0_SetPidChannelActive( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidChannelEnable" of register "PidChannelActive".
**
**  - '0': Deactivating the corresponding PID channel.
**
** - '1': activating the corresponding PID channel.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidChannelEnable" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_2"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_2" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_2")))
#endif

void FREG_TSD0_SetPidChannelActive_PidChannelEnable( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_PIDCHANNELACTIVE+(index*0x4))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FirstPacketFlag" of register "PidChannelActive".
**
**  - '0': The upcoming packet is not the first packet to be received for this PID channel.
**
** - '1': The upcoming packet is the first packet to be received for this PID channel. After the first packet is received, this bit will be automaticaly cleared.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FirstPacketFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_3"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_3" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_3")))
#endif

void FREG_TSD0_SetPidChannelActive_FirstPacketFlag( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_PIDCHANNELACTIVE+(index*0x4))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidChannelActive".
**
** This function reads the value from the index-th entry of the register
** array PidChannelActive.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_4"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_4" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_4")))
#endif

uint32_t FREG_TSD0_GetPidChannelActive( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_PIDCHANNELACTIVE+(index*0x4)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidChannelEnable" of register "PidChannelActive".
**
**  - '0': Deactivating the corresponding PID channel.
**
** - '1': activating the corresponding PID channel.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidChannelEnable" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_5"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_5" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_5")))
#endif

uint32_t FREG_TSD0_GetPidChannelActive_PidChannelEnable( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_PIDCHANNELACTIVE+(index*0x4)));
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FirstPacketFlag" of register "PidChannelActive".
**
**  - '0': The upcoming packet is not the first packet to be received for this PID channel.
**
** - '1': The upcoming packet is the first packet to be received for this PID channel. After the first packet is received, this bit will be automaticaly cleared.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FirstPacketFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_6"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_6" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_6")))
#endif

uint32_t FREG_TSD0_GetPidChannelActive_FirstPacketFlag( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_PIDCHANNELACTIVE+(index*0x4)));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidChannelActive".
**
** This function writes the given value to the index-th entry of the register
** array PidChannelActive.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_7"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_7" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_7")))
#endif

void FREG_TSD1_SetPidChannelActive( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidChannelEnable" of register "PidChannelActive".
**
**  - '0': Deactivating the corresponding PID channel.
**
** - '1': activating the corresponding PID channel.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidChannelEnable" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_8"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_8" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_8")))
#endif

void FREG_TSD1_SetPidChannelActive_PidChannelEnable( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_PIDCHANNELACTIVE+(index*0x4))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FirstPacketFlag" of register "PidChannelActive".
**
**  - '0': The upcoming packet is not the first packet to be received for this PID channel.
**
** - '1': The upcoming packet is the first packet to be received for this PID channel. After the first packet is received, this bit will be automaticaly cleared.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FirstPacketFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_9"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_9" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_9")))
#endif

void FREG_TSD1_SetPidChannelActive_FirstPacketFlag( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_PIDCHANNELACTIVE+(index*0x4))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidChannelActive".
**
** This function reads the value from the index-th entry of the register
** array PidChannelActive.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_10"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_10" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_10")))
#endif

uint32_t FREG_TSD1_GetPidChannelActive( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_PIDCHANNELACTIVE+(index*0x4)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidChannelEnable" of register "PidChannelActive".
**
**  - '0': Deactivating the corresponding PID channel.
**
** - '1': activating the corresponding PID channel.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidChannelEnable" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_11"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_11" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_11")))
#endif

uint32_t FREG_TSD1_GetPidChannelActive_PidChannelEnable( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_PIDCHANNELACTIVE+(index*0x4)));
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FirstPacketFlag" of register "PidChannelActive".
**
**  - '0': The upcoming packet is not the first packet to be received for this PID channel.
**
** - '1': The upcoming packet is the first packet to be received for this PID channel. After the first packet is received, this bit will be automaticaly cleared.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FirstPacketFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_12"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_12" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_12")))
#endif

uint32_t FREG_TSD1_GetPidChannelActive_FirstPacketFlag( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_PIDCHANNELACTIVE+(index*0x4)));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "InputCtrl".
**
** This function writes the given value to the register "InputCtrl".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_13"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_13" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_13")))
#endif

void FREG_TSD01_SetInputCtrl( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts1AmSync" of register "InputCtrl".
**
** Enable automatical synchronization (AM_SYNC) on Sync Byte:
** - '0': sync on start signal or TS1_en
** - '1': auto search for sync byte 0x47 and 0xB8
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts1AmSync" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_14"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_14" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_14")))
#endif

void FREG_TSD01_SetInputCtrl_Ts1AmSync( uint32_t value )
{
    register uint32_t mask = 0x00002000UL;
    value = ( value << 13 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts1PacketStart" of register "InputCtrl".
**
** Polarity of the signal TS1_PACKET_START:
** - '0': high active
** - '1': low active
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts1PacketStart" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_15"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_15" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_15")))
#endif

void FREG_TSD01_SetInputCtrl_Ts1PacketStart( uint32_t value )
{
    register uint32_t mask = 0x00001000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts1En" of register "InputCtrl".
**
** Polarity of TS1_EN:
** - '0': high active
** - '1': low active
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts1En" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_16"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_16" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_16")))
#endif

void FREG_TSD01_SetInputCtrl_Ts1En( uint32_t value )
{
    register uint32_t mask = 0x00000800UL;
    value = ( value << 11 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts1Clk" of register "InputCtrl".
**
** Indicate at which edge (rising of falling edge) of TS1_CLK the TS input data to TSD1 shall be sampled:
** - '0': sample TS data at the rising edge of TS1_CLK.
**
** - '1': sample TS data at the falling edge of TS1_CLK.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts1Clk" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_17"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_17" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_17")))
#endif

void FREG_TSD01_SetInputCtrl_Ts1Clk( uint32_t value )
{
    register uint32_t mask = 0x00000400UL;
    value = ( value << 10 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts1SerialParallelMode" of register "InputCtrl".
**
** Specifies the serial and paralle mode:
** - '01': serial with TS1_PACKET_START
** - '10': parallel without TS1_PACKET_START
** - '11': parallel with TS1_PACKET_START
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts1SerialParallelMode" consists of the bits 9..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000300UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_18"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_18" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_18")))
#endif

void FREG_TSD01_SetInputCtrl_Ts1SerialParallelMode( uint32_t value )
{
    register uint32_t mask = 0x00000300UL;
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts0AmSync" of register "InputCtrl".
**
** Enable automatical synchronization (AM_SYNC) on Sync Byte:
** - '0': sync on start signal or TS0_en
** - '1': auto search for sync byte 0x47 and 0xB8
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts0AmSync" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_19"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_19" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_19")))
#endif

void FREG_TSD01_SetInputCtrl_Ts0AmSync( uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    value = ( value << 5 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts0PacketStart" of register "InputCtrl".
**
** Polarity of the signal TS0_PACKET_START:
** - '0': high active
** - '1': low active
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts0PacketStart" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_20"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_20" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_20")))
#endif

void FREG_TSD01_SetInputCtrl_Ts0PacketStart( uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    value = ( value << 4 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts0En" of register "InputCtrl".
**
** Polarity of TS0_EN:
** - '0': high active
** - '1': low active
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts0En" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_21"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_21" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_21")))
#endif

void FREG_TSD01_SetInputCtrl_Ts0En( uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    value = ( value << 3 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts0Clk" of register "InputCtrl".
**
** Indicate at which edge (rising of falling edge) of TS0_CLK the TS input data to TSD0 shall be sampled:
** - '0': sample TS data at the rising edge of TS0_CLK.
**
** - '1': sample TS data at the falling edge of TS0_CLK.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts0Clk" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_22"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_22" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_22")))
#endif

void FREG_TSD01_SetInputCtrl_Ts0Clk( uint32_t value )
{
    register uint32_t mask = 0x00000004UL;
    value = ( value << 2 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts0SerialParallelMode" of register "InputCtrl".
**
** Specifies the serial and paralle mode:
** - '01': serial with TS0_PACKET_START
** - '10': parallel without TS0_PACKET_START
** - '11': parallel with TS0_PACKET_START
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts0SerialParallelMode" consists of the bits 1..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000003UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_23"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_23" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_23")))
#endif

void FREG_TSD01_SetInputCtrl_Ts0SerialParallelMode( uint32_t value )
{
    register uint32_t mask = 0x00000003UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "InputCtrl".
**
** This function reads the value from the register "InputCtrl".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_24"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_24" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_24")))
#endif

uint32_t FREG_TSD01_GetInputCtrl( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts1AmSync" of register "InputCtrl".
**
** Enable automatical synchronization (AM_SYNC) on Sync Byte:
** - '0': sync on start signal or TS1_en
** - '1': auto search for sync byte 0x47 and 0xB8
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts1AmSync" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_25"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_25" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_25")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts1AmSync( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00002000UL ) >> 13;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts1PacketStart" of register "InputCtrl".
**
** Polarity of the signal TS1_PACKET_START:
** - '0': high active
** - '1': low active
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts1PacketStart" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_26"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_26" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_26")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts1PacketStart( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00001000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts1En" of register "InputCtrl".
**
** Polarity of TS1_EN:
** - '0': high active
** - '1': low active
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts1En" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_27"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_27" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_27")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts1En( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00000800UL ) >> 11;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts1Clk" of register "InputCtrl".
**
** Indicate at which edge (rising of falling edge) of TS1_CLK the TS input data to TSD1 shall be sampled:
** - '0': sample TS data at the rising edge of TS1_CLK.
**
** - '1': sample TS data at the falling edge of TS1_CLK.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts1Clk" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_28"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_28" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_28")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts1Clk( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00000400UL ) >> 10;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts1SerialParallelMode" of register "InputCtrl".
**
** Specifies the serial and paralle mode:
** - '01': serial with TS1_PACKET_START
** - '10': parallel without TS1_PACKET_START
** - '11': parallel with TS1_PACKET_START
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts1SerialParallelMode" consists of the bits 9..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000300UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_29"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_29" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_29")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts1SerialParallelMode( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00000300UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts0AmSync" of register "InputCtrl".
**
** Enable automatical synchronization (AM_SYNC) on Sync Byte:
** - '0': sync on start signal or TS0_en
** - '1': auto search for sync byte 0x47 and 0xB8
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts0AmSync" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_30"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_30" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_30")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts0AmSync( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts0PacketStart" of register "InputCtrl".
**
** Polarity of the signal TS0_PACKET_START:
** - '0': high active
** - '1': low active
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts0PacketStart" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_31"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_31" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_31")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts0PacketStart( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts0En" of register "InputCtrl".
**
** Polarity of TS0_EN:
** - '0': high active
** - '1': low active
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts0En" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_32"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_32" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_32")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts0En( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts0Clk" of register "InputCtrl".
**
** Indicate at which edge (rising of falling edge) of TS0_CLK the TS input data to TSD0 shall be sampled:
** - '0': sample TS data at the rising edge of TS0_CLK.
**
** - '1': sample TS data at the falling edge of TS0_CLK.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts0Clk" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_33"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_33" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_33")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts0Clk( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00000004UL ) >> 2;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts0SerialParallelMode" of register "InputCtrl".
**
** Specifies the serial and paralle mode:
** - '01': serial with TS0_PACKET_START
** - '10': parallel without TS0_PACKET_START
** - '11': parallel with TS0_PACKET_START
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts0SerialParallelMode" consists of the bits 1..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000003UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_34"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_34" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_34")))
#endif

uint32_t FREG_TSD01_GetInputCtrl_Ts0SerialParallelMode( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTCTRL));
    value = ( value & 0x00000003UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "StartDistance".
**
** This function writes the given value to the register "StartDistance".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_35"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_35" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_35")))
#endif

void FREG_TSD01_SetStartDistance( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_STARTDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_STARTDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts1StartDistance" of register "StartDistance".
**
** Distance between Sync Bytes for the input channel 1.
**  If TS1_AM_SYNC is 1, this value must be configured correctly. START_DISTANCE = packet-length - 1 (e.g. 187 or 203)
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts1StartDistance" consists of the bits 19..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x000FF000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_36"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_36" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_36")))
#endif

void FREG_TSD01_SetStartDistance_Ts1StartDistance( uint32_t value )
{
    register uint32_t mask = 0x000FF000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_STARTDISTANCE)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_STARTDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_STARTDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts0StartDistance" of register "StartDistance".
**
** Distance between Sync Bytes for the input channel 0.
**  If TS0_AM_SYNC is 1, this value must be configured correctly. START_DISTANCE = packet-length - 1 (e.g. 187 or 203)
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts0StartDistance" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_37"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_37" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_37")))
#endif

void FREG_TSD01_SetStartDistance_Ts0StartDistance( uint32_t value )
{
    register uint32_t mask = 0x000000FFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_STARTDISTANCE)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_STARTDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_STARTDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "StartDistance".
**
** This function reads the value from the register "StartDistance".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_38"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_38" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_38")))
#endif

uint32_t FREG_TSD01_GetStartDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_STARTDISTANCE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts1StartDistance" of register "StartDistance".
**
** Distance between Sync Bytes for the input channel 1.
**  If TS1_AM_SYNC is 1, this value must be configured correctly. START_DISTANCE = packet-length - 1 (e.g. 187 or 203)
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts1StartDistance" consists of the bits 19..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x000FF000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_39"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_39" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_39")))
#endif

uint32_t FREG_TSD01_GetStartDistance_Ts1StartDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_STARTDISTANCE));
    value = ( value & 0x000FF000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts0StartDistance" of register "StartDistance".
**
** Distance between Sync Bytes for the input channel 0.
**  If TS0_AM_SYNC is 1, this value must be configured correctly. START_DISTANCE = packet-length - 1 (e.g. 187 or 203)
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts0StartDistance" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_40"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_40" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_40")))
#endif

uint32_t FREG_TSD01_GetStartDistance_Ts0StartDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_STARTDISTANCE));
    value = ( value & 0x000000FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "ReadSignalDistance".
**
** This function writes the given value to the register "ReadSignalDistance".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_41"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_41" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_41")))
#endif

void FREG_TSD01_SetReadSignalDistance( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_READSIGNALDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_READSIGNALDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "RdSignalDistance" of register "ReadSignalDistance".
**
** The clock frequency of PID filter is much higher than that of TS packet input buffer.
**  This register specifies the number of clock cycles between two read requests sent to TS packet input buffer by PID filter. Minmum: 5 (Default: 5).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "RdSignalDistance" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_42"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_42" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_42")))
#endif

void FREG_TSD01_SetReadSignalDistance_RdSignalDistance( uint32_t value )
{
    register uint32_t mask = 0x000000FFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_READSIGNALDISTANCE)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_READSIGNALDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_READSIGNALDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "ReadSignalDistance".
**
** This function reads the value from the register "ReadSignalDistance".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_43"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_43" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_43")))
#endif

uint32_t FREG_TSD01_GetReadSignalDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_READSIGNALDISTANCE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "RdSignalDistance" of register "ReadSignalDistance".
**
** The clock frequency of PID filter is much higher than that of TS packet input buffer.
**  This register specifies the number of clock cycles between two read requests sent to TS packet input buffer by PID filter. Minmum: 5 (Default: 5).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "RdSignalDistance" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_44"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_44" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_44")))
#endif

uint32_t FREG_TSD01_GetReadSignalDistance_RdSignalDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_READSIGNALDISTANCE));
    value = ( value & 0x000000FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "InputTimeout".
**
** This function writes the given value to the register "InputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two input packets. If no packet is received during INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s).
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_45"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_45" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_45")))
#endif

void FREG_TSD01_SetInputTimeout( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTTIMEOUT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTTIMEOUT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InputTimeout" of register "InputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two input packets. If no packet is received during INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InputTimeout" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_46"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_46" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_46")))
#endif

void FREG_TSD01_SetInputTimeout_InputTimeout( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INPUTTIMEOUT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INPUTTIMEOUT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INPUTTIMEOUT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "InputTimeout".
**
** This function reads the value from the register "InputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two input packets. If no packet is received during INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s).
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_47"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_47" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_47")))
#endif

uint32_t FREG_TSD01_GetInputTimeout( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTTIMEOUT));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InputTimeout" of register "InputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two input packets. If no packet is received during INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "InputTimeout" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_48"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_48" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_48")))
#endif

uint32_t FREG_TSD01_GetInputTimeout_InputTimeout( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INPUTTIMEOUT));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PacketCounter".
**
** This function writes the given value to the register "PacketCounter".
**
** Number of packets received.
**  Packets containing less than or more than 188 bytes are discarded in input buffer and not included in this value.
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_49"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_49" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_49")))
#endif

void FREG_TSD01_SetPacketCounter( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PACKETCOUNTER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PACKETCOUNTER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketCnt" of register "PacketCounter".
**
** Number of packets received.
**  Packets containing less than or more than 188 bytes are discarded in input buffer and not included in this value.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketCnt" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_50"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_50" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_50")))
#endif

void FREG_TSD01_SetPacketCounter_PacketCnt( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_PACKETCOUNTER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PACKETCOUNTER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PACKETCOUNTER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketCounter".
**
** This function reads the value from the register "PacketCounter".
**
** Number of packets received.
**  Packets containing less than or more than 188 bytes are discarded in input buffer and not included in this value.
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_51"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_51" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_51")))
#endif

uint32_t FREG_TSD01_GetPacketCounter( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PACKETCOUNTER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketCnt" of register "PacketCounter".
**
** Number of packets received.
**  Packets containing less than or more than 188 bytes are discarded in input buffer and not included in this value.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketCnt" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_52"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_52" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_52")))
#endif

uint32_t FREG_TSD01_GetPacketCounter_PacketCnt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PACKETCOUNTER));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "ValidInputTimeout".
**
** This function writes the given value to the register "ValidInputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two valid  input packets. If no valid packet is received during VALID_INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. A packet is 'valid', if its PID is configured, the corresponding STI is activated, and no CC error or syntax error is detected in this packet. The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s). "
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_53"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_53" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_53")))
#endif

void FREG_TSD01_SetValidInputTimeout( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_VALIDINPUTTIMEOUT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_VALIDINPUTTIMEOUT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ValidInputTimeout" of register "ValidInputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two valid  input packets. If no valid packet is received during VALID_INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. A packet is 'valid', if its PID is configured, the corresponding STI is activated, and no CC error or syntax error is detected in this packet. The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s). "
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ValidInputTimeout" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_54"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_54" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_54")))
#endif

void FREG_TSD01_SetValidInputTimeout_ValidInputTimeout( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_VALIDINPUTTIMEOUT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_VALIDINPUTTIMEOUT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_VALIDINPUTTIMEOUT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "ValidInputTimeout".
**
** This function reads the value from the register "ValidInputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two valid  input packets. If no valid packet is received during VALID_INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. A packet is 'valid', if its PID is configured, the corresponding STI is activated, and no CC error or syntax error is detected in this packet. The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s). "
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_55"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_55" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_55")))
#endif

uint32_t FREG_TSD01_GetValidInputTimeout( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_VALIDINPUTTIMEOUT));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ValidInputTimeout" of register "ValidInputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two valid  input packets. If no valid packet is received during VALID_INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. A packet is 'valid', if its PID is configured, the corresponding STI is activated, and no CC error or syntax error is detected in this packet. The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s). "
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "ValidInputTimeout" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_56"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_56" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_56")))
#endif

uint32_t FREG_TSD01_GetValidInputTimeout_ValidInputTimeout( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_VALIDINPUTTIMEOUT));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "ValidPacketCounter".
**
** This function writes the given value to the register "ValidPacketCounter".
**
** Number of valid packets received.
**  VALID_PACKET_CNT = PACKET_CNT - (number of packets with adaptation field control = 00) - (number of removed duplicate packet) - (number of packet with unconfigured PID) - (number of packet with configured but deactivated PID).
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_57"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_57" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_57")))
#endif

void FREG_TSD01_SetValidPacketCounter( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_VALIDPACKETCOUNTER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_VALIDPACKETCOUNTER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ValidPacketCnt" of register "ValidPacketCounter".
**
** Number of valid packets received.
**  VALID_PACKET_CNT = PACKET_CNT - (number of packets with adaptation field control = 00) - (number of removed duplicate packet) - (number of packet with unconfigured PID) - (number of packet with configured but deactivated PID).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ValidPacketCnt" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_58"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_58" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_58")))
#endif

void FREG_TSD01_SetValidPacketCounter_ValidPacketCnt( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_VALIDPACKETCOUNTER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_VALIDPACKETCOUNTER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_VALIDPACKETCOUNTER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "ValidPacketCounter".
**
** This function reads the value from the register "ValidPacketCounter".
**
** Number of valid packets received.
**  VALID_PACKET_CNT = PACKET_CNT - (number of packets with adaptation field control = 00) - (number of removed duplicate packet) - (number of packet with unconfigured PID) - (number of packet with configured but deactivated PID).
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_59"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_59" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_59")))
#endif

uint32_t FREG_TSD01_GetValidPacketCounter( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_VALIDPACKETCOUNTER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ValidPacketCnt" of register "ValidPacketCounter".
**
** Number of valid packets received.
**  VALID_PACKET_CNT = PACKET_CNT - (number of packets with adaptation field control = 00) - (number of removed duplicate packet) - (number of packet with unconfigured PID) - (number of packet with configured but deactivated PID).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "ValidPacketCnt" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_60"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_60" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_60")))
#endif

uint32_t FREG_TSD01_GetValidPacketCounter_ValidPacketCnt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_VALIDPACKETCOUNTER));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "IoChannelSelect".
**
** This function writes the given value to the register "IoChannelSelect".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_61"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_61" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_61")))
#endif

void FREG_TSD_SetIoChannelSelect( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD_IOCHANNELSELECT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "StcSelect" of register "IoChannelSelect".
**
** Select source for the  current STC:
** - '0': Select STC from TSD01
** - '1': Select STC from TSD23
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "StcSelect" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_62"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_62" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_62")))
#endif

void FREG_TSD_SetIoChannelSelect_StcSelect( uint32_t value )
{
    register uint32_t mask = 0x00001000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD_IOCHANNELSELECT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TsOutputSelect" of register "IoChannelSelect".
**
** Select source for the TS output channel:
** - '0': Select TS output data generated by TSD01
** - '1': Select TS output data generated by TSD23
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TsOutputSelect" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_63"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_63" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_63")))
#endif

void FREG_TSD_SetIoChannelSelect_TsOutputSelect( uint32_t value )
{
    register uint32_t mask = 0x00000100UL;
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD_IOCHANNELSELECT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Tsd3InputSelect" of register "IoChannelSelect".
**
** Select the TS input channels for TSD3
** - '00': Select input channel A
** - '01': Select input channel B
** - '10' or '11': Select input channel C
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Tsd3InputSelect" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_64"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_64" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_64")))
#endif

void FREG_TSD_SetIoChannelSelect_Tsd3InputSelect( uint32_t value )
{
    register uint32_t mask = 0x000000C0UL;
    value = ( value << 6 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD_IOCHANNELSELECT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Tsd2InputSelect" of register "IoChannelSelect".
**
** Select the TS input channels for TSD2
** - '00': Select input channel A
** - '01': Select input channel B
** - '10' or '11': Select input channel C
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Tsd2InputSelect" consists of the bits 5..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000030UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_65"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_65" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_65")))
#endif

void FREG_TSD_SetIoChannelSelect_Tsd2InputSelect( uint32_t value )
{
    register uint32_t mask = 0x00000030UL;
    value = ( value << 4 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD_IOCHANNELSELECT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Tsd1InputSelect" of register "IoChannelSelect".
**
** Select the TS input channels for TSD1
** - '00': Select input channel A
** - '01': Select input channel B
** - '10' or '11': Select input channel C
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Tsd1InputSelect" consists of the bits 3..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x0000000CUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_66"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_66" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_66")))
#endif

void FREG_TSD_SetIoChannelSelect_Tsd1InputSelect( uint32_t value )
{
    register uint32_t mask = 0x0000000CUL;
    value = ( value << 2 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD_IOCHANNELSELECT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Tsd0InputSelect" of register "IoChannelSelect".
**
** Select the TS input channels for TSD0
** - '00': Select input channel A
** - '01': Select input channel B
** - '10' or '11': Select input channel C
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Tsd0InputSelect" consists of the bits 1..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000003UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_67"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_67" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_67")))
#endif

void FREG_TSD_SetIoChannelSelect_Tsd0InputSelect( uint32_t value )
{
    register uint32_t mask = 0x00000003UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD_IOCHANNELSELECT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "IoChannelSelect".
**
** This function reads the value from the register "IoChannelSelect".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_68"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_68" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_68")))
#endif

uint32_t FREG_TSD_GetIoChannelSelect( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "StcSelect" of register "IoChannelSelect".
**
** Select source for the  current STC:
** - '0': Select STC from TSD01
** - '1': Select STC from TSD23
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "StcSelect" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_69"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_69" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_69")))
#endif

uint32_t FREG_TSD_GetIoChannelSelect_StcSelect( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT));
    value = ( value & 0x00001000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TsOutputSelect" of register "IoChannelSelect".
**
** Select source for the TS output channel:
** - '0': Select TS output data generated by TSD01
** - '1': Select TS output data generated by TSD23
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "TsOutputSelect" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_70"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_70" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_70")))
#endif

uint32_t FREG_TSD_GetIoChannelSelect_TsOutputSelect( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT));
    value = ( value & 0x00000100UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd3InputSelect" of register "IoChannelSelect".
**
** Select the TS input channels for TSD3
** - '00': Select input channel A
** - '01': Select input channel B
** - '10' or '11': Select input channel C
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd3InputSelect" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_71"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_71" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_71")))
#endif

uint32_t FREG_TSD_GetIoChannelSelect_Tsd3InputSelect( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT));
    value = ( value & 0x000000C0UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd2InputSelect" of register "IoChannelSelect".
**
** Select the TS input channels for TSD2
** - '00': Select input channel A
** - '01': Select input channel B
** - '10' or '11': Select input channel C
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd2InputSelect" consists of the bits 5..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000030UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_72"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_72" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_72")))
#endif

uint32_t FREG_TSD_GetIoChannelSelect_Tsd2InputSelect( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT));
    value = ( value & 0x00000030UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd1InputSelect" of register "IoChannelSelect".
**
** Select the TS input channels for TSD1
** - '00': Select input channel A
** - '01': Select input channel B
** - '10' or '11': Select input channel C
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd1InputSelect" consists of the bits 3..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x0000000CUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_73"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_73" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_73")))
#endif

uint32_t FREG_TSD_GetIoChannelSelect_Tsd1InputSelect( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT));
    value = ( value & 0x0000000CUL ) >> 2;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd0InputSelect" of register "IoChannelSelect".
**
** Select the TS input channels for TSD0
** - '00': Select input channel A
** - '01': Select input channel B
** - '10' or '11': Select input channel C
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd0InputSelect" consists of the bits 1..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000003UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_74"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_74" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_74")))
#endif

uint32_t FREG_TSD_GetIoChannelSelect_Tsd0InputSelect( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD_IOCHANNELSELECT));
    value = ( value & 0x00000003UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketStc".
**
** This function reads the value from the register "PacketStc".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_75"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_75" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_75")))
#endif

uint32_t FREG_TSD01_GetPacketStc( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PACKETSTC));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketStcBase" of register "PacketStc".
**
** The lower 23 bits of STC base which was sampled as the packet was received.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketStcBase" consists of the bits 31..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0xFFFFFE00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_76"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_76" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_76")))
#endif

uint32_t FREG_TSD01_GetPacketStc_PacketStcBase( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PACKETSTC));
    value = ( value & 0xFFFFFE00UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketStcExt" of register "PacketStc".
**
** The STC extension which was sampled as the packet was received.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketStcExt" consists of the bits 8..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000001FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_77"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_77" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_77")))
#endif

uint32_t FREG_TSD01_GetPacketStc_PacketStcExt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PACKETSTC));
    value = ( value & 0x000001FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "CurrentStcLower".
**
** This function writes the given value to the register "CurrentStcLower".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_78"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_78" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_78")))
#endif

void FREG_TSD01_SetCurrentStcLower( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_CURRENTSTCLOWER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCLOWER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CurrentStcBaseLower" of register "CurrentStcLower".
**
** The lower 23 bits of current STC base.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CurrentStcBaseLower" consists of the bits 31..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0xFFFFFE00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_79"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_79" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_79")))
#endif

void FREG_TSD01_SetCurrentStcLower_CurrentStcBaseLower( uint32_t value )
{
    register uint32_t mask = 0xFFFFFE00UL;
    value = ( value << 9 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCLOWER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_CURRENTSTCLOWER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCLOWER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CurrentStcExt" of register "CurrentStcLower".
**
** The current STC extension.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CurrentStcExt" consists of the bits 8..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000001FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_80"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_80" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_80")))
#endif

void FREG_TSD01_SetCurrentStcLower_CurrentStcExt( uint32_t value )
{
    register uint32_t mask = 0x000001FFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCLOWER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_CURRENTSTCLOWER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCLOWER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "CurrentStcLower".
**
** This function reads the value from the register "CurrentStcLower".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_81"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_81" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_81")))
#endif

uint32_t FREG_TSD01_GetCurrentStcLower( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCLOWER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CurrentStcBaseLower" of register "CurrentStcLower".
**
** The lower 23 bits of current STC base.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "CurrentStcBaseLower" consists of the bits 31..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0xFFFFFE00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_82"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_82" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_82")))
#endif

uint32_t FREG_TSD01_GetCurrentStcLower_CurrentStcBaseLower( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCLOWER));
    value = ( value & 0xFFFFFE00UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CurrentStcExt" of register "CurrentStcLower".
**
** The current STC extension.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "CurrentStcExt" consists of the bits 8..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000001FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_83"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_83" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_83")))
#endif

uint32_t FREG_TSD01_GetCurrentStcLower_CurrentStcExt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCLOWER));
    value = ( value & 0x000001FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "CurrentStcUpper".
**
** This function writes the given value to the register "CurrentStcUpper".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_84"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_84" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_84")))
#endif

void FREG_TSD01_SetCurrentStcUpper( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_CURRENTSTCUPPER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCUPPER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CurrentStcBaseUpper" of register "CurrentStcUpper".
**
** The upper 10 bits of current STC base.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CurrentStcBaseUpper" consists of the bits 9..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000003FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_85"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_85" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_85")))
#endif

void FREG_TSD01_SetCurrentStcUpper_CurrentStcBaseUpper( uint32_t value )
{
    register uint32_t mask = 0x000003FFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCUPPER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_CURRENTSTCUPPER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCUPPER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "CurrentStcUpper".
**
** This function reads the value from the register "CurrentStcUpper".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_86"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_86" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_86")))
#endif

uint32_t FREG_TSD01_GetCurrentStcUpper( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCUPPER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CurrentStcBaseUpper" of register "CurrentStcUpper".
**
** The upper 10 bits of current STC base.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "CurrentStcBaseUpper" consists of the bits 9..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000003FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_87"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_87" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_87")))
#endif

uint32_t FREG_TSD01_GetCurrentStcUpper_CurrentStcBaseUpper( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_CURRENTSTCUPPER));
    value = ( value & 0x000003FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PcrLower".
**
** This function reads the value from the register "PcrLower".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_88"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_88" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_88")))
#endif

uint32_t FREG_TSD01_GetPcrLower( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PCRLOWER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PcrBaseLower" of register "PcrLower".
**
** The lower 23 bits of PCR base found in the packet.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PcrBaseLower" consists of the bits 31..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0xFFFFFE00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_89"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_89" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_89")))
#endif

uint32_t FREG_TSD01_GetPcrLower_PcrBaseLower( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PCRLOWER));
    value = ( value & 0xFFFFFE00UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PcrExt" of register "PcrLower".
**
** The PCR extension found in the packet
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PcrExt" consists of the bits 8..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000001FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_90"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_90" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_90")))
#endif

uint32_t FREG_TSD01_GetPcrLower_PcrExt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PCRLOWER));
    value = ( value & 0x000001FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PcrUpper".
**
** This function reads the value from the register "PcrUpper".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_91"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_91" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_91")))
#endif

uint32_t FREG_TSD01_GetPcrUpper( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PCRUPPER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PcrBaseUpper" of register "PcrUpper".
**
** The upper 10 bits of PCR base.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PcrBaseUpper" consists of the bits 9..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000003FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_92"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_92" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_92")))
#endif

uint32_t FREG_TSD01_GetPcrUpper_PcrBaseUpper( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PCRUPPER));
    value = ( value & 0x000003FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LoadPcr".
**
** This function writes the given value to the register "LoadPcr".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_93"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_93" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_93")))
#endif

void FREG_TSD01_SetLoadPcr( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_LOADPCR, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_LOADPCR)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "LoadPcrFlag" of register "LoadPcr".
**
** Indicates if next PCR should be loaded or not:
** - '1': Load the next PCR extracted after this bit is set to 1 to the two CURRENT_STC registers.
**  After the data is loaded, this bit will be automatically cleared.
** - '0': Don't load.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "LoadPcrFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_94"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_94" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_94")))
#endif

void FREG_TSD01_SetLoadPcr_LoadPcrFlag( uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_LOADPCR)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_LOADPCR, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_LOADPCR)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LoadPcr".
**
** This function reads the value from the register "LoadPcr".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_95"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_95" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_95")))
#endif

uint32_t FREG_TSD01_GetLoadPcr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_LOADPCR));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "LoadPcrFlag" of register "LoadPcr".
**
** Indicates if next PCR should be loaded or not:
** - '1': Load the next PCR extracted after this bit is set to 1 to the two CURRENT_STC registers.
**  After the data is loaded, this bit will be automatically cleared.
** - '0': Don't load.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "LoadPcrFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_96"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_96" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_96")))
#endif

uint32_t FREG_TSD01_GetLoadPcr_LoadPcrFlag( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_LOADPCR));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Status".
**
** This function reads the value from the register "Status".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_97"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_97" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_97")))
#endif

uint32_t FREG_TSD01_GetStatus( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_STATUS));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TsdActive" of register "Status".
**
** This bit indicates if any packet is being processed by TSD0 or TSD1.
**
** - '1':YES
** - '0':NO.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "TsdActive" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_98"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_98" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_98")))
#endif

uint32_t FREG_TSD01_GetStatus_TsdActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_STATUS));
    value = ( value & 0x00000400UL ) >> 10;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidMatchValid" of register "Status".
**
** This bit indicates if the PID_MATCH bit in this register  is valid or not.
**
** - '1': valid
** - '0': invalid
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidMatchValid" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_99"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_99" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_99")))
#endif

uint32_t FREG_TSD01_GetStatus_PidMatchValid( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_STATUS));
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidMatch" of register "Status".
**
** If PID_MATCH_VALID bit is '1', PID_MATCH indicates if the PID of the incoming packet matches any PID configured ('1': match.
**  '0': doesn't match).
** If PID_MATCH_VALID bit is '0', PID_MATCH is always set to '0'.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidMatch" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_100"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_100" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_100")))
#endif

uint32_t FREG_TSD01_GetStatus_PidMatch( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_STATUS));
    value = ( value & 0x00000100UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd1Select" of register "Status".
**
** The register TSD_STATUS is shared by TSD0 and TSD1.
**  This bit indicates which TSD is currently active and to which TSD the following PID_INDEX belongs to.
** - '0': the active PID channel is in TSD0.
** - '1': the active PID channel is in TSD1.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd1Select" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_101"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_101" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_101")))
#endif

uint32_t FREG_TSD01_GetStatus_Tsd1Select( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_STATUS));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidIndex" of register "Status".
**
** The PID_index ranges from 0 to 31.
**  If TSD_ACTIVE is '1', PID_INDEX indicates which PID is under processing.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_102"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_102" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_102")))
#endif

uint32_t FREG_TSD01_GetStatus_PidIndex( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_STATUS));
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PesCfg".
**
** This function writes the given value to the index-th entry of the register
** array PesCfg.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_103"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_103" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_103")))
#endif

void FREG_TSD01_SetPesCfg( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Tsd1Select" of register "PesCfg".
**
** TSD1 select signal.
**  This bit indicates in which TSD (TSD0 or TSD1) the PID channel specified by PID_INDEX below is configured.
** - '0' : TSD0 is selected.
** - '1' : TSD1 is selected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Tsd1Select" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_104"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_104" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_104")))
#endif

void FREG_TSD01_SetPesCfg_Tsd1Select( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000200UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 9 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidIndex" of register "PesCfg".
**
** The PID channel index.
**  These 5 bits defines which PID channel shall be processed by this PES parser. The bit TSD1_SELECT above indicates in which TSD (TSD0 or TSD1) the PID channel is configured.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidIndex" consists of the bits 8..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x000001F0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_105"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_105" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_105")))
#endif

void FREG_TSD01_SetPesCfg_PidIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000001F0UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "RemovePesHeader" of register "PesCfg".
**
** Remove PES packet header
** - '0' : don't remove the header.
**
** - '1' : remove the header.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "RemovePesHeader" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_106"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_106" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_106")))
#endif

void FREG_TSD01_SetPesCfg_RemovePesHeader( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000004UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 2 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NewPtsIrqEn" of register "PesCfg".
**
** NEW_PTS_IRQ enable
** - '0' : disable
** - '1' : enable
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NewPtsIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_107"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_107" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_107")))
#endif

void FREG_TSD01_SetPesCfg_NewPtsIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PesEn" of register "PesCfg".
**
** PES_PARSER enable
** - '0' : disable
** - '1' : enable
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PesEn" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_108"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_108" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_108")))
#endif

void FREG_TSD01_SetPesCfg_PesEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PesCfg".
**
** This function reads the value from the index-th entry of the register
** array PesCfg.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_109"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_109" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_109")))
#endif

uint32_t FREG_TSD01_GetPesCfg( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd1Select" of register "PesCfg".
**
** TSD1 select signal.
**  This bit indicates in which TSD (TSD0 or TSD1) the PID channel specified by PID_INDEX below is configured.
** - '0' : TSD0 is selected.
** - '1' : TSD1 is selected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd1Select" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_110"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_110" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_110")))
#endif

uint32_t FREG_TSD01_GetPesCfg_Tsd1Select( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC)));
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidIndex" of register "PesCfg".
**
** The PID channel index.
**  These 5 bits defines which PID channel shall be processed by this PES parser. The bit TSD1_SELECT above indicates in which TSD (TSD0 or TSD1) the PID channel is configured.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidIndex" consists of the bits 8..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x000001F0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_111"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_111" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_111")))
#endif

uint32_t FREG_TSD01_GetPesCfg_PidIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC)));
    value = ( value & 0x000001F0UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "RemovePesHeader" of register "PesCfg".
**
** Remove PES packet header
** - '0' : don't remove the header.
**
** - '1' : remove the header.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "RemovePesHeader" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_112"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_112" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_112")))
#endif

uint32_t FREG_TSD01_GetPesCfg_RemovePesHeader( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC)));
    value = ( value & 0x00000004UL ) >> 2;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NewPtsIrqEn" of register "PesCfg".
**
** NEW_PTS_IRQ enable
** - '0' : disable
** - '1' : enable
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NewPtsIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_113"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_113" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_113")))
#endif

uint32_t FREG_TSD01_GetPesCfg_NewPtsIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC)));
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PesEn" of register "PesCfg".
**
** PES_PARSER enable
** - '0' : disable
** - '1' : enable
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PesEn" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_114"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_114" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_114")))
#endif

uint32_t FREG_TSD01_GetPesCfg_PesEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PESCFG+(index*0xC)));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Pts_0".
**
** This function reads the value from the index-th entry of the register
** array Pts_0.
**
** The 32 LSBs of PTS value.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_115"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_115" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_115")))
#endif

uint32_t FREG_TSD01_GetPts_0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PTS_0+(index*0xC)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PtsLower" of register "Pts_0".
**
** The 32 LSBs of PTS value.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PtsLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_116"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_116" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_116")))
#endif

uint32_t FREG_TSD01_GetPts_0_PtsLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PTS_0+(index*0xC)));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Pts_1".
**
** This function reads the value from the index-th entry of the register
** array Pts_1.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_117"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_117" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_117")))
#endif

uint32_t FREG_TSD01_GetPts_1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PTS_1+(index*0xC)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PtsMsb" of register "Pts_1".
**
** The MSB of PTS value (bit 32).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PtsMsb" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_118"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_118" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_118")))
#endif

uint32_t FREG_TSD01_GetPts_1_PtsMsb( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_PTS_1+(index*0xC)));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PacketStcMode".
**
** This function writes the given value to the register "PacketStcMode".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_119"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_119" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_119")))
#endif

void FREG_TSD01_SetPacketStcMode( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PACKETSTCMODE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PACKETSTCMODE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "StoreAllPacketStc" of register "PacketStcMode".
**
** Specifies when the register PACKET_STC shall be updated:
** - '0' : update the register PACKET_STC only for packets with PCR field.
**
** - '1' : update the register PACKET_STC for all packets.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "StoreAllPacketStc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_120"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_120" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_120")))
#endif

void FREG_TSD01_SetPacketStcMode_StoreAllPacketStc( uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_PACKETSTCMODE)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_PACKETSTCMODE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_PACKETSTCMODE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketStcMode".
**
** This function reads the value from the register "PacketStcMode".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_121"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_121" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_121")))
#endif

uint32_t FREG_TSD01_GetPacketStcMode( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PACKETSTCMODE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "StoreAllPacketStc" of register "PacketStcMode".
**
** Specifies when the register PACKET_STC shall be updated:
** - '0' : update the register PACKET_STC only for packets with PCR field.
**
** - '1' : update the register PACKET_STC for all packets.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "StoreAllPacketStc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_122"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_122" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_122")))
#endif

uint32_t FREG_TSD01_GetPacketStcMode_StoreAllPacketStc( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_PACKETSTCMODE));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidValue".
**
** This function writes the given value to the index-th entry of the register
** array PidValue.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_123"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_123" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_123")))
#endif

void FREG_TSD0_SetPidValue( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return;
    #endif
    FREG_TSD0_PidValueMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDVALUE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDVALUE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidBit" of register "PidValue".
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidBit" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_124"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_124" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_124")))
#endif

void FREG_TSD0_SetPidValue_PidBit( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_PidValueMirror[index] & ~mask;
    FREG_TSD0_PidValueMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDVALUE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDVALUE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidValue".
**
** This function reads the value from the index-th entry of the register
** array PidValue.
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_125"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_125" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_125")))
#endif

uint32_t FREG_TSD0_GetmPidValue( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidValueMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidBit" of register "PidValue".
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidBit" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_126"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_126" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_126")))
#endif

uint32_t FREG_TSD0_GetmPidValue_PidBit( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 13 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidValueMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidConfig_1".
**
** This function writes the given value to the index-th entry of the register
** array PidConfig_1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_127"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_127" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_127")))
#endif

void FREG_TSD0_SetPidConfig_1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    FREG_TSD0_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DuplicateIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for duplicate packet IRQ.
**  If the bit DUPLICATE_CHECK in TSD0_PID_config_2 is set to 1, duplicate packets will be removed. If the bit DUPLICATE_IRQ_EN is also set to 1, a DUPLICATE_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DuplicateIrqEn" consists of the bits 16..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00010000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_128"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_128" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_128")))
#endif

void FREG_TSD0_SetPidConfig_1_DuplicateIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00010000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD0_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "BufferIndex" of register "PidConfig_1".
**
** If the OFFSET_MODE (bit 7 of this register, see below) is set to '0', BUFFER_INDEX specifies to which buffer the data of this PID channel shall be stored.
**  If data from multiple PID channels shall be stored in the same buffer, these PID channels' BUFFER_INDEX shall be set to the same value.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "BufferIndex" consists of the bits 12..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00001F00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_129"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_129" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_129")))
#endif

void FREG_TSD0_SetPidConfig_1_BufferIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00001F00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD0_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OffsetMode" of register "PidConfig_1".
**
** This bit is ONLY active for PSI packets.
**
** - '1': the section data of this PID channel will be stored
** to the buffer with the index K, where k =
** BUFFER_INDEX + offset. Here offset = (matched
** filter target index). If more than one filter targets
** match the incoming section, the lowest target index
** will be used as offset.
** - '0':  the section data will be stored to buffer specified
** with BUFFER_INDEX.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OffsetMode" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_130"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_130" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_130")))
#endif

void FREG_TSD0_SetPidConfig_1_OffsetMode( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD0_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pcr1AfLt7IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** PCR flag is 1 (PCR_1), but adaptation field length is less than 7 (AF_LT_7).
**  In this case, no PCR will be extracted even if the bit EXTRACT_PCR is set to 1. The adapation field will be handeled as if the PCR flag is 0.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pcr1AfLt7IrqEn" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_131"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_131" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_131")))
#endif

void FREG_TSD0_SetPidConfig_1_Pcr1AfLt7IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000040UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    value |= FREG_TSD0_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pl1AfGt183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 1 (PL_1), but adaptation field byte number is greater than 183 (AF_GT183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pl1AfGt183IrqEn" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_132"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_132" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_132")))
#endif

void FREG_TSD0_SetPidConfig_1_Pl1AfGt183IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    value |= FREG_TSD0_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pl0AfNe183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field length is not equal 183 (AF_NE183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pl0AfNe183IrqEn" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_133"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_133" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_133")))
#endif

void FREG_TSD0_SetPidConfig_1_Pl0AfNe183IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    value |= FREG_TSD0_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NullPacketIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for NULL packet IRQ.
**  Null packets (both of the adapation field flag and payload flag in packet header are 0) are always removed. If this bit is set to 1, a NULL_PACKET_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NullPacketIrqEn" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_134"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_134" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_134")))
#endif

void FREG_TSD0_SetPidConfig_1_NullPacketIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 3 ) & mask;
    value |= FREG_TSD0_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DescramblerIndex" of register "PidConfig_1".
**
** Ranges from 0 to 7.
**  Indicates which one of the 8 descramlbers shall be used to descramble this PID channel. The descramble keys are definded through the register DSC_ODD_KEY_UPPER, DSC_ODD_KEY_LOWER, DSC_EVEN_KEY_UPPER and DSC_EVEN_KEY_LOWER. The odd/even flag of scrambling control field in the TS packet header decides if the odd or the even key of the corresponding descrambler is used to descramble the actual TS-packet.
**
** To activate the selected descrambler, the bit BYPASS_DSC in the register PID_CONFIG_2 must be set to 0.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DescramblerIndex" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_135"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_135" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_135")))
#endif

void FREG_TSD0_SetPidConfig_1_DescramblerIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000007UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidConfig_1".
**
** This function reads the value from the index-th entry of the register
** array PidConfig_1.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_136"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_136" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_136")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DuplicateIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for duplicate packet IRQ.
**  If the bit DUPLICATE_CHECK in TSD0_PID_config_2 is set to 1, duplicate packets will be removed. If the bit DUPLICATE_IRQ_EN is also set to 1, a DUPLICATE_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DuplicateIrqEn" consists of the bits 16..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00010000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_137"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_137" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_137")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_1_DuplicateIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_1Mirror[index];
    value = ( value & 0x00010000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "BufferIndex" of register "PidConfig_1".
**
** If the OFFSET_MODE (bit 7 of this register, see below) is set to '0', BUFFER_INDEX specifies to which buffer the data of this PID channel shall be stored.
**  If data from multiple PID channels shall be stored in the same buffer, these PID channels' BUFFER_INDEX shall be set to the same value.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "BufferIndex" consists of the bits 12..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00001F00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_138"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_138" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_138")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_1_BufferIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_1Mirror[index];
    value = ( value & 0x00001F00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OffsetMode" of register "PidConfig_1".
**
** This bit is ONLY active for PSI packets.
**
** - '1': the section data of this PID channel will be stored
** to the buffer with the index K, where k =
** BUFFER_INDEX + offset. Here offset = (matched
** filter target index). If more than one filter targets
** match the incoming section, the lowest target index
** will be used as offset.
** - '0':  the section data will be stored to buffer specified
** with BUFFER_INDEX.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OffsetMode" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_139"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_139" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_139")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_1_OffsetMode( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_1Mirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pcr1AfLt7IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** PCR flag is 1 (PCR_1), but adaptation field length is less than 7 (AF_LT_7).
**  In this case, no PCR will be extracted even if the bit EXTRACT_PCR is set to 1. The adapation field will be handeled as if the PCR flag is 0.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pcr1AfLt7IrqEn" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_140"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_140" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_140")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_1_Pcr1AfLt7IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_1Mirror[index];
    value = ( value & 0x00000040UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pl1AfGt183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 1 (PL_1), but adaptation field byte number is greater than 183 (AF_GT183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pl1AfGt183IrqEn" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_141"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_141" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_141")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_1_Pl1AfGt183IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_1Mirror[index];
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pl0AfNe183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field length is not equal 183 (AF_NE183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pl0AfNe183IrqEn" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_142"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_142" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_142")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_1_Pl0AfNe183IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_1Mirror[index];
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NullPacketIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for NULL packet IRQ.
**  Null packets (both of the adapation field flag and payload flag in packet header are 0) are always removed. If this bit is set to 1, a NULL_PACKET_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NullPacketIrqEn" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_143"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_143" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_143")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_1_NullPacketIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_1Mirror[index];
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DescramblerIndex" of register "PidConfig_1".
**
** Ranges from 0 to 7.
**  Indicates which one of the 8 descramlbers shall be used to descramble this PID channel. The descramble keys are definded through the register DSC_ODD_KEY_UPPER, DSC_ODD_KEY_LOWER, DSC_EVEN_KEY_UPPER and DSC_EVEN_KEY_LOWER. The odd/even flag of scrambling control field in the TS packet header decides if the odd or the even key of the corresponding descrambler is used to descramble the actual TS-packet.
**
** To activate the selected descrambler, the bit BYPASS_DSC in the register PID_CONFIG_2 must be set to 0.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DescramblerIndex" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_144"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_144" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_144")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_1_DescramblerIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_1Mirror[index];
    value = ( value & 0x00000007UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidConfig_2".
**
** This function writes the given value to the index-th entry of the register
** array PidConfig_2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_145"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_145" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_145")))
#endif

void FREG_TSD0_SetPidConfig_2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PtrTarget" of register "PidConfig_2".
**
** Pointer to the first target in SF_target_RAM.
**
** PTR_TARGET ranges from 0 through127. This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0.
**
** For example, if the first target is stored in line 25 of SF_target_RAM, then PTR_TARGET shall be set to 25.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PtrTarget" consists of the bits 31..25,
**       the given bitgroup value will be shifted left by 25 bits and
**       masked using the bitmask 0xFE000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_146"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_146" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_146")))
#endif

void FREG_TSD0_SetPidConfig_2_PtrTarget( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFE000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 25 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NTarget" of register "PidConfig_2".
**
** Number of filter target.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. Let the number of target be k. k is coded and stored to N_TARGET. Attention: N_TARGET is not binary-coded decimal format of k (see below)!! For example, if k = 4, N_TARGET is '1000' (decimal 8) not '0100' (decimal 4).
** - k= 1: N_TARGET='0001'
** - k= 2: N_TARGET='0010'
** - k= 4: N_TARGET='1000'
** - k= 8: N_TARGET='1001'
** - k=12: N_TARGET='1010'
** - k=16: N_TARGET='1011'
** - k=20: N_TARGET='1100'
** - k=24: N_TARGET='1101'
** - k=28: N_TARGET='1110'
** - k=32: N_TARGET='1111'
** (Coding rules:
** N_TARGET[3] = 0 and N_TARGET[2:0] = k, if k<4.
** N_TARGET[3] = 1 and N_TARGET[2:0] = (k/4)-1, if k4.)
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NTarget" consists of the bits 24..21,
**       the given bitgroup value will be shifted left by 21 bits and
**       masked using the bitmask 0x01E00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_147"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_147" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_147")))
#endif

void FREG_TSD0_SetPidConfig_2_NTarget( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x01E00000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 21 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TargetLength" of register "PidConfig_2".
**
** Filter target length.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. All filter targets of a PID channel shall have the same length. TARGET_LENGTH ranges from 1 to 25 (including table ID byte, but excluding the two section length bytes).
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TargetLength" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_148"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_148" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_148")))
#endif

void FREG_TSD0_SetPidConfig_2_TargetLength( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x001F0000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "StoreCompletePacket" of register "PidConfig_2".
**
** Indicate if TS packets header (4 bytes) and adaptation field shall be stored.
**
** - '0': Only payload shall be stored (packet header and adaptation field shall be removed).
** - '1': The complete packet (packet header, adaptation field and payload) shall be stored.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "StoreCompletePacket" consists of the bits 15..15,
**       the given bitgroup value will be shifted left by 15 bits and
**       masked using the bitmask 0x00008000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_149"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_149" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_149")))
#endif

void FREG_TSD0_SetPidConfig_2_StoreCompletePacket( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00008000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 15 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PusIrqEn" of register "PidConfig_2".
**
** Payload Unit Start (PUS) interrupt enable:
** - '0': disabled.
**
** - '1': enabled.
** If the Payload Unit Start Indicator of a transport stream packet is '1' and PUS_IRQ_EN is '1' then a PUS_IRQ will be triggered.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PusIrqEn" consists of the bits 14..14,
**       the given bitgroup value will be shifted left by 14 bits and
**       masked using the bitmask 0x00004000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_150"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_150" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_150")))
#endif

void FREG_TSD0_SetPidConfig_2_PusIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00004000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 14 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no packet is received during a certain time (defined in the register INPUT_TIMEOUT), an INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InputTimeoutIrqEn" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_151"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_151" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_151")))
#endif

void FREG_TSD0_SetPidConfig_2_InputTimeoutIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00002000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 13 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ValidInputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no valid packet is received during a certain time (defined the in register VALID_INPUT_TIMEOUT), an VALID_INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ValidInputTimeoutIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_152"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_152" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_152")))
#endif

void FREG_TSD0_SetPidConfig_2_ValidInputTimeoutIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00001000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 12 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NewPcrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for NEW_PCR_IRQ.
**  If a  new PCR is extracted, a NEW_PCR_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NewPcrIrqEn" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_153"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_153" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_153")))
#endif

void FREG_TSD0_SetPidConfig_2_NewPcrIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000800UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 11 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CcIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CONTINUITY_COUNTER_ERROR_IRQ.
**  If CC_CHECK is set and a continuity counter error is found,  a CONTINUITY_COUNTER_ERROR_IRQ will be generated.
** - '1': enable interrupt
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CcIrqEn" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_154"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_154" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_154")))
#endif

void FREG_TSD0_SetPidConfig_2_CcIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000400UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 10 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SectionEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for SECTION_END_IRQ.
**  If an incoming section matches at least one filter target and its end is detected, a SECTION_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SectionEndIrqEn" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_155"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_155" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_155")))
#endif

void FREG_TSD0_SetPidConfig_2_SectionEndIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000200UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 9 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PACKET_END_IRQ.
**  If the PID of an incoming packet matches the PID of this channel and all bytes in this packet was sent to Buffer Mangager, a PACKET_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketEndIrqEn" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_156"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_156" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_156")))
#endif

void FREG_TSD0_SetPidConfig_2_PacketEndIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000100UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ScrambledPacketIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for scrambled transport packet.
**  If the scrambling controll flag in TS packet header is set to 1, a SCRAMBLED_PACKET_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ScrambledPacketIrqEn" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_157"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_157" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_157")))
#endif

void FREG_TSD0_SetPidConfig_2_ScrambledPacketIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CcCheck" of register "PidConfig_2".
**
** Continuity Counter error  check.
**  If a TS packet has payload, its continuity counter shall be incremented by 1 or equals to that of the previous packet. If a TS packet has only adaptation field, its continuity counter shall not be incremented. If any of the conditions is not filled, the TS packet will be discarded and the corresponding PID channel will be disabled.
** - '0': don't check
** - '1': if CC error detected, discard the packet and disable the corresponding PID channel.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CcCheck" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_158"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_158" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_158")))
#endif

void FREG_TSD0_SetPidConfig_2_CcCheck( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000040UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DuplicateCheck" of register "PidConfig_2".
**
** Duplicate packet check.
**  If a TS packet has payload but its continuity counter is equal to that of the previous packet, then this packet is a duplicate packet. If this bit is set, such packets will be discarded.
** - '0': don't check.
** - '1': discard duplicate packet.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DuplicateCheck" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_159"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_159" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_159")))
#endif

void FREG_TSD0_SetPidConfig_2_DuplicateCheck( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PesPayload" of register "PidConfig_2".
**
** Specifies type of transport packet payload
** - '0': PSI payload (section data)
** - '1': PES payload (video, MPEG audio,
** teletext, closed caption)
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PesPayload" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_160"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_160" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_160")))
#endif

void FREG_TSD0_SetPidConfig_2_PesPayload( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ExtractPcr" of register "PidConfig_2".
**
** Enable the extraction of PCR field from adaptation field:
** - '0': PCR should be skipped
** - '1': PCR should be extracted.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ExtractPcr" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_161"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_161" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_161")))
#endif

void FREG_TSD0_SetPidConfig_2_ExtractPcr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 3 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PsiCcCheckMode" of register "PidConfig_2".
**
** Specify the Continuity Counter (CC) Check Mode for PSI packets (therefore ONLY active for PSI packets):
** - '1': always check continuity counter if CC_CHECK is
** enabled.
**
** - '0': only check continuity counter if check is enabled and section filter is active.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PsiCcCheckMode" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_162"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_162" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_162")))
#endif

void FREG_TSD0_SetPidConfig_2_PsiCcCheckMode( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000004UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 2 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CrcErrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CRC error.
**  If the syntax indicator in a section is set to 1 and the CRC  in this section is wrong, a CRC_ERROR_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CrcErrIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_163"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_163" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_163")))
#endif

void FREG_TSD0_SetPidConfig_2_CrcErrIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "BypassDsc" of register "PidConfig_2".
**
** Bypass DVB descrambler.
**
** - '0': DVB descrambler not bypassed. Descramlbe key and the DESCRAMBLER_INDEX in CONFIG_1 must be programmed. If the scrambling control flag in the TS packet header is not set, the descrambler will not be activated even if this bit is set to 0. Therefore, this bit can be set to 0 in all default configurations and it shall be set to 1 only if descrambler must be deactivated.
** - '1': DVB descrambler is bypassed.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "BypassDsc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_164"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_164" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_164")))
#endif

void FREG_TSD0_SetPidConfig_2_BypassDsc( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD0_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidConfig_2".
**
** This function reads the value from the index-th entry of the register
** array PidConfig_2.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_165"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_165" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_165")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PtrTarget" of register "PidConfig_2".
**
** Pointer to the first target in SF_target_RAM.
**
** PTR_TARGET ranges from 0 through127. This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0.
**
** For example, if the first target is stored in line 25 of SF_target_RAM, then PTR_TARGET shall be set to 25.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PtrTarget" consists of the bits 31..25,
**       the given bitgroup value will be shifted left by 25 bits and
**       masked using the bitmask 0xFE000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_166"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_166" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_166")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_PtrTarget( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0xFE000000UL ) >> 25;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NTarget" of register "PidConfig_2".
**
** Number of filter target.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. Let the number of target be k. k is coded and stored to N_TARGET. Attention: N_TARGET is not binary-coded decimal format of k (see below)!! For example, if k = 4, N_TARGET is '1000' (decimal 8) not '0100' (decimal 4).
** - k= 1: N_TARGET='0001'
** - k= 2: N_TARGET='0010'
** - k= 4: N_TARGET='1000'
** - k= 8: N_TARGET='1001'
** - k=12: N_TARGET='1010'
** - k=16: N_TARGET='1011'
** - k=20: N_TARGET='1100'
** - k=24: N_TARGET='1101'
** - k=28: N_TARGET='1110'
** - k=32: N_TARGET='1111'
** (Coding rules:
** N_TARGET[3] = 0 and N_TARGET[2:0] = k, if k<4.
** N_TARGET[3] = 1 and N_TARGET[2:0] = (k/4)-1, if k4.)
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NTarget" consists of the bits 24..21,
**       the given bitgroup value will be shifted left by 21 bits and
**       masked using the bitmask 0x01E00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_167"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_167" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_167")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_NTarget( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x01E00000UL ) >> 21;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TargetLength" of register "PidConfig_2".
**
** Filter target length.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. All filter targets of a PID channel shall have the same length. TARGET_LENGTH ranges from 1 to 25 (including table ID byte, but excluding the two section length bytes).
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TargetLength" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_168"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_168" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_168")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_TargetLength( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x001F0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "StoreCompletePacket" of register "PidConfig_2".
**
** Indicate if TS packets header (4 bytes) and adaptation field shall be stored.
**
** - '0': Only payload shall be stored (packet header and adaptation field shall be removed).
** - '1': The complete packet (packet header, adaptation field and payload) shall be stored.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "StoreCompletePacket" consists of the bits 15..15,
**       the given bitgroup value will be shifted left by 15 bits and
**       masked using the bitmask 0x00008000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_169"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_169" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_169")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_StoreCompletePacket( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00008000UL ) >> 15;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PusIrqEn" of register "PidConfig_2".
**
** Payload Unit Start (PUS) interrupt enable:
** - '0': disabled.
**
** - '1': enabled.
** If the Payload Unit Start Indicator of a transport stream packet is '1' and PUS_IRQ_EN is '1' then a PUS_IRQ will be triggered.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PusIrqEn" consists of the bits 14..14,
**       the given bitgroup value will be shifted left by 14 bits and
**       masked using the bitmask 0x00004000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_170"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_170" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_170")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_PusIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00004000UL ) >> 14;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no packet is received during a certain time (defined in the register INPUT_TIMEOUT), an INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "InputTimeoutIrqEn" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_171"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_171" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_171")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_InputTimeoutIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00002000UL ) >> 13;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ValidInputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no valid packet is received during a certain time (defined the in register VALID_INPUT_TIMEOUT), an VALID_INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ValidInputTimeoutIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_172"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_172" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_172")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_ValidInputTimeoutIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00001000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NewPcrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for NEW_PCR_IRQ.
**  If a  new PCR is extracted, a NEW_PCR_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NewPcrIrqEn" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_173"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_173" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_173")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_NewPcrIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000800UL ) >> 11;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CcIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CONTINUITY_COUNTER_ERROR_IRQ.
**  If CC_CHECK is set and a continuity counter error is found,  a CONTINUITY_COUNTER_ERROR_IRQ will be generated.
** - '1': enable interrupt
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CcIrqEn" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_174"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_174" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_174")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_CcIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000400UL ) >> 10;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SectionEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for SECTION_END_IRQ.
**  If an incoming section matches at least one filter target and its end is detected, a SECTION_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SectionEndIrqEn" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_175"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_175" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_175")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_SectionEndIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PACKET_END_IRQ.
**  If the PID of an incoming packet matches the PID of this channel and all bytes in this packet was sent to Buffer Mangager, a PACKET_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketEndIrqEn" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_176"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_176" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_176")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_PacketEndIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000100UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ScrambledPacketIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for scrambled transport packet.
**  If the scrambling controll flag in TS packet header is set to 1, a SCRAMBLED_PACKET_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ScrambledPacketIrqEn" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_177"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_177" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_177")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_ScrambledPacketIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CcCheck" of register "PidConfig_2".
**
** Continuity Counter error  check.
**  If a TS packet has payload, its continuity counter shall be incremented by 1 or equals to that of the previous packet. If a TS packet has only adaptation field, its continuity counter shall not be incremented. If any of the conditions is not filled, the TS packet will be discarded and the corresponding PID channel will be disabled.
** - '0': don't check
** - '1': if CC error detected, discard the packet and disable the corresponding PID channel.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CcCheck" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_178"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_178" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_178")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_CcCheck( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000040UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DuplicateCheck" of register "PidConfig_2".
**
** Duplicate packet check.
**  If a TS packet has payload but its continuity counter is equal to that of the previous packet, then this packet is a duplicate packet. If this bit is set, such packets will be discarded.
** - '0': don't check.
** - '1': discard duplicate packet.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DuplicateCheck" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_179"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_179" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_179")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_DuplicateCheck( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PesPayload" of register "PidConfig_2".
**
** Specifies type of transport packet payload
** - '0': PSI payload (section data)
** - '1': PES payload (video, MPEG audio,
** teletext, closed caption)
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PesPayload" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_180"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_180" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_180")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_PesPayload( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ExtractPcr" of register "PidConfig_2".
**
** Enable the extraction of PCR field from adaptation field:
** - '0': PCR should be skipped
** - '1': PCR should be extracted.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ExtractPcr" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_181"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_181" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_181")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_ExtractPcr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PsiCcCheckMode" of register "PidConfig_2".
**
** Specify the Continuity Counter (CC) Check Mode for PSI packets (therefore ONLY active for PSI packets):
** - '1': always check continuity counter if CC_CHECK is
** enabled.
**
** - '0': only check continuity counter if check is enabled and section filter is active.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PsiCcCheckMode" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_182"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_182" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_182")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_PsiCcCheckMode( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000004UL ) >> 2;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CrcErrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CRC error.
**  If the syntax indicator in a section is set to 1 and the CRC  in this section is wrong, a CRC_ERROR_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CrcErrIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_183"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_183" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_183")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_CrcErrIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "BypassDsc" of register "PidConfig_2".
**
** Bypass DVB descrambler.
**
** - '0': DVB descrambler not bypassed. Descramlbe key and the DESCRAMBLER_INDEX in CONFIG_1 must be programmed. If the scrambling control flag in the TS packet header is not set, the descrambler will not be activated even if this bit is set to 0. Therefore, this bit can be set to 0 in all default configurations and it shall be set to 1 only if descrambler must be deactivated.
** - '1': DVB descrambler is bypassed.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "BypassDsc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_184"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_184" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_184")))
#endif

uint32_t FREG_TSD0_GetmPidConfig_2_BypassDsc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_PidConfig_2Mirror[index];
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscOddKeyUpper".
**
** This function writes the given value to the index-th entry of the register
** array DscOddKeyUpper.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_185"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_185" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_185")))
#endif

void FREG_TSD0_SetDscOddKeyUpper( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD0_DscOddKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_DSCODDKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_DSCODDKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OddKeyUpper" of register "DscOddKeyUpper".
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OddKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_186"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_186" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_186")))
#endif

void FREG_TSD0_SetDscOddKeyUpper_OddKeyUpper( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_DscOddKeyUpperMirror[index] & ~mask;
    FREG_TSD0_DscOddKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_DSCODDKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_DSCODDKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscOddKeyUpper".
**
** This function reads the value from the index-th entry of the register
** array DscOddKeyUpper.
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_187"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_187" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_187")))
#endif

uint32_t FREG_TSD0_GetmDscOddKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_DscOddKeyUpperMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OddKeyUpper" of register "DscOddKeyUpper".
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OddKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_188"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_188" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_188")))
#endif

uint32_t FREG_TSD0_GetmDscOddKeyUpper_OddKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_DscOddKeyUpperMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscOddKeyLower".
**
** This function writes the given value to the index-th entry of the register
** array DscOddKeyLower.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_189"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_189" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_189")))
#endif

void FREG_TSD0_SetDscOddKeyLower( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD0_DscOddKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_DSCODDKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_DSCODDKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OddKeyLower" of register "DscOddKeyLower".
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OddKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_190"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_190" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_190")))
#endif

void FREG_TSD0_SetDscOddKeyLower_OddKeyLower( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_DscOddKeyLowerMirror[index] & ~mask;
    FREG_TSD0_DscOddKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_DSCODDKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_DSCODDKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscOddKeyLower".
**
** This function reads the value from the index-th entry of the register
** array DscOddKeyLower.
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_191"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_191" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_191")))
#endif

uint32_t FREG_TSD0_GetmDscOddKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_DscOddKeyLowerMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OddKeyLower" of register "DscOddKeyLower".
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OddKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_192"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_192" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_192")))
#endif

uint32_t FREG_TSD0_GetmDscOddKeyLower_OddKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_DscOddKeyLowerMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscEvenKeyUpper".
**
** This function writes the given value to the index-th entry of the register
** array DscEvenKeyUpper.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_193"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_193" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_193")))
#endif

void FREG_TSD0_SetDscEvenKeyUpper( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD0_DscEvenKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_DSCEVENKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_DSCEVENKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "EvenKeyUpper" of register "DscEvenKeyUpper".
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "EvenKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_194"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_194" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_194")))
#endif

void FREG_TSD0_SetDscEvenKeyUpper_EvenKeyUpper( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_DscEvenKeyUpperMirror[index] & ~mask;
    FREG_TSD0_DscEvenKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_DSCEVENKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_DSCEVENKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscEvenKeyUpper".
**
** This function reads the value from the index-th entry of the register
** array DscEvenKeyUpper.
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_195"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_195" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_195")))
#endif

uint32_t FREG_TSD0_GetmDscEvenKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_DscEvenKeyUpperMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "EvenKeyUpper" of register "DscEvenKeyUpper".
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "EvenKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_196"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_196" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_196")))
#endif

uint32_t FREG_TSD0_GetmDscEvenKeyUpper_EvenKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_DscEvenKeyUpperMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscEvenKeyLower".
**
** This function writes the given value to the index-th entry of the register
** array DscEvenKeyLower.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_197"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_197" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_197")))
#endif

void FREG_TSD0_SetDscEvenKeyLower( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD0_DscEvenKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_DSCEVENKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_DSCEVENKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "EvenKeyLower" of register "DscEvenKeyLower".
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "EvenKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_198"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_198" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_198")))
#endif

void FREG_TSD0_SetDscEvenKeyLower_EvenKeyLower( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_DscEvenKeyLowerMirror[index] & ~mask;
    FREG_TSD0_DscEvenKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_DSCEVENKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_DSCEVENKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscEvenKeyLower".
**
** This function reads the value from the index-th entry of the register
** array DscEvenKeyLower.
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_199"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_199" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_199")))
#endif

uint32_t FREG_TSD0_GetmDscEvenKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_DscEvenKeyLowerMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "EvenKeyLower" of register "DscEvenKeyLower".
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "EvenKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_200"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_200" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_200")))
#endif

uint32_t FREG_TSD0_GetmDscEvenKeyLower_EvenKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_DscEvenKeyLowerMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidValue".
**
** This function writes the given value to the index-th entry of the register
** array PidValue.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_201"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_201" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_201")))
#endif

void FREG_TSD1_SetPidValue( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return;
    #endif
    FREG_TSD1_PidValueMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDVALUE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDVALUE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidBit" of register "PidValue".
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidBit" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_202"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_202" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_202")))
#endif

void FREG_TSD1_SetPidValue_PidBit( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_PidValueMirror[index] & ~mask;
    FREG_TSD1_PidValueMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDVALUE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDVALUE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidValue".
**
** This function reads the value from the index-th entry of the register
** array PidValue.
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_203"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_203" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_203")))
#endif

uint32_t FREG_TSD1_GetmPidValue( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidValueMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidBit" of register "PidValue".
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidBit" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_204"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_204" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_204")))
#endif

uint32_t FREG_TSD1_GetmPidValue_PidBit( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 13 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidValueMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidConfig_1".
**
** This function writes the given value to the index-th entry of the register
** array PidConfig_1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_205"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_205" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_205")))
#endif

void FREG_TSD1_SetPidConfig_1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    FREG_TSD1_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DuplicateIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for duplicate packet IRQ.
**  If the bit DUPLICATE_CHECK in TSD1_PID_config_2 is set to 1, duplicate packets will be removed. If the bit DUPLICATE_IRQ_EN is also set to 1, a DUPLICATE_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DuplicateIrqEn" consists of the bits 16..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00010000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_206"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_206" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_206")))
#endif

void FREG_TSD1_SetPidConfig_1_DuplicateIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00010000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD1_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "BufferIndex" of register "PidConfig_1".
**
** If the OFFSET_MODE (bit 7 of this register, see below) is set to 0, BUFFER_INDEX specifies to which buffer the data of this PID channel shall be stored.
**  If data from multiple PID channels shall be stored in the same buffer, these PID channels' BUFFER_INDEX shall be set to the same value.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "BufferIndex" consists of the bits 12..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00001F00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_207"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_207" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_207")))
#endif

void FREG_TSD1_SetPidConfig_1_BufferIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00001F00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD1_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OffsetMode" of register "PidConfig_1".
**
** This bit is ONLY active for PSI packets.
**
** - '1': the section data of this PID channel will be stored
** to the buffer with the index K, where k =
** BUFFER_INDEX + offset. Here offset = (matched
** filter target index). If more than one filter targets
** match the incoming section, the lowest target index
** will be used as offset.
** - '0':  the section data will be stored to buffer specified
** with BUFFER_INDEX.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OffsetMode" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_208"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_208" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_208")))
#endif

void FREG_TSD1_SetPidConfig_1_OffsetMode( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD1_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pcr1AfLt7IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** PCR flag is 1 (PCR_1), but adaptation field length is less than 7 (AF_LT_7).
**  In this case, no PCR will be extracted even if the bit EXTRACT_PCR is set to 1. The adapation field will be handeled as if the PCR flag is 0.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pcr1AfLt7IrqEn" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_209"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_209" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_209")))
#endif

void FREG_TSD1_SetPidConfig_1_Pcr1AfLt7IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000040UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    value |= FREG_TSD1_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pl1AfGt183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field byte number is greater than 183 (AF_GT183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pl1AfGt183IrqEn" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_210"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_210" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_210")))
#endif

void FREG_TSD1_SetPidConfig_1_Pl1AfGt183IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    value |= FREG_TSD1_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pl0AfNe183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field length is not equal 183 (AF_NE183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pl0AfNe183IrqEn" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_211"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_211" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_211")))
#endif

void FREG_TSD1_SetPidConfig_1_Pl0AfNe183IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    value |= FREG_TSD1_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NullPacketIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for NULL packet IRQ.
**  Null packets (both of the adapation field flag and payload flag in packet header are 0) are alway removed. If this bit is set to 1, a NULL_PACKET_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NullPacketIrqEn" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_212"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_212" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_212")))
#endif

void FREG_TSD1_SetPidConfig_1_NullPacketIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 3 ) & mask;
    value |= FREG_TSD1_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DescramblerIndex" of register "PidConfig_1".
**
** Ranges from 0 to 7.
**  Indicates which one of the 8 descramlbers shall be used to descramble this PID channel. The descramble keys are definded through the register DSC_ODD_KEY_UPPER, DSC_ODD_KEY_LOWER, DSC_EVEN_KEY_UPPER and DSC_EVEN_KEY_LOWER. The odd/even flag of scrambling control field in the TS packet header decides if the odd or the even key of the corresponding descrambler is used to descramble the actual TS-packet.
**
** To activate the selected descrambler, the bit BYPASS_DSC in the register PID_CONFIG_2 must be set to 0.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DescramblerIndex" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_213"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_213" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_213")))
#endif

void FREG_TSD1_SetPidConfig_1_DescramblerIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000007UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidConfig_1".
**
** This function reads the value from the index-th entry of the register
** array PidConfig_1.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_214"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_214" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_214")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DuplicateIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for duplicate packet IRQ.
**  If the bit DUPLICATE_CHECK in TSD1_PID_config_2 is set to 1, duplicate packets will be removed. If the bit DUPLICATE_IRQ_EN is also set to 1, a DUPLICATE_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DuplicateIrqEn" consists of the bits 16..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00010000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_215"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_215" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_215")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_1_DuplicateIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_1Mirror[index];
    value = ( value & 0x00010000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "BufferIndex" of register "PidConfig_1".
**
** If the OFFSET_MODE (bit 7 of this register, see below) is set to 0, BUFFER_INDEX specifies to which buffer the data of this PID channel shall be stored.
**  If data from multiple PID channels shall be stored in the same buffer, these PID channels' BUFFER_INDEX shall be set to the same value.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "BufferIndex" consists of the bits 12..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00001F00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_216"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_216" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_216")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_1_BufferIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_1Mirror[index];
    value = ( value & 0x00001F00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OffsetMode" of register "PidConfig_1".
**
** This bit is ONLY active for PSI packets.
**
** - '1': the section data of this PID channel will be stored
** to the buffer with the index K, where k =
** BUFFER_INDEX + offset. Here offset = (matched
** filter target index). If more than one filter targets
** match the incoming section, the lowest target index
** will be used as offset.
** - '0':  the section data will be stored to buffer specified
** with BUFFER_INDEX.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OffsetMode" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_217"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_217" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_217")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_1_OffsetMode( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_1Mirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pcr1AfLt7IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** PCR flag is 1 (PCR_1), but adaptation field length is less than 7 (AF_LT_7).
**  In this case, no PCR will be extracted even if the bit EXTRACT_PCR is set to 1. The adapation field will be handeled as if the PCR flag is 0.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pcr1AfLt7IrqEn" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_218"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_218" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_218")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_1_Pcr1AfLt7IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_1Mirror[index];
    value = ( value & 0x00000040UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pl1AfGt183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field byte number is greater than 183 (AF_GT183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pl1AfGt183IrqEn" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_219"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_219" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_219")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_1_Pl1AfGt183IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_1Mirror[index];
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pl0AfNe183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field length is not equal 183 (AF_NE183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pl0AfNe183IrqEn" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_220"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_220" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_220")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_1_Pl0AfNe183IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_1Mirror[index];
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NullPacketIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for NULL packet IRQ.
**  Null packets (both of the adapation field flag and payload flag in packet header are 0) are alway removed. If this bit is set to 1, a NULL_PACKET_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NullPacketIrqEn" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_221"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_221" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_221")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_1_NullPacketIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_1Mirror[index];
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DescramblerIndex" of register "PidConfig_1".
**
** Ranges from 0 to 7.
**  Indicates which one of the 8 descramlbers shall be used to descramble this PID channel. The descramble keys are definded through the register DSC_ODD_KEY_UPPER, DSC_ODD_KEY_LOWER, DSC_EVEN_KEY_UPPER and DSC_EVEN_KEY_LOWER. The odd/even flag of scrambling control field in the TS packet header decides if the odd or the even key of the corresponding descrambler is used to descramble the actual TS-packet.
**
** To activate the selected descrambler, the bit BYPASS_DSC in the register PID_CONFIG_2 must be set to 0.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DescramblerIndex" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_222"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_222" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_222")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_1_DescramblerIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_1Mirror[index];
    value = ( value & 0x00000007UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidConfig_2".
**
** This function writes the given value to the index-th entry of the register
** array PidConfig_2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_223"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_223" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_223")))
#endif

void FREG_TSD1_SetPidConfig_2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PtrTarget" of register "PidConfig_2".
**
** Pointer to the first target in SF_target_RAM.
**
** PTR_TARGET ranges from 0 to 127. This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0.
**
** For example, if the first target is stored in line 25 of SF_target_RAM, then PTR_TARGET shall be set to 25.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PtrTarget" consists of the bits 31..25,
**       the given bitgroup value will be shifted left by 25 bits and
**       masked using the bitmask 0xFE000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_224"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_224" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_224")))
#endif

void FREG_TSD1_SetPidConfig_2_PtrTarget( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFE000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 25 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NTarget" of register "PidConfig_2".
**
** Number of filter target.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. Let the number of target be k. k is coded and stored to N_TARGET. Attention: N_TARGET is not binary-coded decimal format of k (see below)!! For example, if k = 4, N_TARGET is '1000' (decimal 8) not '0100' (decimal 4).
** - k= 1: N_TARGET='0001'
** - k= 2: N_TARGET='0010'
** - k= 4: N_TARGET='1000'
** - k= 8: N_TARGET='1001'
** - k=12: N_TARGET='1010'
** - k=16: N_TARGET='1011'
** - k=20: N_TARGET='1100'
** - k=24: N_TARGET='1101'
** - k=28: N_TARGET='1110'
** - k=32: N_TARGET='1111'
** (Coding rules:
** N_TARGET[3] = 0 and N_TARGET[2:0] = k, if k<4.
** N_TARGET[3] = 1 and N_TARGET[2:0] = (k/4)-1, if k4.)
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NTarget" consists of the bits 24..21,
**       the given bitgroup value will be shifted left by 21 bits and
**       masked using the bitmask 0x01E00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_225"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_225" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_225")))
#endif

void FREG_TSD1_SetPidConfig_2_NTarget( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x01E00000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 21 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TargetLength" of register "PidConfig_2".
**
** Filter target length.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. All filter targets of a PID channel shall have the same length. TARGET_LENGTH ranges from 1 to 15 (including table ID byte, but excluding the two section length bytes).
** To disable section filtering, set TARGET_LENGTH = 1.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TargetLength" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_226"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_226" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_226")))
#endif

void FREG_TSD1_SetPidConfig_2_TargetLength( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x001F0000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "StoreCompletePacket" of register "PidConfig_2".
**
** Indicate if TS packets header (4 bytes) and adaptation field shall be stored.
**
** - '0': Only payload shall be stored (packet header and adaptation field shall be removed).
** - '1': The complete packet (packet header, adaptation field and payload) shall be stored.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "StoreCompletePacket" consists of the bits 15..15,
**       the given bitgroup value will be shifted left by 15 bits and
**       masked using the bitmask 0x00008000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_227"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_227" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_227")))
#endif

void FREG_TSD1_SetPidConfig_2_StoreCompletePacket( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00008000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 15 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PusIrqEn" of register "PidConfig_2".
**
** Payload Unit Start (PUS) interrupt enable:
** - '0': disabled.
**
** - '1': enabled.
** If the Payload Unit Start Indicator of a transport stream packet is '1' and PUS_IRQ_EN is '1' then a PUS_IRQ will be triggered.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PusIrqEn" consists of the bits 14..14,
**       the given bitgroup value will be shifted left by 14 bits and
**       masked using the bitmask 0x00004000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_228"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_228" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_228")))
#endif

void FREG_TSD1_SetPidConfig_2_PusIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00004000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 14 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no packet is received during a certain time (defined in the register INPUT_TIMEOUT), an INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InputTimeoutIrqEn" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_229"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_229" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_229")))
#endif

void FREG_TSD1_SetPidConfig_2_InputTimeoutIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00002000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 13 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ValidInputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no valid packet is received during a certain time (defined the in register VALID_INPUT_TIMEOUT), an VALID_INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ValidInputTimeoutIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_230"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_230" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_230")))
#endif

void FREG_TSD1_SetPidConfig_2_ValidInputTimeoutIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00001000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 12 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NewPcrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PCR handling (new PCR available)
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NewPcrIrqEn" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_231"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_231" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_231")))
#endif

void FREG_TSD1_SetPidConfig_2_NewPcrIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000800UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 11 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CcIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CONTINUITY_COUNTER_ERROR_IRQ.
**  If CC_CHECK is set and a continuity counter error is found,  a CONTINUITY_COUNTER_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CcIrqEn" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_232"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_232" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_232")))
#endif

void FREG_TSD1_SetPidConfig_2_CcIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000400UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 10 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SectionEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for SECTION_END_IRQ.
**  If an incoming section matches at least one filter target and its end is detected, a SECTION_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SectionEndIrqEn" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_233"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_233" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_233")))
#endif

void FREG_TSD1_SetPidConfig_2_SectionEndIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000200UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 9 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PACKET_END_IRQ.
**  If the PID of an incoming packet matches the PID of this channel and all bytes in this packet was sent to Buffer Mangager, a PACKET_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketEndIrqEn" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_234"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_234" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_234")))
#endif

void FREG_TSD1_SetPidConfig_2_PacketEndIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000100UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ScrambledPacketIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for scrambled transport packet.
**  If the scrambling controll flag in TS packet header is set to 1, a SCRAMBLED_PACKET_IRQ will be generated.
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ScrambledPacketIrqEn" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_235"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_235" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_235")))
#endif

void FREG_TSD1_SetPidConfig_2_ScrambledPacketIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CcCheck" of register "PidConfig_2".
**
** Continuity Counter error  check.
**  If a TS packet has payload, its continuity counter shall be incremented by 1 or equals to that of the previous packet. If a TS packet has only adaptation field, its continuity counter shall not be incremented. If any of the conditions is not filled, the TS packet will be discarded and the corresponding PID channel will be disabled.
** - '0': don't check
** - '1': if CC error detected, discard the packet and disable the corresponding PID channel.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CcCheck" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_236"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_236" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_236")))
#endif

void FREG_TSD1_SetPidConfig_2_CcCheck( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000040UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DuplicateCheck" of register "PidConfig_2".
**
** Duplicate packet check.
**  If a TS packet has payload but its continuity counter is equal to that of the previous packet, then this packet is a duplicate packet. If this bit is set, such packets will be discarded.
** - '0': don't check
** - '1': discard duplicate packet.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DuplicateCheck" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_237"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_237" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_237")))
#endif

void FREG_TSD1_SetPidConfig_2_DuplicateCheck( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PesPayload" of register "PidConfig_2".
**
** Specifies type of transport packet payload
** - '0': PSI payload (section data)
** - '1': PES payload (video, MPEG audio,
** teletext, closed caption)
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PesPayload" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_238"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_238" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_238")))
#endif

void FREG_TSD1_SetPidConfig_2_PesPayload( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ExtractPcr" of register "PidConfig_2".
**
** Enable the extraction of PCR field from adaptation field:
** - '0': PCR should be skipped
** - '1': PCR should be extracted.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ExtractPcr" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_239"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_239" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_239")))
#endif

void FREG_TSD1_SetPidConfig_2_ExtractPcr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 3 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PsiCcCheckMode" of register "PidConfig_2".
**
** Specify the Continuity Counter (CC) Check Mode for PSI packets (therefore ONLY active for PSI packets):
** - '1': always check continuity counter if CC_CHECK is
** enabled.
**
** - '0': only check continuity counter if check is enabled and section filter is active.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PsiCcCheckMode" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_240"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_240" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_240")))
#endif

void FREG_TSD1_SetPidConfig_2_PsiCcCheckMode( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000004UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 2 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CrcErrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CRC error.
**  If the syntax indicator in a section is set to 1 and the CRC  in this section is wrong, a CRC_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CrcErrIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_241"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_241" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_241")))
#endif

void FREG_TSD1_SetPidConfig_2_CrcErrIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "BypassDsc" of register "PidConfig_2".
**
** Bypass DVB descrambler.
**
** - '0': DVB descrambler not bypassed. Descramlbe key and the DESCRAMBLER_INDEX in CONFIG_1 must be programmed. If the scrambling control flag in the TS packet header is not set, the descrambler will not be activated even if this bit is set to 0. Therefore, this bit can be set to 0 in all default configuration and it shall be set to 1 only if descrambler must be deactivated.
** - '1': DVB descrambler is bypassed.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "BypassDsc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_242"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_242" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_242")))
#endif

void FREG_TSD1_SetPidConfig_2_BypassDsc( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD1_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidConfig_2".
**
** This function reads the value from the index-th entry of the register
** array PidConfig_2.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_243"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_243" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_243")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PtrTarget" of register "PidConfig_2".
**
** Pointer to the first target in SF_target_RAM.
**
** PTR_TARGET ranges from 0 to 127. This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0.
**
** For example, if the first target is stored in line 25 of SF_target_RAM, then PTR_TARGET shall be set to 25.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PtrTarget" consists of the bits 31..25,
**       the given bitgroup value will be shifted left by 25 bits and
**       masked using the bitmask 0xFE000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_244"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_244" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_244")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_PtrTarget( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0xFE000000UL ) >> 25;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NTarget" of register "PidConfig_2".
**
** Number of filter target.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. Let the number of target be k. k is coded and stored to N_TARGET. Attention: N_TARGET is not binary-coded decimal format of k (see below)!! For example, if k = 4, N_TARGET is '1000' (decimal 8) not '0100' (decimal 4).
** - k= 1: N_TARGET='0001'
** - k= 2: N_TARGET='0010'
** - k= 4: N_TARGET='1000'
** - k= 8: N_TARGET='1001'
** - k=12: N_TARGET='1010'
** - k=16: N_TARGET='1011'
** - k=20: N_TARGET='1100'
** - k=24: N_TARGET='1101'
** - k=28: N_TARGET='1110'
** - k=32: N_TARGET='1111'
** (Coding rules:
** N_TARGET[3] = 0 and N_TARGET[2:0] = k, if k<4.
** N_TARGET[3] = 1 and N_TARGET[2:0] = (k/4)-1, if k4.)
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NTarget" consists of the bits 24..21,
**       the given bitgroup value will be shifted left by 21 bits and
**       masked using the bitmask 0x01E00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_245"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_245" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_245")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_NTarget( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x01E00000UL ) >> 21;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TargetLength" of register "PidConfig_2".
**
** Filter target length.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. All filter targets of a PID channel shall have the same length. TARGET_LENGTH ranges from 1 to 15 (including table ID byte, but excluding the two section length bytes).
** To disable section filtering, set TARGET_LENGTH = 1.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TargetLength" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_246"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_246" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_246")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_TargetLength( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x001F0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "StoreCompletePacket" of register "PidConfig_2".
**
** Indicate if TS packets header (4 bytes) and adaptation field shall be stored.
**
** - '0': Only payload shall be stored (packet header and adaptation field shall be removed).
** - '1': The complete packet (packet header, adaptation field and payload) shall be stored.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "StoreCompletePacket" consists of the bits 15..15,
**       the given bitgroup value will be shifted left by 15 bits and
**       masked using the bitmask 0x00008000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_247"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_247" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_247")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_StoreCompletePacket( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00008000UL ) >> 15;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PusIrqEn" of register "PidConfig_2".
**
** Payload Unit Start (PUS) interrupt enable:
** - '0': disabled.
**
** - '1': enabled.
** If the Payload Unit Start Indicator of a transport stream packet is '1' and PUS_IRQ_EN is '1' then a PUS_IRQ will be triggered.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PusIrqEn" consists of the bits 14..14,
**       the given bitgroup value will be shifted left by 14 bits and
**       masked using the bitmask 0x00004000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_248"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_248" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_248")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_PusIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00004000UL ) >> 14;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no packet is received during a certain time (defined in the register INPUT_TIMEOUT), an INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "InputTimeoutIrqEn" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_249"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_249" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_249")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_InputTimeoutIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00002000UL ) >> 13;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ValidInputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no valid packet is received during a certain time (defined the in register VALID_INPUT_TIMEOUT), an VALID_INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ValidInputTimeoutIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_250"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_250" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_250")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_ValidInputTimeoutIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00001000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NewPcrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PCR handling (new PCR available)
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NewPcrIrqEn" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_251"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_251" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_251")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_NewPcrIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000800UL ) >> 11;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CcIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CONTINUITY_COUNTER_ERROR_IRQ.
**  If CC_CHECK is set and a continuity counter error is found,  a CONTINUITY_COUNTER_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CcIrqEn" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_252"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_252" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_252")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_CcIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000400UL ) >> 10;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SectionEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for SECTION_END_IRQ.
**  If an incoming section matches at least one filter target and its end is detected, a SECTION_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SectionEndIrqEn" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_253"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_253" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_253")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_SectionEndIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PACKET_END_IRQ.
**  If the PID of an incoming packet matches the PID of this channel and all bytes in this packet was sent to Buffer Mangager, a PACKET_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketEndIrqEn" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_254"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_254" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_254")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_PacketEndIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000100UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ScrambledPacketIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for scrambled transport packet.
**  If the scrambling controll flag in TS packet header is set to 1, a SCRAMBLED_PACKET_IRQ will be generated.
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ScrambledPacketIrqEn" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_255"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_255" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_255")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_ScrambledPacketIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CcCheck" of register "PidConfig_2".
**
** Continuity Counter error  check.
**  If a TS packet has payload, its continuity counter shall be incremented by 1 or equals to that of the previous packet. If a TS packet has only adaptation field, its continuity counter shall not be incremented. If any of the conditions is not filled, the TS packet will be discarded and the corresponding PID channel will be disabled.
** - '0': don't check
** - '1': if CC error detected, discard the packet and disable the corresponding PID channel.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CcCheck" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_256"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_256" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_256")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_CcCheck( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000040UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DuplicateCheck" of register "PidConfig_2".
**
** Duplicate packet check.
**  If a TS packet has payload but its continuity counter is equal to that of the previous packet, then this packet is a duplicate packet. If this bit is set, such packets will be discarded.
** - '0': don't check
** - '1': discard duplicate packet.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DuplicateCheck" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_257"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_257" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_257")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_DuplicateCheck( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PesPayload" of register "PidConfig_2".
**
** Specifies type of transport packet payload
** - '0': PSI payload (section data)
** - '1': PES payload (video, MPEG audio,
** teletext, closed caption)
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PesPayload" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_258"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_258" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_258")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_PesPayload( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ExtractPcr" of register "PidConfig_2".
**
** Enable the extraction of PCR field from adaptation field:
** - '0': PCR should be skipped
** - '1': PCR should be extracted.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ExtractPcr" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_259"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_259" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_259")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_ExtractPcr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PsiCcCheckMode" of register "PidConfig_2".
**
** Specify the Continuity Counter (CC) Check Mode for PSI packets (therefore ONLY active for PSI packets):
** - '1': always check continuity counter if CC_CHECK is
** enabled.
**
** - '0': only check continuity counter if check is enabled and section filter is active.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PsiCcCheckMode" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_260"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_260" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_260")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_PsiCcCheckMode( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000004UL ) >> 2;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CrcErrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CRC error.
**  If the syntax indicator in a section is set to 1 and the CRC  in this section is wrong, a CRC_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CrcErrIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_261"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_261" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_261")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_CrcErrIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "BypassDsc" of register "PidConfig_2".
**
** Bypass DVB descrambler.
**
** - '0': DVB descrambler not bypassed. Descramlbe key and the DESCRAMBLER_INDEX in CONFIG_1 must be programmed. If the scrambling control flag in the TS packet header is not set, the descrambler will not be activated even if this bit is set to 0. Therefore, this bit can be set to 0 in all default configuration and it shall be set to 1 only if descrambler must be deactivated.
** - '1': DVB descrambler is bypassed.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "BypassDsc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_262"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_262" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_262")))
#endif

uint32_t FREG_TSD1_GetmPidConfig_2_BypassDsc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_PidConfig_2Mirror[index];
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscOddKeyUpper".
**
** This function writes the given value to the index-th entry of the register
** array DscOddKeyUpper.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_263"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_263" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_263")))
#endif

void FREG_TSD1_SetDscOddKeyUpper( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD1_DscOddKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_DSCODDKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_DSCODDKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OddKeyUpper" of register "DscOddKeyUpper".
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OddKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_264"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_264" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_264")))
#endif

void FREG_TSD1_SetDscOddKeyUpper_OddKeyUpper( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_DscOddKeyUpperMirror[index] & ~mask;
    FREG_TSD1_DscOddKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_DSCODDKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_DSCODDKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscOddKeyUpper".
**
** This function reads the value from the index-th entry of the register
** array DscOddKeyUpper.
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_265"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_265" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_265")))
#endif

uint32_t FREG_TSD1_GetmDscOddKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_DscOddKeyUpperMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OddKeyUpper" of register "DscOddKeyUpper".
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OddKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_266"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_266" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_266")))
#endif

uint32_t FREG_TSD1_GetmDscOddKeyUpper_OddKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_DscOddKeyUpperMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscOddKeyLower".
**
** This function writes the given value to the index-th entry of the register
** array DscOddKeyLower.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_267"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_267" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_267")))
#endif

void FREG_TSD1_SetDscOddKeyLower( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD1_DscOddKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_DSCODDKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_DSCODDKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OddKeyLower" of register "DscOddKeyLower".
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OddKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_268"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_268" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_268")))
#endif

void FREG_TSD1_SetDscOddKeyLower_OddKeyLower( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_DscOddKeyLowerMirror[index] & ~mask;
    FREG_TSD1_DscOddKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_DSCODDKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_DSCODDKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscOddKeyLower".
**
** This function reads the value from the index-th entry of the register
** array DscOddKeyLower.
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_269"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_269" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_269")))
#endif

uint32_t FREG_TSD1_GetmDscOddKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_DscOddKeyLowerMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OddKeyLower" of register "DscOddKeyLower".
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OddKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_270"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_270" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_270")))
#endif

uint32_t FREG_TSD1_GetmDscOddKeyLower_OddKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_DscOddKeyLowerMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscEvenKeyUpper".
**
** This function writes the given value to the index-th entry of the register
** array DscEvenKeyUpper.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_271"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_271" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_271")))
#endif

void FREG_TSD1_SetDscEvenKeyUpper( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD1_DscEvenKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_DSCEVENKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_DSCEVENKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "EvenKeyUpper" of register "DscEvenKeyUpper".
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "EvenKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_272"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_272" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_272")))
#endif

void FREG_TSD1_SetDscEvenKeyUpper_EvenKeyUpper( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_DscEvenKeyUpperMirror[index] & ~mask;
    FREG_TSD1_DscEvenKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_DSCEVENKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_DSCEVENKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscEvenKeyUpper".
**
** This function reads the value from the index-th entry of the register
** array DscEvenKeyUpper.
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_273"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_273" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_273")))
#endif

uint32_t FREG_TSD1_GetmDscEvenKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_DscEvenKeyUpperMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "EvenKeyUpper" of register "DscEvenKeyUpper".
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "EvenKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_274"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_274" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_274")))
#endif

uint32_t FREG_TSD1_GetmDscEvenKeyUpper_EvenKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_DscEvenKeyUpperMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscEvenKeyLower".
**
** This function writes the given value to the index-th entry of the register
** array DscEvenKeyLower.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_275"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_275" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_275")))
#endif

void FREG_TSD1_SetDscEvenKeyLower( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD1_DscEvenKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_DSCEVENKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_DSCEVENKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "EvenKeyLower" of register "DscEvenKeyLower".
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "EvenKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_276"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_276" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_276")))
#endif

void FREG_TSD1_SetDscEvenKeyLower_EvenKeyLower( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_DscEvenKeyLowerMirror[index] & ~mask;
    FREG_TSD1_DscEvenKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_DSCEVENKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_DSCEVENKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscEvenKeyLower".
**
** This function reads the value from the index-th entry of the register
** array DscEvenKeyLower.
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_277"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_277" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_277")))
#endif

uint32_t FREG_TSD1_GetmDscEvenKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_DscEvenKeyLowerMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "EvenKeyLower" of register "DscEvenKeyLower".
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "EvenKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_278"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_278" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_278")))
#endif

uint32_t FREG_TSD1_GetmDscEvenKeyLower_EvenKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_DscEvenKeyLowerMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket0".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_279"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_279" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_279")))
#endif

void FREG_TSD0_SetLinPacket0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_LinPacket0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_280"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_280" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_280")))
#endif

void FREG_TSD0_SetLinPacket0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_LinPacket0Mirror[index] & ~mask;
    FREG_TSD0_LinPacket0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket0".
**
** This function reads the value from the index-th entry of the register
** array LinPacket0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_281"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_281" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_281")))
#endif

uint32_t FREG_TSD0_GetmLinPacket0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacket0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_282"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_282" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_282")))
#endif

uint32_t FREG_TSD0_GetmLinPacket0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacket0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket1".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_283"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_283" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_283")))
#endif

void FREG_TSD0_SetLinPacket1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_LinPacket1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_284"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_284" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_284")))
#endif

void FREG_TSD0_SetLinPacket1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_LinPacket1Mirror[index] & ~mask;
    FREG_TSD0_LinPacket1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket1".
**
** This function reads the value from the index-th entry of the register
** array LinPacket1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_285"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_285" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_285")))
#endif

uint32_t FREG_TSD0_GetmLinPacket1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacket1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_286"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_286" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_286")))
#endif

uint32_t FREG_TSD0_GetmLinPacket1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacket1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket2".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_287"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_287" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_287")))
#endif

void FREG_TSD0_SetLinPacket2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_LinPacket2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_288"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_288" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_288")))
#endif

void FREG_TSD0_SetLinPacket2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_LinPacket2Mirror[index] & ~mask;
    FREG_TSD0_LinPacket2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket2".
**
** This function reads the value from the index-th entry of the register
** array LinPacket2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_289"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_289" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_289")))
#endif

uint32_t FREG_TSD0_GetmLinPacket2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacket2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_290"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_290" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_290")))
#endif

uint32_t FREG_TSD0_GetmLinPacket2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacket2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket3".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_291"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_291" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_291")))
#endif

void FREG_TSD0_SetLinPacket3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_LinPacket3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_292"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_292" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_292")))
#endif

void FREG_TSD0_SetLinPacket3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_LinPacket3Mirror[index] & ~mask;
    FREG_TSD0_LinPacket3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket3".
**
** This function reads the value from the index-th entry of the register
** array LinPacket3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_293"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_293" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_293")))
#endif

uint32_t FREG_TSD0_GetmLinPacket3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacket3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_294"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_294" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_294")))
#endif

uint32_t FREG_TSD0_GetmLinPacket3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacket3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket0".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_295"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_295" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_295")))
#endif

void FREG_TSD1_SetLinPacket0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_LinPacket0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_296"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_296" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_296")))
#endif

void FREG_TSD1_SetLinPacket0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_LinPacket0Mirror[index] & ~mask;
    FREG_TSD1_LinPacket0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket0".
**
** This function reads the value from the index-th entry of the register
** array LinPacket0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_297"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_297" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_297")))
#endif

uint32_t FREG_TSD1_GetmLinPacket0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacket0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_298"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_298" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_298")))
#endif

uint32_t FREG_TSD1_GetmLinPacket0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacket0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket1".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_299"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_299" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_299")))
#endif

void FREG_TSD1_SetLinPacket1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_LinPacket1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_300"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_300" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_300")))
#endif

void FREG_TSD1_SetLinPacket1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_LinPacket1Mirror[index] & ~mask;
    FREG_TSD1_LinPacket1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket1".
**
** This function reads the value from the index-th entry of the register
** array LinPacket1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_301"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_301" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_301")))
#endif

uint32_t FREG_TSD1_GetmLinPacket1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacket1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_302"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_302" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_302")))
#endif

uint32_t FREG_TSD1_GetmLinPacket1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacket1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket2".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_303"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_303" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_303")))
#endif

void FREG_TSD1_SetLinPacket2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_LinPacket2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_304"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_304" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_304")))
#endif

void FREG_TSD1_SetLinPacket2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_LinPacket2Mirror[index] & ~mask;
    FREG_TSD1_LinPacket2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket2".
**
** This function reads the value from the index-th entry of the register
** array LinPacket2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_305"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_305" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_305")))
#endif

uint32_t FREG_TSD1_GetmLinPacket2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacket2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_306"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_306" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_306")))
#endif

uint32_t FREG_TSD1_GetmLinPacket2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacket2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket3".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_307"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_307" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_307")))
#endif

void FREG_TSD1_SetLinPacket3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_LinPacket3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_308"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_308" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_308")))
#endif

void FREG_TSD1_SetLinPacket3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_LinPacket3Mirror[index] & ~mask;
    FREG_TSD1_LinPacket3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket3".
**
** This function reads the value from the index-th entry of the register
** array LinPacket3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_309"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_309" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_309")))
#endif

uint32_t FREG_TSD1_GetmLinPacket3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacket3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_310"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_310" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_310")))
#endif

uint32_t FREG_TSD1_GetmLinPacket3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacket3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto0".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_311"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_311" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_311")))
#endif

void FREG_TSD0_SetLinPacketAuto0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_LinPacketAuto0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKETAUTO0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKETAUTO0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_312"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_312" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_312")))
#endif

void FREG_TSD0_SetLinPacketAuto0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_LinPacketAuto0Mirror[index] & ~mask;
    FREG_TSD0_LinPacketAuto0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKETAUTO0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKETAUTO0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto0".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_313"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_313" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_313")))
#endif

uint32_t FREG_TSD0_GetmLinPacketAuto0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacketAuto0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_314"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_314" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_314")))
#endif

uint32_t FREG_TSD0_GetmLinPacketAuto0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacketAuto0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto1".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_315"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_315" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_315")))
#endif

void FREG_TSD0_SetLinPacketAuto1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_LinPacketAuto1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKETAUTO1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKETAUTO1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_316"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_316" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_316")))
#endif

void FREG_TSD0_SetLinPacketAuto1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_LinPacketAuto1Mirror[index] & ~mask;
    FREG_TSD0_LinPacketAuto1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKETAUTO1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKETAUTO1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto1".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_317"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_317" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_317")))
#endif

uint32_t FREG_TSD0_GetmLinPacketAuto1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacketAuto1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_318"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_318" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_318")))
#endif

uint32_t FREG_TSD0_GetmLinPacketAuto1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacketAuto1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto2".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_319"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_319" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_319")))
#endif

void FREG_TSD0_SetLinPacketAuto2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_LinPacketAuto2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKETAUTO2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKETAUTO2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_320"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_320" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_320")))
#endif

void FREG_TSD0_SetLinPacketAuto2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_LinPacketAuto2Mirror[index] & ~mask;
    FREG_TSD0_LinPacketAuto2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKETAUTO2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKETAUTO2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto2".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_321"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_321" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_321")))
#endif

uint32_t FREG_TSD0_GetmLinPacketAuto2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacketAuto2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_322"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_322" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_322")))
#endif

uint32_t FREG_TSD0_GetmLinPacketAuto2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacketAuto2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto3".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_323"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_323" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_323")))
#endif

void FREG_TSD0_SetLinPacketAuto3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_LinPacketAuto3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKETAUTO3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKETAUTO3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_324"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_324" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_324")))
#endif

void FREG_TSD0_SetLinPacketAuto3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_LinPacketAuto3Mirror[index] & ~mask;
    FREG_TSD0_LinPacketAuto3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_LINPACKETAUTO3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_LINPACKETAUTO3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto3".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_325"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_325" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_325")))
#endif

uint32_t FREG_TSD0_GetmLinPacketAuto3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacketAuto3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_326"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_326" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_326")))
#endif

uint32_t FREG_TSD0_GetmLinPacketAuto3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_LinPacketAuto3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto0".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_327"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_327" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_327")))
#endif

void FREG_TSD1_SetLinPacketAuto0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_LinPacketAuto0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKETAUTO0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKETAUTO0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_328"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_328" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_328")))
#endif

void FREG_TSD1_SetLinPacketAuto0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_LinPacketAuto0Mirror[index] & ~mask;
    FREG_TSD1_LinPacketAuto0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKETAUTO0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKETAUTO0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto0".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_329"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_329" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_329")))
#endif

uint32_t FREG_TSD1_GetmLinPacketAuto0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacketAuto0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_330"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_330" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_330")))
#endif

uint32_t FREG_TSD1_GetmLinPacketAuto0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacketAuto0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto1".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_331"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_331" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_331")))
#endif

void FREG_TSD1_SetLinPacketAuto1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_LinPacketAuto1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKETAUTO1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKETAUTO1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_332"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_332" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_332")))
#endif

void FREG_TSD1_SetLinPacketAuto1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_LinPacketAuto1Mirror[index] & ~mask;
    FREG_TSD1_LinPacketAuto1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKETAUTO1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKETAUTO1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto1".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_333"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_333" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_333")))
#endif

uint32_t FREG_TSD1_GetmLinPacketAuto1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacketAuto1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_334"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_334" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_334")))
#endif

uint32_t FREG_TSD1_GetmLinPacketAuto1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacketAuto1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto2".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_335"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_335" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_335")))
#endif

void FREG_TSD1_SetLinPacketAuto2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_LinPacketAuto2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKETAUTO2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKETAUTO2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_336"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_336" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_336")))
#endif

void FREG_TSD1_SetLinPacketAuto2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_LinPacketAuto2Mirror[index] & ~mask;
    FREG_TSD1_LinPacketAuto2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKETAUTO2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKETAUTO2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto2".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_337"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_337" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_337")))
#endif

uint32_t FREG_TSD1_GetmLinPacketAuto2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacketAuto2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_338"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_338" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_338")))
#endif

uint32_t FREG_TSD1_GetmLinPacketAuto2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacketAuto2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto3".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_339"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_339" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_339")))
#endif

void FREG_TSD1_SetLinPacketAuto3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_LinPacketAuto3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKETAUTO3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKETAUTO3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_340"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_340" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_340")))
#endif

void FREG_TSD1_SetLinPacketAuto3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_LinPacketAuto3Mirror[index] & ~mask;
    FREG_TSD1_LinPacketAuto3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_LINPACKETAUTO3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_LINPACKETAUTO3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto3".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_341"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_341" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_341")))
#endif

uint32_t FREG_TSD1_GetmLinPacketAuto3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacketAuto3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_342"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_342" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_342")))
#endif

uint32_t FREG_TSD1_GetmLinPacketAuto3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_LinPacketAuto3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet0".
**
** This function writes the given value to the index-th entry of the register
** array Packet0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_343"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_343" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_343")))
#endif

void FREG_TSD0_SetPacket0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_Packet0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_344"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_344" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_344")))
#endif

void FREG_TSD0_SetPacket0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_Packet0Mirror[index] & ~mask;
    FREG_TSD0_Packet0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet0".
**
** This function reads the value from the index-th entry of the register
** array Packet0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_345"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_345" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_345")))
#endif

uint32_t FREG_TSD0_GetmPacket0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_Packet0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_346"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_346" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_346")))
#endif

uint32_t FREG_TSD0_GetmPacket0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_Packet0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet1".
**
** This function writes the given value to the index-th entry of the register
** array Packet1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_347"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_347" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_347")))
#endif

void FREG_TSD0_SetPacket1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_Packet1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_348"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_348" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_348")))
#endif

void FREG_TSD0_SetPacket1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_Packet1Mirror[index] & ~mask;
    FREG_TSD0_Packet1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet1".
**
** This function reads the value from the index-th entry of the register
** array Packet1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_349"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_349" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_349")))
#endif

uint32_t FREG_TSD0_GetmPacket1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_Packet1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_350"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_350" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_350")))
#endif

uint32_t FREG_TSD0_GetmPacket1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_Packet1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet2".
**
** This function writes the given value to the index-th entry of the register
** array Packet2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_351"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_351" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_351")))
#endif

void FREG_TSD0_SetPacket2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_Packet2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_352"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_352" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_352")))
#endif

void FREG_TSD0_SetPacket2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_Packet2Mirror[index] & ~mask;
    FREG_TSD0_Packet2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet2".
**
** This function reads the value from the index-th entry of the register
** array Packet2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_353"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_353" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_353")))
#endif

uint32_t FREG_TSD0_GetmPacket2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_Packet2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_354"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_354" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_354")))
#endif

uint32_t FREG_TSD0_GetmPacket2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_Packet2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet3".
**
** This function writes the given value to the index-th entry of the register
** array Packet3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_355"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_355" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_355")))
#endif

void FREG_TSD0_SetPacket3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD0_Packet3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_356"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_356" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_356")))
#endif

void FREG_TSD0_SetPacket3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_Packet3Mirror[index] & ~mask;
    FREG_TSD0_Packet3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet3".
**
** This function reads the value from the index-th entry of the register
** array Packet3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_357"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_357" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_357")))
#endif

uint32_t FREG_TSD0_GetmPacket3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_Packet3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_358"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_358" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_358")))
#endif

uint32_t FREG_TSD0_GetmPacket3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_Packet3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet0".
**
** This function writes the given value to the index-th entry of the register
** array Packet0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_359"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_359" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_359")))
#endif

void FREG_TSD1_SetPacket0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_Packet0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_360"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_360" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_360")))
#endif

void FREG_TSD1_SetPacket0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_Packet0Mirror[index] & ~mask;
    FREG_TSD1_Packet0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet0".
**
** This function reads the value from the index-th entry of the register
** array Packet0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_361"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_361" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_361")))
#endif

uint32_t FREG_TSD1_GetmPacket0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_Packet0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_362"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_362" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_362")))
#endif

uint32_t FREG_TSD1_GetmPacket0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_Packet0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet1".
**
** This function writes the given value to the index-th entry of the register
** array Packet1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_363"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_363" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_363")))
#endif

void FREG_TSD1_SetPacket1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_Packet1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_364"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_364" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_364")))
#endif

void FREG_TSD1_SetPacket1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_Packet1Mirror[index] & ~mask;
    FREG_TSD1_Packet1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet1".
**
** This function reads the value from the index-th entry of the register
** array Packet1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_365"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_365" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_365")))
#endif

uint32_t FREG_TSD1_GetmPacket1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_Packet1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_366"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_366" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_366")))
#endif

uint32_t FREG_TSD1_GetmPacket1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_Packet1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet2".
**
** This function writes the given value to the index-th entry of the register
** array Packet2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_367"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_367" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_367")))
#endif

void FREG_TSD1_SetPacket2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_Packet2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_368"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_368" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_368")))
#endif

void FREG_TSD1_SetPacket2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_Packet2Mirror[index] & ~mask;
    FREG_TSD1_Packet2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet2".
**
** This function reads the value from the index-th entry of the register
** array Packet2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_369"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_369" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_369")))
#endif

uint32_t FREG_TSD1_GetmPacket2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_Packet2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_370"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_370" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_370")))
#endif

uint32_t FREG_TSD1_GetmPacket2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_Packet2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet3".
**
** This function writes the given value to the index-th entry of the register
** array Packet3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_371"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_371" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_371")))
#endif

void FREG_TSD1_SetPacket3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD1_Packet3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_372"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_372" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_372")))
#endif

void FREG_TSD1_SetPacket3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_Packet3Mirror[index] & ~mask;
    FREG_TSD1_Packet3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet3".
**
** This function reads the value from the index-th entry of the register
** array Packet3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_373"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_373" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_373")))
#endif

uint32_t FREG_TSD1_GetmPacket3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_Packet3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_374"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_374" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_374")))
#endif

uint32_t FREG_TSD1_GetmPacket3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_Packet3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PacketCtrl".
**
** This function writes the given value to the register "PacketCtrl".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_375"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_375" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_375")))
#endif

void FREG_TSD0_SetPacketCtrl( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid3" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_3 is valid.
**
** If the packet is valid, this bit group must be set to '111' to enable read out of PACKET_BUFFER_3.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_3.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid3" consists of the bits 14..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00007000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_376"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_376" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_376")))
#endif

void FREG_TSD0_SetPacketCtrl_PacketBufValid3( uint32_t value )
{
    register uint32_t mask = 0x00007000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid2" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_2 is valid.
**
** If the packet is valid, this bit group must be set to '110' to enable read out of PACKET_BUFFER_2.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_2.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid2" consists of the bits 10..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000700UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_377"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_377" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_377")))
#endif

void FREG_TSD0_SetPacketCtrl_PacketBufValid2( uint32_t value )
{
    register uint32_t mask = 0x00000700UL;
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid1" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_1 is valid.
**
** If the packet is valid, this bit group must be set to '101' to enable read out of PACKET_BUFFER_1.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_1.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid1" consists of the bits 6..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000070UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_378"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_378" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_378")))
#endif

void FREG_TSD0_SetPacketCtrl_PacketBufValid1( uint32_t value )
{
    register uint32_t mask = 0x00000070UL;
    value = ( value << 4 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid0" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_0 is valid.
**
** If the packet is valid, this bit group must be set to '100' to enable read out of PACKET_BUFFER_0.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_0.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid0" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_379"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_379" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_379")))
#endif

void FREG_TSD0_SetPacketCtrl_PacketBufValid0( uint32_t value )
{
    register uint32_t mask = 0x00000007UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketCtrl".
**
** This function reads the value from the register "PacketCtrl".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_380"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_380" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_380")))
#endif

uint32_t FREG_TSD0_GetPacketCtrl( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid3" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_3 is valid.
**
** If the packet is valid, this bit group must be set to '111' to enable read out of PACKET_BUFFER_3.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_3.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid3" consists of the bits 14..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00007000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_381"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_381" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_381")))
#endif

uint32_t FREG_TSD0_GetPacketCtrl_PacketBufValid3( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL));
    value = ( value & 0x00007000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid2" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_2 is valid.
**
** If the packet is valid, this bit group must be set to '110' to enable read out of PACKET_BUFFER_2.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_2.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid2" consists of the bits 10..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000700UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_382"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_382" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_382")))
#endif

uint32_t FREG_TSD0_GetPacketCtrl_PacketBufValid2( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL));
    value = ( value & 0x00000700UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid1" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_1 is valid.
**
** If the packet is valid, this bit group must be set to '101' to enable read out of PACKET_BUFFER_1.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_1.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid1" consists of the bits 6..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000070UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_383"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_383" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_383")))
#endif

uint32_t FREG_TSD0_GetPacketCtrl_PacketBufValid1( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL));
    value = ( value & 0x00000070UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid0" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_0 is valid.
**
** If the packet is valid, this bit group must be set to '100' to enable read out of PACKET_BUFFER_0.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_0.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid0" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_384"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_384" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_384")))
#endif

uint32_t FREG_TSD0_GetPacketCtrl_PacketBufValid0( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD0_PACKETCTRL));
    value = ( value & 0x00000007UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PacketCtrl".
**
** This function writes the given value to the register "PacketCtrl".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_385"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_385" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_385")))
#endif

void FREG_TSD1_SetPacketCtrl( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid3" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_3 is valid.
**
** If the packet is valid, this bit group must be set to '111' to enable read out of PACKET_BUFFER_3.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_3.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid3" consists of the bits 14..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00007000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_386"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_386" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_386")))
#endif

void FREG_TSD1_SetPacketCtrl_PacketBufValid3( uint32_t value )
{
    register uint32_t mask = 0x00007000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid2" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_2 is valid.
**
** If the packet is valid, this bit group must be set to '110' to enable read out of PACKET_BUFFER_2.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_2.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid2" consists of the bits 10..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000700UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_387"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_387" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_387")))
#endif

void FREG_TSD1_SetPacketCtrl_PacketBufValid2( uint32_t value )
{
    register uint32_t mask = 0x00000700UL;
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid1" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_1 is valid.
**
** If the packet is valid, this bit group must be set to '101' to enable read out of PACKET_BUFFER_1.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_1.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid1" consists of the bits 6..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000070UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_388"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_388" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_388")))
#endif

void FREG_TSD1_SetPacketCtrl_PacketBufValid1( uint32_t value )
{
    register uint32_t mask = 0x00000070UL;
    value = ( value << 4 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid0" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_0 is valid.
**
** If the packet is valid, this bit group must be set to '100' to enable read out of PACKET_BUFFER_0.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_0.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid0" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_389"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_389" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_389")))
#endif

void FREG_TSD1_SetPacketCtrl_PacketBufValid0( uint32_t value )
{
    register uint32_t mask = 0x00000007UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketCtrl".
**
** This function reads the value from the register "PacketCtrl".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_390"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_390" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_390")))
#endif

uint32_t FREG_TSD1_GetPacketCtrl( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid3" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_3 is valid.
**
** If the packet is valid, this bit group must be set to '111' to enable read out of PACKET_BUFFER_3.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_3.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid3" consists of the bits 14..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00007000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_391"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_391" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_391")))
#endif

uint32_t FREG_TSD1_GetPacketCtrl_PacketBufValid3( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL));
    value = ( value & 0x00007000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid2" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_2 is valid.
**
** If the packet is valid, this bit group must be set to '110' to enable read out of PACKET_BUFFER_2.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_2.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid2" consists of the bits 10..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000700UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_392"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_392" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_392")))
#endif

uint32_t FREG_TSD1_GetPacketCtrl_PacketBufValid2( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL));
    value = ( value & 0x00000700UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid1" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_1 is valid.
**
** If the packet is valid, this bit group must be set to '101' to enable read out of PACKET_BUFFER_1.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_1.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid1" consists of the bits 6..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000070UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_393"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_393" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_393")))
#endif

uint32_t FREG_TSD1_GetPacketCtrl_PacketBufValid1( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL));
    value = ( value & 0x00000070UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid0" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_0 is valid.
**
** If the packet is valid, this bit group must be set to '100' to enable read out of PACKET_BUFFER_0.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_0.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid0" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_394"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_394" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_394")))
#endif

uint32_t FREG_TSD1_GetPacketCtrl_PacketBufValid0( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD1_PACKETCTRL));
    value = ( value & 0x00000007UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Irq".
**
** This function reads the value from the register "Irq".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_395"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_395" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_395")))
#endif

uint32_t FREG_TSD01_GetIrq( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_IRQ));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "IrqFifoOvf" of register "Irq".
**
** Indicates if this IRQ FIFO overflows:
** - '0': not overflow.
**
** - '1': overflow.
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqFifoOvf" consists of the bits 29..29,
**       the given bitgroup value will be shifted left by 29 bits and
**       masked using the bitmask 0x20000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_396"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_396" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_396")))
#endif

uint32_t FREG_TSD01_ExtractIrq_IrqFifoOvf( uint32_t value )
{
    value = ( value & 0x20000000UL ) >> 29;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "IrqAvailable" of register "Irq".
**
** Indicates if IRQ is available:
** - '0': not available (IRQ FIFO is empty).
**
** - '1': available (IRQ FIFO is not empty).
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqAvailable" consists of the bits 28..28,
**       the given bitgroup value will be shifted left by 28 bits and
**       masked using the bitmask 0x10000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_397"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_397" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_397")))
#endif

uint32_t FREG_TSD01_ExtractIrq_IrqAvailable( uint32_t value )
{
    value = ( value & 0x10000000UL ) >> 28;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "FilterTargetIndex" of register "Irq".
**
** For SECTION_END_IRQ and CRC_ERROR_IRQ the FILTER_TARGET_INDEX indicates to which filter target the corresponding IRQ belongs.
**
** If N (N<=32) filter targets are defined for a PID channel (these filter targets are indexed from 0 to N-1) and the current section matches the filter target N, then the FILTER_TARGET_INDEX is set to N.
** For example, 32 filter targets are defined for a PID channel (these filter targets are indexed from 0 to 31).
** If the current section matches the filter target 0, then the FILTER_TARGET_INDEX is set to '00000' (decimal 0).
** If the current section matches the filter target 15, then the FILTER_TARGET_INDEX is set to '01111' (decimal 15).
**
** If the current section matches more than one filter targets,  then the FILTER_TARGET_INDEX is set to the lowest target index.
** For example, if a section matches the filter target 1, 2, 3, then the FILTER_TARGET_INDEX is set to '00001' (decimal 1).
**
** For all other IRQs the FILTER_TARGET_INDEX are constant '00000'.
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterTargetIndex" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_398"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_398" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_398")))
#endif

uint32_t FREG_TSD01_ExtractIrq_FilterTargetIndex( uint32_t value )
{
    value = ( value & 0x001F0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "IrqValue" of register "Irq".
**
** IRQ of TSD01
** Read access: return the next IRQ in the FIFO, the read pointer will be incremented.
**
**
** The IRQ  value and priority are defined below (the smaller the priority number is, the higher the priority. This means, TRANSPORT_ERROR_IRQ has the highest priority.)
** IRQ                                            Value      Priority
** SCRAMBLED_PACKET_IRQ      : 0xF2         8
** DUPLICATE_IRQ                       : 0xF1         8
** PCR_1_AF_LT_7_IRQ                : 0xF0        8
** PL_1_AF_GT183_IRQ                : 0xEF         8
** PL_0_AF_NE183_IRQ                : 0xEE        8
** TRANSPORT_ERROR_IRQ        : 0xED        0
** NULL_PACKET_IRQ                  : 0xEC        8
** NEW_PTS_IRQ_3                      : 0xEB       8
** NEW_PTS_IRQ_2                      : 0xEA       8
** NEW_PTS_IRQ_1                      : 0xE9        8
** NEW_PTS_IRQ_0                      : 0xE8        8
** PUS_IRQ                                  : 0xE7         8
** CRC_ERROR_IRQ                     : 0xE6         6
** NEW_PCR_IRQ                         : 0xE5         2
** CONTINUITY_CNT_ERROR_IRQ : 0xE4         1
** INPUT_TIMEOUT_IRQ                : 0xE3         5
** VALID_INPUT_TIMEOUT_IRQ      : 0xE2        4
** SECTION_END_IRQ                   : 0xE1         7
** PACKET_END_IRQ                    : 0xE0         3
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqValue" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_399"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_399" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_399")))
#endif

uint32_t FREG_TSD01_ExtractIrq_IrqValue( uint32_t value )
{
    value = ( value & 0x0000FF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "Tsd1Select" of register "Irq".
**
** Indicates if this IRQ is generated by TSD0 or TSD1.
**
** - '0': TSD0.
** - '1': TSD1.
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd1Select" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_400"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_400" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_400")))
#endif

uint32_t FREG_TSD01_ExtractIrq_Tsd1Select( uint32_t value )
{
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "PidIndex" of register "Irq".
**
** PID_INDEX, ranges from 0 to 31.
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_401"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_401" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_401")))
#endif

uint32_t FREG_TSD01_ExtractIrq_PidIndex( uint32_t value )
{
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "IrqDbg".
**
** This function reads the value from the index-th entry of the register
** array IrqDbg.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_402"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_402" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_402")))
#endif

uint32_t FREG_TSD01_GetIrqDbg( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_IRQDBG+(index*0x4)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqFifoOvf" of register "IrqDbg".
**
** Indicates if this IRQ FIFO overflows:
** - '0': not overflow.
**
** - '1': overflow.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqFifoOvf" consists of the bits 29..29,
**       the given bitgroup value will be shifted left by 29 bits and
**       masked using the bitmask 0x20000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_403"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_403" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_403")))
#endif

uint32_t FREG_TSD01_GetIrqDbg_IrqFifoOvf( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_IRQDBG+(index*0x4)));
    value = ( value & 0x20000000UL ) >> 29;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqAvailable" of register "IrqDbg".
**
** Indicates if IRQ is available:
** - '0': not available (IRQ FIFO is empty).
**
** - '1': available (IRQ FIFO is not empty).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqAvailable" consists of the bits 28..28,
**       the given bitgroup value will be shifted left by 28 bits and
**       masked using the bitmask 0x10000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_404"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_404" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_404")))
#endif

uint32_t FREG_TSD01_GetIrqDbg_IrqAvailable( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_IRQDBG+(index*0x4)));
    value = ( value & 0x10000000UL ) >> 28;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterTargetIndex" of register "IrqDbg".
**
** For SECTION_END_IRQ and CRC_ERROR_IRQ the FILTER_TARGET_INDEX indicates to which filter target the corresponding IRQ belongs.
**
** If N (N<=32) filter targets are defined for a PID channel (these filter targets are indexed from 0 to N-1) and the current section matches the filter target N, then the FILTER_TARGET_INDEX is set to N.
** For example, 32 filter targets are defined for a PID channel (these filter targets are indexed from 0 to 31).
** If the current section matches the filter target 0, then the FILTER_TARGET_INDEX is set to '00000' (decimal 0).
** If the current section matches the filter target 15, then the FILTER_TARGET_INDEX is set to '01111' (decimal 15).
**
** If the current section matches more than one filter targets,  then the FILTER_TARGET_INDEX is set to the lowest target index.
** For example, if a section matches the filter target 1, 2, 3, then the FILTER_TARGET_INDEX is set to '00001' (decimal 1).
**
** For all other IRQs the FILTER_TARGET_INDEX are constant '00000'.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterTargetIndex" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_405"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_405" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_405")))
#endif

uint32_t FREG_TSD01_GetIrqDbg_FilterTargetIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_IRQDBG+(index*0x4)));
    value = ( value & 0x001F0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqValue" of register "IrqDbg".
**
** IRQ of TSD01.
**  Read the TSD01_IRQ for debug. The internal read pointer will NOT be incremented
**
** The IRQ  value and priority are defined below (the smaller the priority number is, the higher the priority. This means, TRANSPORT_ERROR_IRQ has the highest priority.)
** IRQ                                            Value      Priority
** SCRAMBLED_PACKET_IRQ      : 0xF2         8
** DUPLICATE_IRQ                       : 0xF1         8
** PCR_1_AF_LT_7_IRQ                : 0xF0         8
** PL_1_AF_GT183_IRQ                : 0xEF         8
** PL_0_AF_NE183_IRQ                : 0xEE         8
** TRANSPORT_ERROR_IRQ        : 0xED         0
** NULL_PACKET_IRQ                  : 0xEC        8
** NEW_PTS_IRQ_3                      : 0xEB        8
** NEW_PTS_IRQ_2                      : 0xEA        8
** NEW_PTS_IRQ_1                      : 0xE9        8
** NEW_PTS_IRQ_0                      : 0xE8        8
** PUS_IRQ                                  : 0xE7         8
** CRC_ERROR_IRQ                     : 0xE6         6
** NEW_PCR_IRQ                         : 0xE5         2
** CONTINUITY_CNT_ERROR_IRQ : 0xE4         1
** INPUT_TIMEOUT_IRQ                : 0xE3         5
** VALID_INPUT_TIMEOUT_IRQ      : 0xE2        4
** SECTION_END_IRQ                   : 0xE1         7
** PACKET_END_IRQ                    : 0xE0         3
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqValue" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_406"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_406" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_406")))
#endif

uint32_t FREG_TSD01_GetIrqDbg_IrqValue( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_IRQDBG+(index*0x4)));
    value = ( value & 0x0000FF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd1Select" of register "IrqDbg".
**
** Indicates if this IRQ is generated by TSD0 or TSD1.
**
** - '0': TSD0.
** - '1': TSD1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd1Select" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_407"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_407" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_407")))
#endif

uint32_t FREG_TSD01_GetIrqDbg_Tsd1Select( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_IRQDBG+(index*0x4)));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidIndex" of register "IrqDbg".
**
** PID_INDEX, ranges from 0 to 31.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_408"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_408" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_408")))
#endif

uint32_t FREG_TSD01_GetIrqDbg_PidIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD01_IRQDBG+(index*0x4)));
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "IrqRdPtr".
**
** This function reads the value from the register "IrqRdPtr".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_409"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_409" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_409")))
#endif

uint32_t FREG_TSD01_GetIrqRdPtr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_IRQRDPTR));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqRdPtr" of register "IrqRdPtr".
**
** The read pointer of the TSD01 IRQ FIFO.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqRdPtr" consists of the bits 5..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000003FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_410"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_410" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_410")))
#endif

uint32_t FREG_TSD01_GetIrqRdPtr_IrqRdPtr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_IRQRDPTR));
    value = ( value & 0x0000003FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "IrqWrPtr".
**
** This function reads the value from the register "IrqWrPtr".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_411"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_411" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_411")))
#endif

uint32_t FREG_TSD01_GetIrqWrPtr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_IRQWRPTR));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqWrPtr" of register "IrqWrPtr".
**
** The write pointer of the TSD01 IRQ FIFO.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqWrPtr" consists of the bits 5..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000003FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_412"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_412" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_412")))
#endif

uint32_t FREG_TSD01_GetIrqWrPtr_IrqWrPtr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_IRQWRPTR));
    value = ( value & 0x0000003FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "IrqClear".
**
** This function writes the given value to the register "IrqClear".
**
** All IRQs in the IRQ-FIFO will be cleared if this register is written (no matter what value).
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_413"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_413" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_413")))
#endif

void FREG_TSD01_SetIrqClear( uint32_t value )
{
    FREG_TSD01_IrqClearMirror = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_IRQCLEAR, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_IRQCLEAR)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ClearAllIrq" of register "IrqClear".
**
** All IRQs in the IRQ-FIFO will be cleared if this register is written (no matter what value).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ClearAllIrq" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_414"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_414" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_414")))
#endif

void FREG_TSD01_SetIrqClear_ClearAllIrq( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    value |= FREG_TSD01_IrqClearMirror & ~mask;
    FREG_TSD01_IrqClearMirror = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_IRQCLEAR, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_IRQCLEAR)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "IrqClear".
**
** This function reads the value from the register "IrqClear".
**
** All IRQs in the IRQ-FIFO will be cleared if this register is written (no matter what value).
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_415"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_415" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_415")))
#endif

uint32_t FREG_TSD01_GetmIrqClear( void )
{
    register uint32_t value = FREG_TSD01_IrqClearMirror;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ClearAllIrq" of register "IrqClear".
**
** All IRQs in the IRQ-FIFO will be cleared if this register is written (no matter what value).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "ClearAllIrq" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_416"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_416" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_416")))
#endif

uint32_t FREG_TSD01_GetmIrqClear_ClearAllIrq( void )
{
    register uint32_t value = FREG_TSD01_IrqClearMirror;
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SbCtrl".
**
** This function writes the given value to the index-th entry of the register
** array SbCtrl.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_417"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_417" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_417")))
#endif

void FREG_TSD0_SetSbCtrl( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "WrPtr" of register "SbCtrl".
**
** Write pointer of the section header buffer
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "WrPtr" consists of the bits 31..26,
**       the given bitgroup value will be shifted left by 26 bits and
**       masked using the bitmask 0xFC000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_418"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_418" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_418")))
#endif

void FREG_TSD0_SetSbCtrl_WrPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFC000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 26 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "RdPtr" of register "SbCtrl".
**
** Read pointer of the section header buffer
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "RdPtr" consists of the bits 25..20,
**       the given bitgroup value will be shifted left by 20 bits and
**       masked using the bitmask 0x03F00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_419"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_419" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_419")))
#endif

void FREG_TSD0_SetSbCtrl_RdPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x03F00000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 20 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ResidueCnt" of register "SbCtrl".
**
** The number of remaining data bytes of the corresponding target.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ResidueCnt" consists of the bits 19..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x000FFF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_420"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_420" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_420")))
#endif

void FREG_TSD0_SetSbCtrl_ResidueCnt( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000FFF00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PaddingCnt" of register "SbCtrl".
**
** The number of padding bytes needed for the current section.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PaddingCnt" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_421"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_421" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_421")))
#endif

void FREG_TSD0_SetSbCtrl_PaddingCnt( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000000C0UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterMatch" of register "SbCtrl".
**
** Indicates if the current section matches any filter target.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterMatch" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_422"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_422" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_422")))
#endif

void FREG_TSD0_SetSbCtrl_FilterMatch( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterIndex" of register "SbCtrl".
**
** The index of the matched filter.
**  If a section matches multiple filter targets, the smallest filter target indext is stored. For example, if a section matches the target 3, target 7 and target 15, FILTER_INDEX is set to 00011 (decimal 3).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_423"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_423" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_423")))
#endif

void FREG_TSD0_SetSbCtrl_FilterIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000001FUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SbCtrl".
**
** This function reads the value from the index-th entry of the register
** array SbCtrl.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_424"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_424" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_424")))
#endif

uint32_t FREG_TSD0_GetSbCtrl( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "WrPtr" of register "SbCtrl".
**
** Write pointer of the section header buffer
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "WrPtr" consists of the bits 31..26,
**       the given bitgroup value will be shifted left by 26 bits and
**       masked using the bitmask 0xFC000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_425"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_425" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_425")))
#endif

uint32_t FREG_TSD0_GetSbCtrl_WrPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8)));
    value = ( value & 0xFC000000UL ) >> 26;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "RdPtr" of register "SbCtrl".
**
** Read pointer of the section header buffer
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "RdPtr" consists of the bits 25..20,
**       the given bitgroup value will be shifted left by 20 bits and
**       masked using the bitmask 0x03F00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_426"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_426" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_426")))
#endif

uint32_t FREG_TSD0_GetSbCtrl_RdPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8)));
    value = ( value & 0x03F00000UL ) >> 20;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ResidueCnt" of register "SbCtrl".
**
** The number of remaining data bytes of the corresponding target.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ResidueCnt" consists of the bits 19..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x000FFF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_427"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_427" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_427")))
#endif

uint32_t FREG_TSD0_GetSbCtrl_ResidueCnt( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8)));
    value = ( value & 0x000FFF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PaddingCnt" of register "SbCtrl".
**
** The number of padding bytes needed for the current section.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PaddingCnt" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_428"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_428" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_428")))
#endif

uint32_t FREG_TSD0_GetSbCtrl_PaddingCnt( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8)));
    value = ( value & 0x000000C0UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterMatch" of register "SbCtrl".
**
** Indicates if the current section matches any filter target.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterMatch" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_429"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_429" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_429")))
#endif

uint32_t FREG_TSD0_GetSbCtrl_FilterMatch( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8)));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterIndex" of register "SbCtrl".
**
** The index of the matched filter.
**  If a section matches multiple filter targets, the smallest filter target indext is stored. For example, if a section matches the target 3, target 7 and target 15, FILTER_INDEX is set to 00011 (decimal 3).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_430"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_430" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_430")))
#endif

uint32_t FREG_TSD0_GetSbCtrl_FilterIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_SBCTRL+(index*0x8)));
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Crc".
**
** This function writes the given value to the index-th entry of the register
** array Crc.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_431"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_431" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_431")))
#endif

void FREG_TSD0_SetCrc( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_CRC+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_CRC+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Crc" of register "Crc".
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Crc" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_432"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_432" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_432")))
#endif

void FREG_TSD0_SetCrc_Crc( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD0_CRC+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_CRC+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_CRC+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Crc".
**
** This function reads the value from the index-th entry of the register
** array Crc.
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_433"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_433" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_433")))
#endif

uint32_t FREG_TSD0_GetCrc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_CRC+(index*0x8)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Crc" of register "Crc".
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Crc" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_434"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_434" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_434")))
#endif

uint32_t FREG_TSD0_GetCrc_Crc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD0_CRC+(index*0x8)));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfActive".
**
** This function reads the value from the register "SfActive".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_435"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_435" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_435")))
#endif

uint32_t FREG_TSD0_GetSfActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD0_SFACTIVE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SfActive" of register "SfActive".
**
** Each bit indicates if Section Filter (SF) of the corresponding PID in TSD0 is active (bit n corresponds to PID channel n).
**
** - '0': not active.
** - '1': active.
** Section Filter is active, if the section comparison can't be started because the so far collected section bytes are not enough (less than the configured section filter Target Length) or the section comparison is finished but the section end is not reached yet.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "SfActive" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_436"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_436" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_436")))
#endif

uint32_t FREG_TSD0_GetSfActive_SfActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD0_SFACTIVE));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SbCtrl".
**
** This function writes the given value to the index-th entry of the register
** array SbCtrl.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_437"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_437" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_437")))
#endif

void FREG_TSD1_SetSbCtrl( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "WrPtr" of register "SbCtrl".
**
** Write pointer of the section header buffer
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "WrPtr" consists of the bits 31..26,
**       the given bitgroup value will be shifted left by 26 bits and
**       masked using the bitmask 0xFC000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_438"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_438" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_438")))
#endif

void FREG_TSD1_SetSbCtrl_WrPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFC000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 26 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "RdPtr" of register "SbCtrl".
**
** Read pointer of the section header buffer
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "RdPtr" consists of the bits 25..20,
**       the given bitgroup value will be shifted left by 20 bits and
**       masked using the bitmask 0x03F00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_439"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_439" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_439")))
#endif

void FREG_TSD1_SetSbCtrl_RdPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x03F00000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 20 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ResidueCnt" of register "SbCtrl".
**
** The number of remaining data bytes of the corresponding target.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ResidueCnt" consists of the bits 19..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x000FFF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_440"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_440" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_440")))
#endif

void FREG_TSD1_SetSbCtrl_ResidueCnt( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000FFF00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PaddingCnt" of register "SbCtrl".
**
** The number of padding bytes needed for the current section.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PaddingCnt" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_441"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_441" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_441")))
#endif

void FREG_TSD1_SetSbCtrl_PaddingCnt( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000000C0UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterMatch" of register "SbCtrl".
**
** Indicates if the current section matches any filter target.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterMatch" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_442"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_442" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_442")))
#endif

void FREG_TSD1_SetSbCtrl_FilterMatch( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterIndex" of register "SbCtrl".
**
** The index of the matched filter.
**  If a section matches multiple filter targets, the smallest filter target indext is stored. For example, if a section matches the target 3, target 7 and target 15, FILTER_INDEX is set to 00011 (decimal 3).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_443"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_443" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_443")))
#endif

void FREG_TSD1_SetSbCtrl_FilterIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000001FUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SbCtrl".
**
** This function reads the value from the index-th entry of the register
** array SbCtrl.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_444"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_444" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_444")))
#endif

uint32_t FREG_TSD1_GetSbCtrl( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "WrPtr" of register "SbCtrl".
**
** Write pointer of the section header buffer
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "WrPtr" consists of the bits 31..26,
**       the given bitgroup value will be shifted left by 26 bits and
**       masked using the bitmask 0xFC000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_445"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_445" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_445")))
#endif

uint32_t FREG_TSD1_GetSbCtrl_WrPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8)));
    value = ( value & 0xFC000000UL ) >> 26;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "RdPtr" of register "SbCtrl".
**
** Read pointer of the section header buffer
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "RdPtr" consists of the bits 25..20,
**       the given bitgroup value will be shifted left by 20 bits and
**       masked using the bitmask 0x03F00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_446"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_446" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_446")))
#endif

uint32_t FREG_TSD1_GetSbCtrl_RdPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8)));
    value = ( value & 0x03F00000UL ) >> 20;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ResidueCnt" of register "SbCtrl".
**
** The number of remaining data bytes of the corresponding target.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ResidueCnt" consists of the bits 19..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x000FFF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_447"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_447" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_447")))
#endif

uint32_t FREG_TSD1_GetSbCtrl_ResidueCnt( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8)));
    value = ( value & 0x000FFF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PaddingCnt" of register "SbCtrl".
**
** The number of padding bytes needed for the current section.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PaddingCnt" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_448"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_448" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_448")))
#endif

uint32_t FREG_TSD1_GetSbCtrl_PaddingCnt( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8)));
    value = ( value & 0x000000C0UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterMatch" of register "SbCtrl".
**
** Indicates if the current section matches any filter target.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterMatch" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_449"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_449" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_449")))
#endif

uint32_t FREG_TSD1_GetSbCtrl_FilterMatch( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8)));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterIndex" of register "SbCtrl".
**
** The index of the matched filter.
**  If a section matches multiple filter targets, the smallest filter target indext is stored. For example, if a section matches the target 3, target 7 and target 15, FILTER_INDEX is set to 00011 (decimal 3).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_450"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_450" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_450")))
#endif

uint32_t FREG_TSD1_GetSbCtrl_FilterIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_SBCTRL+(index*0x8)));
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Crc".
**
** This function writes the given value to the index-th entry of the register
** array Crc.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_451"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_451" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_451")))
#endif

void FREG_TSD1_SetCrc( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_CRC+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_CRC+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Crc" of register "Crc".
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Crc" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_452"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_452" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_452")))
#endif

void FREG_TSD1_SetCrc_Crc( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD1_CRC+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_CRC+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_CRC+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Crc".
**
** This function reads the value from the index-th entry of the register
** array Crc.
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_453"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_453" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_453")))
#endif

uint32_t FREG_TSD1_GetCrc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_CRC+(index*0x8)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Crc" of register "Crc".
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Crc" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_454"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_454" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_454")))
#endif

uint32_t FREG_TSD1_GetCrc_Crc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD1_CRC+(index*0x8)));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfActive".
**
** This function reads the value from the register "SfActive".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_455"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_455" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_455")))
#endif

uint32_t FREG_TSD1_GetSfActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD1_SFACTIVE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SfActive" of register "SfActive".
**
** Each bit indicates if Section Filter (SF) of the corresponding PID in TSD1 is active (bit n corresponds to PID channel n).
**
** - '0': not active.
** - '1': active.
** Section Filter is active, if the section comparison can't be started because the so far collected section bytes are not enough (less than the configured section filter Target Length) or the section comparison is finished but the section end is not reached yet.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "SfActive" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_456"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_456" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_456")))
#endif

uint32_t FREG_TSD1_GetSfActive_SfActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD1_SFACTIVE));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SfTargets".
**
** This function writes the given value to the index-th entry of the register
** array SfTargets.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_457"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_457" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_457")))
#endif

void FREG_TSD0_SetSfTargets( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    FREG_TSD0_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SecData0" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SecData0" consists of the bits 31..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0xFF000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_458"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_458" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_458")))
#endif

void FREG_TSD0_SetSfTargets_SecData0( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFF000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 24 ) & mask;
    value |= FREG_TSD0_SfTargetsMirror[index] & ~mask;
    FREG_TSD0_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterEnable0" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_0 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [31:24] are DATA and [23:16] are ENABLE, these 16 bits together ([31:16]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterEnable0" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_459"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_459" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_459")))
#endif

void FREG_TSD0_SetSfTargets_FilterEnable0( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00FF0000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD0_SfTargetsMirror[index] & ~mask;
    FREG_TSD0_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SecData1" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SecData1" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_460"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_460" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_460")))
#endif

void FREG_TSD0_SetSfTargets_SecData1( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000FF00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD0_SfTargetsMirror[index] & ~mask;
    FREG_TSD0_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterEnable1" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_1 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [15:8] are DATA and [7:0] are ENABLE, these 16 bits together ([15:0]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterEnable1" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_461"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_461" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_461")))
#endif

void FREG_TSD0_SetSfTargets_FilterEnable1( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000000FFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_SfTargetsMirror[index] & ~mask;
    FREG_TSD0_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfTargets".
**
** This function reads the value from the index-th entry of the register
** array SfTargets.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_462"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_462" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_462")))
#endif

uint32_t FREG_TSD0_GetmSfTargets( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_SfTargetsMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SecData0" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SecData0" consists of the bits 31..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0xFF000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_463"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_463" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_463")))
#endif

uint32_t FREG_TSD0_GetmSfTargets_SecData0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_SfTargetsMirror[index];
    value = ( value & 0xFF000000UL ) >> 24;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterEnable0" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_0 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [31:24] are DATA and [23:16] are ENABLE, these 16 bits together ([31:16]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterEnable0" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_464"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_464" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_464")))
#endif

uint32_t FREG_TSD0_GetmSfTargets_FilterEnable0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_SfTargetsMirror[index];
    value = ( value & 0x00FF0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SecData1" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SecData1" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_465"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_465" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_465")))
#endif

uint32_t FREG_TSD0_GetmSfTargets_SecData1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_SfTargetsMirror[index];
    value = ( value & 0x0000FF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterEnable1" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_1 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [15:8] are DATA and [7:0] are ENABLE, these 16 bits together ([15:0]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterEnable1" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_466"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_466" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_466")))
#endif

uint32_t FREG_TSD0_GetmSfTargets_FilterEnable1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_SfTargetsMirror[index];
    value = ( value & 0x000000FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SfPtr".
**
** This function writes the given value to the index-th entry of the register
** array SfPtr.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_467"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_467" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_467")))
#endif

void FREG_TSD0_SetSfPtr( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    FREG_TSD0_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Eol" of register "SfPtr".
**
** End of List flag.
**
** - '1': The corresponding RAM line is the End of filter
** target.
** - '0': Not End of List. The NXT_DEP_PTR below points
** to the next DEP (Data Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Eol" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_468"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_468" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_468")))
#endif

void FREG_TSD0_SetSfPtr_Eol( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD0_SfPtrMirror[index] & ~mask;
    FREG_TSD0_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NxtDepPtr" of register "SfPtr".
**
** If EOL = '1', NXT_DEP_PTR must be set to 0x00.
**
** If EOL = '0', set NXT_DEP_PTR to the line number of next DEP. If NXT_DEP_PTR is set to 0, this means the corresponding RAM line is availabe.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NxtDepPtr" consists of the bits 6..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000007FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_469"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_469" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_469")))
#endif

void FREG_TSD0_SetSfPtr_NxtDepPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000007FUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD0_SfPtrMirror[index] & ~mask;
    FREG_TSD0_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD0_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD0_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfPtr".
**
** This function reads the value from the index-th entry of the register
** array SfPtr.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_470"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_470" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_470")))
#endif

uint32_t FREG_TSD0_GetmSfPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_SfPtrMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Eol" of register "SfPtr".
**
** End of List flag.
**
** - '1': The corresponding RAM line is the End of filter
** target.
** - '0': Not End of List. The NXT_DEP_PTR below points
** to the next DEP (Data Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Eol" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_471"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_471" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_471")))
#endif

uint32_t FREG_TSD0_GetmSfPtr_Eol( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 128 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_SfPtrMirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NxtDepPtr" of register "SfPtr".
**
** If EOL = '1', NXT_DEP_PTR must be set to 0x00.
**
** If EOL = '0', set NXT_DEP_PTR to the line number of next DEP. If NXT_DEP_PTR is set to 0, this means the corresponding RAM line is availabe.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NxtDepPtr" consists of the bits 6..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000007FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_472"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_472" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_472")))
#endif

uint32_t FREG_TSD0_GetmSfPtr_NxtDepPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 128 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD0_SfPtrMirror[index];
    value = ( value & 0x0000007FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SfTargets".
**
** This function writes the given value to the index-th entry of the register
** array SfTargets.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_473"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_473" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_473")))
#endif

void FREG_TSD1_SetSfTargets( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    FREG_TSD1_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SecData0" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SecData0" consists of the bits 31..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0xFF000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_474"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_474" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_474")))
#endif

void FREG_TSD1_SetSfTargets_SecData0( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFF000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 24 ) & mask;
    value |= FREG_TSD1_SfTargetsMirror[index] & ~mask;
    FREG_TSD1_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterEnable0" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_0 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [31:24] are DATA and [23:16] are ENABLE, these 16 bits together ([31:16]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterEnable0" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_475"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_475" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_475")))
#endif

void FREG_TSD1_SetSfTargets_FilterEnable0( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00FF0000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD1_SfTargetsMirror[index] & ~mask;
    FREG_TSD1_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SecData1" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SecData1" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_476"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_476" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_476")))
#endif

void FREG_TSD1_SetSfTargets_SecData1( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000FF00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD1_SfTargetsMirror[index] & ~mask;
    FREG_TSD1_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterEnable1" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_1 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [15:8] are DATA and [7:0] are ENABLE, these 16 bits together ([15:0]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterEnable1" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_477"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_477" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_477")))
#endif

void FREG_TSD1_SetSfTargets_FilterEnable1( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000000FFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_SfTargetsMirror[index] & ~mask;
    FREG_TSD1_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfTargets".
**
** This function reads the value from the index-th entry of the register
** array SfTargets.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_478"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_478" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_478")))
#endif

uint32_t FREG_TSD1_GetmSfTargets( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_SfTargetsMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SecData0" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SecData0" consists of the bits 31..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0xFF000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_479"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_479" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_479")))
#endif

uint32_t FREG_TSD1_GetmSfTargets_SecData0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_SfTargetsMirror[index];
    value = ( value & 0xFF000000UL ) >> 24;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterEnable0" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_0 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [31:24] are DATA and [23:16] are ENABLE, these 16 bits together ([31:16]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterEnable0" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_480"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_480" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_480")))
#endif

uint32_t FREG_TSD1_GetmSfTargets_FilterEnable0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_SfTargetsMirror[index];
    value = ( value & 0x00FF0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SecData1" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SecData1" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_481"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_481" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_481")))
#endif

uint32_t FREG_TSD1_GetmSfTargets_SecData1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_SfTargetsMirror[index];
    value = ( value & 0x0000FF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterEnable1" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_1 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [15:8] are DATA and [7:0] are ENABLE, these 16 bits together ([15:0]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterEnable1" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_482"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_482" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_482")))
#endif

uint32_t FREG_TSD1_GetmSfTargets_FilterEnable1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_SfTargetsMirror[index];
    value = ( value & 0x000000FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SfPtr".
**
** This function writes the given value to the index-th entry of the register
** array SfPtr.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_483"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_483" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_483")))
#endif

void FREG_TSD1_SetSfPtr( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    FREG_TSD1_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Eol" of register "SfPtr".
**
** End of List flag.
**
** - '1': The corresponding RAM line is the End of filter
** target.
** - '0': Not End of List. The corresponding NXT_DEP_PTR
** points to the next DEP (Data Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Eol" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_484"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_484" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_484")))
#endif

void FREG_TSD1_SetSfPtr_Eol( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD1_SfPtrMirror[index] & ~mask;
    FREG_TSD1_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NxtDepPtr" of register "SfPtr".
**
** If EOL = '1', NXT_DEP_PTR must be set to 0x00.
**
** If EOL = '0', set NXT_DEP_PTR to the line number of next DEP. If NXT_DEP_PTR is set to 0, this means the corresponding RAM line is availabe.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NxtDepPtr" consists of the bits 6..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000007FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_485"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_485" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_485")))
#endif

void FREG_TSD1_SetSfPtr_NxtDepPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000007FUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD1_SfPtrMirror[index] & ~mask;
    FREG_TSD1_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD1_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD1_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfPtr".
**
** This function reads the value from the index-th entry of the register
** array SfPtr.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_486"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_486" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_486")))
#endif

uint32_t FREG_TSD1_GetmSfPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_SfPtrMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Eol" of register "SfPtr".
**
** End of List flag.
**
** - '1': The corresponding RAM line is the End of filter
** target.
** - '0': Not End of List. The corresponding NXT_DEP_PTR
** points to the next DEP (Data Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Eol" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_487"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_487" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_487")))
#endif

uint32_t FREG_TSD1_GetmSfPtr_Eol( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 128 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_SfPtrMirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NxtDepPtr" of register "SfPtr".
**
** If EOL = '1', NXT_DEP_PTR must be set to 0x00.
**
** If EOL = '0', set NXT_DEP_PTR to the line number of next DEP. If NXT_DEP_PTR is set to 0, this means the corresponding RAM line is availabe.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NxtDepPtr" consists of the bits 6..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000007FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_488"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_488" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_488")))
#endif

uint32_t FREG_TSD1_GetmSfPtr_NxtDepPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 128 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD1_SfPtrMirror[index];
    value = ( value & 0x0000007FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidChannelActive".
**
** This function writes the given value to the index-th entry of the register
** array PidChannelActive.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_489"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_489" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_489")))
#endif

void FREG_TSD2_SetPidChannelActive( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidChannelEnable" of register "PidChannelActive".
**
**  - '0': Deactivating the corresponding PID channel.
**
** - '1': activating the corresponding PID channel.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidChannelEnable" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_490"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_490" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_490")))
#endif

void FREG_TSD2_SetPidChannelActive_PidChannelEnable( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_PIDCHANNELACTIVE+(index*0x4))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FirstPacketFlag" of register "PidChannelActive".
**
**  - '0': The upcoming packet is not the first packet to be received for this PID channel.
**
** - '1': The upcoming packet is the first packet to be received for this PID channel. After the first packet is received, this bit will be automaticaly cleared.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FirstPacketFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_491"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_491" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_491")))
#endif

void FREG_TSD2_SetPidChannelActive_FirstPacketFlag( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_PIDCHANNELACTIVE+(index*0x4))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidChannelActive".
**
** This function reads the value from the index-th entry of the register
** array PidChannelActive.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_492"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_492" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_492")))
#endif

uint32_t FREG_TSD2_GetPidChannelActive( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_PIDCHANNELACTIVE+(index*0x4)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidChannelEnable" of register "PidChannelActive".
**
**  - '0': Deactivating the corresponding PID channel.
**
** - '1': activating the corresponding PID channel.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidChannelEnable" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_493"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_493" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_493")))
#endif

uint32_t FREG_TSD2_GetPidChannelActive_PidChannelEnable( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_PIDCHANNELACTIVE+(index*0x4)));
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FirstPacketFlag" of register "PidChannelActive".
**
**  - '0': The upcoming packet is not the first packet to be received for this PID channel.
**
** - '1': The upcoming packet is the first packet to be received for this PID channel. After the first packet is received, this bit will be automaticaly cleared.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FirstPacketFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_494"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_494" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_494")))
#endif

uint32_t FREG_TSD2_GetPidChannelActive_FirstPacketFlag( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_PIDCHANNELACTIVE+(index*0x4)));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidChannelActive".
**
** This function writes the given value to the index-th entry of the register
** array PidChannelActive.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_495"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_495" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_495")))
#endif

void FREG_TSD3_SetPidChannelActive( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidChannelEnable" of register "PidChannelActive".
**
**  - '0': Deactivating the corresponding PID channel.
**
** - '1': activating the corresponding PID channel.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidChannelEnable" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_496"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_496" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_496")))
#endif

void FREG_TSD3_SetPidChannelActive_PidChannelEnable( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_PIDCHANNELACTIVE+(index*0x4))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FirstPacketFlag" of register "PidChannelActive".
**
**  - '0': The upcoming packet is not the first packet to be received for this PID channel.
**
** - '1': The upcoming packet is the first packet to be received for this PID channel. After the first packet is received, this bit will be automaticaly cleared.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FirstPacketFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_497"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_497" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_497")))
#endif

void FREG_TSD3_SetPidChannelActive_FirstPacketFlag( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_PIDCHANNELACTIVE+(index*0x4))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCHANNELACTIVE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCHANNELACTIVE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidChannelActive".
**
** This function reads the value from the index-th entry of the register
** array PidChannelActive.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_498"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_498" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_498")))
#endif

uint32_t FREG_TSD3_GetPidChannelActive( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_PIDCHANNELACTIVE+(index*0x4)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidChannelEnable" of register "PidChannelActive".
**
**  - '0': Deactivating the corresponding PID channel.
**
** - '1': activating the corresponding PID channel.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidChannelEnable" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_499"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_499" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_499")))
#endif

uint32_t FREG_TSD3_GetPidChannelActive_PidChannelEnable( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_PIDCHANNELACTIVE+(index*0x4)));
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FirstPacketFlag" of register "PidChannelActive".
**
**  - '0': The upcoming packet is not the first packet to be received for this PID channel.
**
** - '1': The upcoming packet is the first packet to be received for this PID channel. After the first packet is received, this bit will be automaticaly cleared.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FirstPacketFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_500"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_500" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_500")))
#endif

uint32_t FREG_TSD3_GetPidChannelActive_FirstPacketFlag( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_PIDCHANNELACTIVE+(index*0x4)));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "InputCtrl".
**
** This function writes the given value to the register "InputCtrl".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_501"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_501" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_501")))
#endif

void FREG_TSD23_SetInputCtrl( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts3AmSync" of register "InputCtrl".
**
** Enable automatical synchronization (AM_SYNC) on Sync Byte:
** - '0': sync on start signal or TS3_en
** - '1': auto search for sync byte 0x47 and 0xB8
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts3AmSync" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_502"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_502" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_502")))
#endif

void FREG_TSD23_SetInputCtrl_Ts3AmSync( uint32_t value )
{
    register uint32_t mask = 0x00002000UL;
    value = ( value << 13 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts3PacketStart" of register "InputCtrl".
**
** Polarity of the signal TS3_PACKET_START:
** - '0': high active
** - '1': low active
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts3PacketStart" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_503"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_503" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_503")))
#endif

void FREG_TSD23_SetInputCtrl_Ts3PacketStart( uint32_t value )
{
    register uint32_t mask = 0x00001000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts3En" of register "InputCtrl".
**
** Polarity of TS3_EN:
** - '0': high active
** - '1': low active
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts3En" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_504"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_504" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_504")))
#endif

void FREG_TSD23_SetInputCtrl_Ts3En( uint32_t value )
{
    register uint32_t mask = 0x00000800UL;
    value = ( value << 11 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts3Clk" of register "InputCtrl".
**
** Indicate at which edge (rising of falling edge) of TS3_CLK the TS input data to TSD3 shall be sampled:
** - '0': sample TS data at the rising edge of TS3_CLK.
**
** - '1': sample TS data at the falling edge of TS3_CLK.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts3Clk" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_505"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_505" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_505")))
#endif

void FREG_TSD23_SetInputCtrl_Ts3Clk( uint32_t value )
{
    register uint32_t mask = 0x00000400UL;
    value = ( value << 10 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts3SerialParallelMode" of register "InputCtrl".
**
** Specifies the serial and paralle mode:
** - '01': serial with TS3_PACKET_START
** - '10': parallel without TS3_PACKET_START
** - '11': parallel with TS3_PACKET_START
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts3SerialParallelMode" consists of the bits 9..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000300UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_506"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_506" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_506")))
#endif

void FREG_TSD23_SetInputCtrl_Ts3SerialParallelMode( uint32_t value )
{
    register uint32_t mask = 0x00000300UL;
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts2AmSync" of register "InputCtrl".
**
** Enable automatical synchronization (AM_SYNC) on Sync Byte:
** - '0': sync on start signal or TS2_en
** - '1': auto search for sync byte 0x47 and 0xB8
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts2AmSync" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_507"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_507" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_507")))
#endif

void FREG_TSD23_SetInputCtrl_Ts2AmSync( uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    value = ( value << 5 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts2PacketStart" of register "InputCtrl".
**
** Polarity of the signal TS2_PACKET_START:
** - '0': high active
** - '1': low active
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts2PacketStart" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_508"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_508" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_508")))
#endif

void FREG_TSD23_SetInputCtrl_Ts2PacketStart( uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    value = ( value << 4 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts2En" of register "InputCtrl".
**
** Polarity of TS2_EN:
** - '0': high active
** - '1': low active
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts2En" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_509"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_509" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_509")))
#endif

void FREG_TSD23_SetInputCtrl_Ts2En( uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    value = ( value << 3 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts2Clk" of register "InputCtrl".
**
** Indicate at which edge (rising of falling edge) of TS2_CLK the TS input data to TSD2 shall be sampled:
** - '0': sample TS data at the rising edge of TS2_CLK.
**
** - '1': sample TS data at the falling edge of TS2_CLK.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts2Clk" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_510"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_510" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_510")))
#endif

void FREG_TSD23_SetInputCtrl_Ts2Clk( uint32_t value )
{
    register uint32_t mask = 0x00000004UL;
    value = ( value << 2 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts2SerialParallelMode" of register "InputCtrl".
**
** Specifies the serial and paralle mode:
** - '01': serial with TS2_PACKET_START
** - '10': parallel without TS2_PACKET_START
** - '11': parallel with TS2_PACKET_START
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts2SerialParallelMode" consists of the bits 1..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000003UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_511"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_511" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_511")))
#endif

void FREG_TSD23_SetInputCtrl_Ts2SerialParallelMode( uint32_t value )
{
    register uint32_t mask = 0x00000003UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 10
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "InputCtrl".
**
** This function reads the value from the register "InputCtrl".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_512"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_512" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_512")))
#endif

uint32_t FREG_TSD23_GetInputCtrl( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts3AmSync" of register "InputCtrl".
**
** Enable automatical synchronization (AM_SYNC) on Sync Byte:
** - '0': sync on start signal or TS3_en
** - '1': auto search for sync byte 0x47 and 0xB8
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts3AmSync" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_513"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_513" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_513")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts3AmSync( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00002000UL ) >> 13;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts3PacketStart" of register "InputCtrl".
**
** Polarity of the signal TS3_PACKET_START:
** - '0': high active
** - '1': low active
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts3PacketStart" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_514"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_514" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_514")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts3PacketStart( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00001000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts3En" of register "InputCtrl".
**
** Polarity of TS3_EN:
** - '0': high active
** - '1': low active
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts3En" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_515"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_515" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_515")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts3En( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00000800UL ) >> 11;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts3Clk" of register "InputCtrl".
**
** Indicate at which edge (rising of falling edge) of TS3_CLK the TS input data to TSD3 shall be sampled:
** - '0': sample TS data at the rising edge of TS3_CLK.
**
** - '1': sample TS data at the falling edge of TS3_CLK.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts3Clk" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_516"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_516" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_516")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts3Clk( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00000400UL ) >> 10;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts3SerialParallelMode" of register "InputCtrl".
**
** Specifies the serial and paralle mode:
** - '01': serial with TS3_PACKET_START
** - '10': parallel without TS3_PACKET_START
** - '11': parallel with TS3_PACKET_START
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts3SerialParallelMode" consists of the bits 9..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000300UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_517"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_517" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_517")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts3SerialParallelMode( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00000300UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts2AmSync" of register "InputCtrl".
**
** Enable automatical synchronization (AM_SYNC) on Sync Byte:
** - '0': sync on start signal or TS2_en
** - '1': auto search for sync byte 0x47 and 0xB8
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts2AmSync" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_518"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_518" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_518")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts2AmSync( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts2PacketStart" of register "InputCtrl".
**
** Polarity of the signal TS2_PACKET_START:
** - '0': high active
** - '1': low active
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts2PacketStart" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_519"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_519" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_519")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts2PacketStart( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts2En" of register "InputCtrl".
**
** Polarity of TS2_EN:
** - '0': high active
** - '1': low active
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts2En" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_520"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_520" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_520")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts2En( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts2Clk" of register "InputCtrl".
**
** Indicate at which edge (rising of falling edge) of TS2_CLK the TS input data to TSD2 shall be sampled:
** - '0': sample TS data at the rising edge of TS2_CLK.
**
** - '1': sample TS data at the falling edge of TS2_CLK.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts2Clk" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_521"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_521" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_521")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts2Clk( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00000004UL ) >> 2;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts2SerialParallelMode" of register "InputCtrl".
**
** Specifies the serial and paralle mode:
** - '01': serial with TS2_PACKET_START
** - '10': parallel without TS2_PACKET_START
** - '11': parallel with TS2_PACKET_START
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts2SerialParallelMode" consists of the bits 1..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000003UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_522"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_522" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_522")))
#endif

uint32_t FREG_TSD23_GetInputCtrl_Ts2SerialParallelMode( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTCTRL));
    value = ( value & 0x00000003UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "StartDistance".
**
** This function writes the given value to the register "StartDistance".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_523"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_523" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_523")))
#endif

void FREG_TSD23_SetStartDistance( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_STARTDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_STARTDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts3StartDistance" of register "StartDistance".
**
** Distance between Sync Bytes for the input channel 1.
**  If TS3_AM_SYNC is 1, this value must be configured correctly. START_DISTANCE = packet-length - 1 (e.g. 187 or 203)
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts3StartDistance" consists of the bits 19..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x000FF000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_524"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_524" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_524")))
#endif

void FREG_TSD23_SetStartDistance_Ts3StartDistance( uint32_t value )
{
    register uint32_t mask = 0x000FF000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_STARTDISTANCE)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_STARTDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_STARTDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Ts2StartDistance" of register "StartDistance".
**
** Distance between Sync Bytes for the input channel 0.
**  If TS2_AM_SYNC is 1, this value must be configured correctly. START_DISTANCE = packet-length - 1 (e.g. 187 or 203)
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Ts2StartDistance" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_525"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_525" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_525")))
#endif

void FREG_TSD23_SetStartDistance_Ts2StartDistance( uint32_t value )
{
    register uint32_t mask = 0x000000FFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_STARTDISTANCE)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_STARTDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_STARTDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "StartDistance".
**
** This function reads the value from the register "StartDistance".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_526"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_526" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_526")))
#endif

uint32_t FREG_TSD23_GetStartDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_STARTDISTANCE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts3StartDistance" of register "StartDistance".
**
** Distance between Sync Bytes for the input channel 1.
**  If TS3_AM_SYNC is 1, this value must be configured correctly. START_DISTANCE = packet-length - 1 (e.g. 187 or 203)
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts3StartDistance" consists of the bits 19..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x000FF000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_527"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_527" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_527")))
#endif

uint32_t FREG_TSD23_GetStartDistance_Ts3StartDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_STARTDISTANCE));
    value = ( value & 0x000FF000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Ts2StartDistance" of register "StartDistance".
**
** Distance between Sync Bytes for the input channel 0.
**  If TS2_AM_SYNC is 1, this value must be configured correctly. START_DISTANCE = packet-length - 1 (e.g. 187 or 203)
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Ts2StartDistance" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_528"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_528" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_528")))
#endif

uint32_t FREG_TSD23_GetStartDistance_Ts2StartDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_STARTDISTANCE));
    value = ( value & 0x000000FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "ReadSignalDistance".
**
** This function writes the given value to the register "ReadSignalDistance".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_529"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_529" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_529")))
#endif

void FREG_TSD23_SetReadSignalDistance( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_READSIGNALDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_READSIGNALDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "RdSignalDistance" of register "ReadSignalDistance".
**
** The clock frequency of PID filter is much higher than that of TS packet input buffer.
**  This register specifies the number of clock cycles between two read requests sent to TS packet input buffer by PID filter. Minmum: 5 (Default: 5).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "RdSignalDistance" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_530"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_530" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_530")))
#endif

void FREG_TSD23_SetReadSignalDistance_RdSignalDistance( uint32_t value )
{
    register uint32_t mask = 0x000000FFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_READSIGNALDISTANCE)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_READSIGNALDISTANCE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_READSIGNALDISTANCE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "ReadSignalDistance".
**
** This function reads the value from the register "ReadSignalDistance".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_531"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_531" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_531")))
#endif

uint32_t FREG_TSD23_GetReadSignalDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_READSIGNALDISTANCE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "RdSignalDistance" of register "ReadSignalDistance".
**
** The clock frequency of PID filter is much higher than that of TS packet input buffer.
**  This register specifies the number of clock cycles between two read requests sent to TS packet input buffer by PID filter. Minmum: 5 (Default: 5).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "RdSignalDistance" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_532"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_532" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_532")))
#endif

uint32_t FREG_TSD23_GetReadSignalDistance_RdSignalDistance( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_READSIGNALDISTANCE));
    value = ( value & 0x000000FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "InputTimeout".
**
** This function writes the given value to the register "InputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two input packets. If no packet is received during INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated.  The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s).
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_533"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_533" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_533")))
#endif

void FREG_TSD23_SetInputTimeout( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTTIMEOUT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTTIMEOUT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InputTimeout" of register "InputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two input packets. If no packet is received during INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated.  The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InputTimeout" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_534"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_534" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_534")))
#endif

void FREG_TSD23_SetInputTimeout_InputTimeout( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INPUTTIMEOUT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INPUTTIMEOUT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INPUTTIMEOUT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "InputTimeout".
**
** This function reads the value from the register "InputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two input packets. If no packet is received during INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated.  The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s).
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_535"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_535" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_535")))
#endif

uint32_t FREG_TSD23_GetInputTimeout( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTTIMEOUT));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InputTimeout" of register "InputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two input packets. If no packet is received during INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated.  The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "InputTimeout" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_536"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_536" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_536")))
#endif

uint32_t FREG_TSD23_GetInputTimeout_InputTimeout( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INPUTTIMEOUT));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PacketCounter".
**
** This function writes the given value to the register "PacketCounter".
**
** Number of packets received.
**  Packets containing less than or more than 188 bytes are discarded in input buffer and not included in this value.
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_537"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_537" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_537")))
#endif

void FREG_TSD23_SetPacketCounter( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PACKETCOUNTER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PACKETCOUNTER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketCnt" of register "PacketCounter".
**
** Number of packets received.
**  Packets containing less than or more than 188 bytes are discarded in input buffer and not included in this value.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketCnt" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_538"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_538" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_538")))
#endif

void FREG_TSD23_SetPacketCounter_PacketCnt( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_PACKETCOUNTER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PACKETCOUNTER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PACKETCOUNTER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketCounter".
**
** This function reads the value from the register "PacketCounter".
**
** Number of packets received.
**  Packets containing less than or more than 188 bytes are discarded in input buffer and not included in this value.
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_539"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_539" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_539")))
#endif

uint32_t FREG_TSD23_GetPacketCounter( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PACKETCOUNTER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketCnt" of register "PacketCounter".
**
** Number of packets received.
**  Packets containing less than or more than 188 bytes are discarded in input buffer and not included in this value.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketCnt" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_540"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_540" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_540")))
#endif

uint32_t FREG_TSD23_GetPacketCounter_PacketCnt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PACKETCOUNTER));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "ValidInputTimeout".
**
** This function writes the given value to the register "ValidInputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two valid  input packets. If no valid packet is received during VALID_INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. A packet is 'valid', if its PID is configured, the corresponding STI is activated, and no CC error or syntax error is detected in this packet.  The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s). "
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_541"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_541" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_541")))
#endif

void FREG_TSD23_SetValidInputTimeout( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_VALIDINPUTTIMEOUT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_VALIDINPUTTIMEOUT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ValidInputTimeout" of register "ValidInputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two valid  input packets. If no valid packet is received during VALID_INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. A packet is 'valid', if its PID is configured, the corresponding STI is activated, and no CC error or syntax error is detected in this packet.  The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s). "
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ValidInputTimeout" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_542"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_542" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_542")))
#endif

void FREG_TSD23_SetValidInputTimeout_ValidInputTimeout( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_VALIDINPUTTIMEOUT)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_VALIDINPUTTIMEOUT, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_VALIDINPUTTIMEOUT)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "ValidInputTimeout".
**
** This function reads the value from the register "ValidInputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two valid  input packets. If no valid packet is received during VALID_INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. A packet is 'valid', if its PID is configured, the corresponding STI is activated, and no CC error or syntax error is detected in this packet.  The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s). "
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_543"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_543" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_543")))
#endif

uint32_t FREG_TSD23_GetValidInputTimeout( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_VALIDINPUTTIMEOUT));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ValidInputTimeout" of register "ValidInputTimeout".
**
** The max.
**  time gap (unit: clock cycle \@ 162MHz, i.e. one unit is 1/162MHz = 6,1728ns) between two valid  input packets. If no valid packet is received during VALID_INPUT_TIMEOUT+1 clock cycles, an interrupt will be generated. A packet is 'valid', if its PID is configured, the corresponding STI is activated, and no CC error or syntax error is detected in this packet.  The default value 0xFFFFFFFF corresponds 2^32/162MHz (approximately  26.512438s). "
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "ValidInputTimeout" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_544"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_544" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_544")))
#endif

uint32_t FREG_TSD23_GetValidInputTimeout_ValidInputTimeout( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_VALIDINPUTTIMEOUT));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "ValidPacketCounter".
**
** This function writes the given value to the register "ValidPacketCounter".
**
** Number of valid packets received.
**  VALID_PACKET_CNT = PACKET_CNT - (number of packets with adaptation field control = 00) - (number of removed duplicate packet) - (number of packet with unconfigured PID) - (number of packet with configured but deactivated PID).
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_545"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_545" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_545")))
#endif

void FREG_TSD23_SetValidPacketCounter( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_VALIDPACKETCOUNTER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_VALIDPACKETCOUNTER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ValidPacketCnt" of register "ValidPacketCounter".
**
** Number of valid packets received.
**  VALID_PACKET_CNT = PACKET_CNT - (number of packets with adaptation field control = 00) - (number of removed duplicate packet) - (number of packet with unconfigured PID) - (number of packet with configured but deactivated PID).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ValidPacketCnt" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_546"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_546" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_546")))
#endif

void FREG_TSD23_SetValidPacketCounter_ValidPacketCnt( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_VALIDPACKETCOUNTER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_VALIDPACKETCOUNTER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_VALIDPACKETCOUNTER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "ValidPacketCounter".
**
** This function reads the value from the register "ValidPacketCounter".
**
** Number of valid packets received.
**  VALID_PACKET_CNT = PACKET_CNT - (number of packets with adaptation field control = 00) - (number of removed duplicate packet) - (number of packet with unconfigured PID) - (number of packet with configured but deactivated PID).
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_547"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_547" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_547")))
#endif

uint32_t FREG_TSD23_GetValidPacketCounter( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_VALIDPACKETCOUNTER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ValidPacketCnt" of register "ValidPacketCounter".
**
** Number of valid packets received.
**  VALID_PACKET_CNT = PACKET_CNT - (number of packets with adaptation field control = 00) - (number of removed duplicate packet) - (number of packet with unconfigured PID) - (number of packet with configured but deactivated PID).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "ValidPacketCnt" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_548"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_548" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_548")))
#endif

uint32_t FREG_TSD23_GetValidPacketCounter_ValidPacketCnt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_VALIDPACKETCOUNTER));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketStc".
**
** This function reads the value from the register "PacketStc".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_549"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_549" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_549")))
#endif

uint32_t FREG_TSD23_GetPacketStc( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PACKETSTC));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketStcBase" of register "PacketStc".
**
** The lower 23 bits of STC base which was sampled as the packet was received.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketStcBase" consists of the bits 31..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0xFFFFFE00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_550"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_550" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_550")))
#endif

uint32_t FREG_TSD23_GetPacketStc_PacketStcBase( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PACKETSTC));
    value = ( value & 0xFFFFFE00UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketStcExt" of register "PacketStc".
**
** The STC extension which was sampled as the packet was received.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketStcExt" consists of the bits 8..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000001FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_551"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_551" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_551")))
#endif

uint32_t FREG_TSD23_GetPacketStc_PacketStcExt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PACKETSTC));
    value = ( value & 0x000001FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "CurrentStcLower".
**
** This function writes the given value to the register "CurrentStcLower".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_552"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_552" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_552")))
#endif

void FREG_TSD23_SetCurrentStcLower( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_CURRENTSTCLOWER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCLOWER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CurrentStcBaseLower" of register "CurrentStcLower".
**
** The lower 23 bits of current STC base.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CurrentStcBaseLower" consists of the bits 31..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0xFFFFFE00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_553"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_553" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_553")))
#endif

void FREG_TSD23_SetCurrentStcLower_CurrentStcBaseLower( uint32_t value )
{
    register uint32_t mask = 0xFFFFFE00UL;
    value = ( value << 9 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCLOWER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_CURRENTSTCLOWER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCLOWER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CurrentStcExt" of register "CurrentStcLower".
**
** The current STC extension.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CurrentStcExt" consists of the bits 8..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000001FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_554"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_554" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_554")))
#endif

void FREG_TSD23_SetCurrentStcLower_CurrentStcExt( uint32_t value )
{
    register uint32_t mask = 0x000001FFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 2
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCLOWER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_CURRENTSTCLOWER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCLOWER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "CurrentStcLower".
**
** This function reads the value from the register "CurrentStcLower".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_555"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_555" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_555")))
#endif

uint32_t FREG_TSD23_GetCurrentStcLower( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCLOWER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CurrentStcBaseLower" of register "CurrentStcLower".
**
** The lower 23 bits of current STC base.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "CurrentStcBaseLower" consists of the bits 31..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0xFFFFFE00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_556"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_556" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_556")))
#endif

uint32_t FREG_TSD23_GetCurrentStcLower_CurrentStcBaseLower( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCLOWER));
    value = ( value & 0xFFFFFE00UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CurrentStcExt" of register "CurrentStcLower".
**
** The current STC extension.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "CurrentStcExt" consists of the bits 8..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000001FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_557"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_557" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_557")))
#endif

uint32_t FREG_TSD23_GetCurrentStcLower_CurrentStcExt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCLOWER));
    value = ( value & 0x000001FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "CurrentStcUpper".
**
** This function writes the given value to the register "CurrentStcUpper".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_558"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_558" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_558")))
#endif

void FREG_TSD23_SetCurrentStcUpper( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_CURRENTSTCUPPER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCUPPER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CurrentStcBaseUpper" of register "CurrentStcUpper".
**
** The upper 10 bits of current STC base.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CurrentStcBaseUpper" consists of the bits 9..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000003FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_559"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_559" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_559")))
#endif

void FREG_TSD23_SetCurrentStcUpper_CurrentStcBaseUpper( uint32_t value )
{
    register uint32_t mask = 0x000003FFUL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCUPPER)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_CURRENTSTCUPPER, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCUPPER)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "CurrentStcUpper".
**
** This function reads the value from the register "CurrentStcUpper".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_560"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_560" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_560")))
#endif

uint32_t FREG_TSD23_GetCurrentStcUpper( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCUPPER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CurrentStcBaseUpper" of register "CurrentStcUpper".
**
** The upper 10 bits of current STC base.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "CurrentStcBaseUpper" consists of the bits 9..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000003FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_561"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_561" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_561")))
#endif

uint32_t FREG_TSD23_GetCurrentStcUpper_CurrentStcBaseUpper( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_CURRENTSTCUPPER));
    value = ( value & 0x000003FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PcrLower".
**
** This function reads the value from the register "PcrLower".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_562"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_562" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_562")))
#endif

uint32_t FREG_TSD23_GetPcrLower( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PCRLOWER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PcrBaseLower" of register "PcrLower".
**
** The lower 23 bits of PCR base found in the packet.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PcrBaseLower" consists of the bits 31..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0xFFFFFE00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_563"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_563" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_563")))
#endif

uint32_t FREG_TSD23_GetPcrLower_PcrBaseLower( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PCRLOWER));
    value = ( value & 0xFFFFFE00UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PcrExt" of register "PcrLower".
**
** The PCR extension found in the packet
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PcrExt" consists of the bits 8..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000001FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_564"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_564" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_564")))
#endif

uint32_t FREG_TSD23_GetPcrLower_PcrExt( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PCRLOWER));
    value = ( value & 0x000001FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PcrUpper".
**
** This function reads the value from the register "PcrUpper".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_565"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_565" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_565")))
#endif

uint32_t FREG_TSD23_GetPcrUpper( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PCRUPPER));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PcrBaseUpper" of register "PcrUpper".
**
** The upper 10 bits of PCR base.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PcrBaseUpper" consists of the bits 9..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000003FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_566"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_566" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_566")))
#endif

uint32_t FREG_TSD23_GetPcrUpper_PcrBaseUpper( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PCRUPPER));
    value = ( value & 0x000003FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LoadPcr".
**
** This function writes the given value to the register "LoadPcr".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_567"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_567" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_567")))
#endif

void FREG_TSD23_SetLoadPcr( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_LOADPCR, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_LOADPCR)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "LoadPcrFlag" of register "LoadPcr".
**
** Indicates if next PCR should be loaded or not:
** - '1': Load the next PCR extracted after this bit is set to 1 to the two CURRENT_STC registers.
**  After the data is loaded, this bit will be automatically cleared.
** - '0': Don't load.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "LoadPcrFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_568"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_568" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_568")))
#endif

void FREG_TSD23_SetLoadPcr_LoadPcrFlag( uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_LOADPCR)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_LOADPCR, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_LOADPCR)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LoadPcr".
**
** This function reads the value from the register "LoadPcr".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_569"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_569" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_569")))
#endif

uint32_t FREG_TSD23_GetLoadPcr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_LOADPCR));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "LoadPcrFlag" of register "LoadPcr".
**
** Indicates if next PCR should be loaded or not:
** - '1': Load the next PCR extracted after this bit is set to 1 to the two CURRENT_STC registers.
**  After the data is loaded, this bit will be automatically cleared.
** - '0': Don't load.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "LoadPcrFlag" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_570"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_570" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_570")))
#endif

uint32_t FREG_TSD23_GetLoadPcr_LoadPcrFlag( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_LOADPCR));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Status".
**
** This function reads the value from the register "Status".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_571"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_571" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_571")))
#endif

uint32_t FREG_TSD23_GetStatus( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_STATUS));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TsdActive" of register "Status".
**
** This bit indicates if any packet is being processed by TSD2 or TSD3.
**
** - '1':YES
** - '0':NO.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "TsdActive" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_572"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_572" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_572")))
#endif

uint32_t FREG_TSD23_GetStatus_TsdActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_STATUS));
    value = ( value & 0x00000400UL ) >> 10;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidMatchValid" of register "Status".
**
** This bit indicates if the PID_MATCH bit in this register  is valid or not.
**
** - '1': valid
** - '0': invalid
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidMatchValid" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_573"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_573" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_573")))
#endif

uint32_t FREG_TSD23_GetStatus_PidMatchValid( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_STATUS));
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidMatch" of register "Status".
**
** If PID_MATCH_VALID bit is '1', PID_MATCH indicates if the PID of the incoming packet matches any PID configured ('1': match.
**  '0': doesn't match).
** If PID_MATCH_VALID bit is '0', PID_MATCH is always set to '0'.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidMatch" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_574"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_574" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_574")))
#endif

uint32_t FREG_TSD23_GetStatus_PidMatch( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_STATUS));
    value = ( value & 0x00000100UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd3Select" of register "Status".
**
** The register TSD_STATUS is shared by TSD2 and TSD3.
**  This bit indicates which TSD is currently active and to which TSD the following PID_INDEX belongs to.
** - '0': the active PID channel is in TSD2.
** - '1': the active PID channel is in TSD3.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd3Select" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_575"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_575" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_575")))
#endif

uint32_t FREG_TSD23_GetStatus_Tsd3Select( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_STATUS));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidIndex" of register "Status".
**
** The PID_index ranges from 0 to 31.
**  If TSD_ACTIVE is '1', PID_INDEX indicates which PID is under processing.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_576"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_576" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_576")))
#endif

uint32_t FREG_TSD23_GetStatus_PidIndex( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_STATUS));
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PesCfg".
**
** This function writes the given value to the index-th entry of the register
** array PesCfg.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_577"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_577" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_577")))
#endif

void FREG_TSD23_SetPesCfg( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Tsd3Select" of register "PesCfg".
**
** TSD3 select signal.
**  This bit indicates in which TSD (TSD2 or TSD3) the PID channel specified by PID_INDEX below is configured.
** - '0' : TSD2 is selected.
** - '1' : TSD3 is selected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Tsd3Select" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_578"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_578" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_578")))
#endif

void FREG_TSD23_SetPesCfg_Tsd3Select( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000200UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 9 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidIndex" of register "PesCfg".
**
** The PID channel index.
**  These 5 bits defines which PID channel shall be processed by this PES parser. The bit TSD3_SELECT above indicates in which TSD (TSD2 or TSD3) the PID channel is configured.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidIndex" consists of the bits 8..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x000001F0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_579"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_579" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_579")))
#endif

void FREG_TSD23_SetPesCfg_PidIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000001F0UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "RemovePesHeader" of register "PesCfg".
**
** Remove PES packet header
** - '0' : don't remove the header.
**
** - '1' : remove the header.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "RemovePesHeader" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_580"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_580" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_580")))
#endif

void FREG_TSD23_SetPesCfg_RemovePesHeader( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000004UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 2 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NewPtsIrqEn" of register "PesCfg".
**
** NEW_PTS_IRQ enable
** - '0' : disable
** - '1' : enable
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NewPtsIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_581"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_581" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_581")))
#endif

void FREG_TSD23_SetPesCfg_NewPtsIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PesEn" of register "PesCfg".
**
** PES_PARSER enable
** - '0' : disable
** - '1' : enable
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PesEn" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_582"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_582" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_582")))
#endif

void FREG_TSD23_SetPesCfg_PesEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 5
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PESCFG+(index*0xC), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PesCfg".
**
** This function reads the value from the index-th entry of the register
** array PesCfg.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_583"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_583" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_583")))
#endif

uint32_t FREG_TSD23_GetPesCfg( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd3Select" of register "PesCfg".
**
** TSD3 select signal.
**  This bit indicates in which TSD (TSD2 or TSD3) the PID channel specified by PID_INDEX below is configured.
** - '0' : TSD2 is selected.
** - '1' : TSD3 is selected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd3Select" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_584"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_584" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_584")))
#endif

uint32_t FREG_TSD23_GetPesCfg_Tsd3Select( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC)));
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidIndex" of register "PesCfg".
**
** The PID channel index.
**  These 5 bits defines which PID channel shall be processed by this PES parser. The bit TSD3_SELECT above indicates in which TSD (TSD2 or TSD3) the PID channel is configured.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidIndex" consists of the bits 8..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x000001F0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_585"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_585" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_585")))
#endif

uint32_t FREG_TSD23_GetPesCfg_PidIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC)));
    value = ( value & 0x000001F0UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "RemovePesHeader" of register "PesCfg".
**
** Remove PES packet header
** - '0' : don't remove the header.
**
** - '1' : remove the header.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "RemovePesHeader" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_586"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_586" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_586")))
#endif

uint32_t FREG_TSD23_GetPesCfg_RemovePesHeader( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC)));
    value = ( value & 0x00000004UL ) >> 2;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NewPtsIrqEn" of register "PesCfg".
**
** NEW_PTS_IRQ enable
** - '0' : disable
** - '1' : enable
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NewPtsIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_587"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_587" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_587")))
#endif

uint32_t FREG_TSD23_GetPesCfg_NewPtsIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC)));
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PesEn" of register "PesCfg".
**
** PES_PARSER enable
** - '0' : disable
** - '1' : enable
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PesEn" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_588"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_588" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_588")))
#endif

uint32_t FREG_TSD23_GetPesCfg_PesEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PESCFG+(index*0xC)));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Pts_0".
**
** This function reads the value from the index-th entry of the register
** array Pts_0.
**
** The 32 LSBs of PTS value.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_589"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_589" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_589")))
#endif

uint32_t FREG_TSD23_GetPts_0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PTS_0+(index*0xC)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PtsLower" of register "Pts_0".
**
** The 32 LSBs of PTS value.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PtsLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_590"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_590" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_590")))
#endif

uint32_t FREG_TSD23_GetPts_0_PtsLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PTS_0+(index*0xC)));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Pts_1".
**
** This function reads the value from the index-th entry of the register
** array Pts_1.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_591"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_591" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_591")))
#endif

uint32_t FREG_TSD23_GetPts_1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PTS_1+(index*0xC)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PtsMsb" of register "Pts_1".
**
** The MSB of PTS value (bit 32).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PtsMsb" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_592"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_592" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_592")))
#endif

uint32_t FREG_TSD23_GetPts_1_PtsMsb( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 4 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_PTS_1+(index*0xC)));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PacketStcMode".
**
** This function writes the given value to the register "PacketStcMode".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_593"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_593" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_593")))
#endif

void FREG_TSD23_SetPacketStcMode( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PACKETSTCMODE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PACKETSTCMODE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "StoreAllPacketStc" of register "PacketStcMode".
**
** Specifies when the register PACKET_STC shall be updated:
** - '0' : update the register PACKET_STC only for packets with PCR field.
**
** - '1' : update the register PACKET_STC for all packets.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "StoreAllPacketStc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_594"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_594" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_594")))
#endif

void FREG_TSD23_SetPacketStcMode_StoreAllPacketStc( uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_PACKETSTCMODE)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_PACKETSTCMODE, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_PACKETSTCMODE)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketStcMode".
**
** This function reads the value from the register "PacketStcMode".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_595"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_595" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_595")))
#endif

uint32_t FREG_TSD23_GetPacketStcMode( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PACKETSTCMODE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "StoreAllPacketStc" of register "PacketStcMode".
**
** Specifies when the register PACKET_STC shall be updated:
** - '0' : update the register PACKET_STC only for packets with PCR field.
**
** - '1' : update the register PACKET_STC for all packets.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "StoreAllPacketStc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_596"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_596" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_596")))
#endif

uint32_t FREG_TSD23_GetPacketStcMode_StoreAllPacketStc( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_PACKETSTCMODE));
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidValue".
**
** This function writes the given value to the index-th entry of the register
** array PidValue.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_597"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_597" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_597")))
#endif

void FREG_TSD2_SetPidValue( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return;
    #endif
    FREG_TSD2_PidValueMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDVALUE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDVALUE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidBit" of register "PidValue".
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidBit" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_598"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_598" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_598")))
#endif

void FREG_TSD2_SetPidValue_PidBit( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_PidValueMirror[index] & ~mask;
    FREG_TSD2_PidValueMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDVALUE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDVALUE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidValue".
**
** This function reads the value from the index-th entry of the register
** array PidValue.
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_599"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_599" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_599")))
#endif

uint32_t FREG_TSD2_GetmPidValue( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidValueMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidBit" of register "PidValue".
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidBit" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_600"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_600" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_600")))
#endif

uint32_t FREG_TSD2_GetmPidValue_PidBit( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 13 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidValueMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidConfig_1".
**
** This function writes the given value to the index-th entry of the register
** array PidConfig_1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_601"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_601" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_601")))
#endif

void FREG_TSD2_SetPidConfig_1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    FREG_TSD2_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DuplicateIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for duplicate packet IRQ.
**  If the bit DUPLICATE_CHECK in TS1_PID_config_2 is set to 1, duplicate packets will be removed. If the bit DUPLICATE_IRQ_EN is also set to 1, a DUPLICATE_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DuplicateIrqEn" consists of the bits 16..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00010000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_602"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_602" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_602")))
#endif

void FREG_TSD2_SetPidConfig_1_DuplicateIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00010000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD2_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "BufferIndex" of register "PidConfig_1".
**
** If the OFFSET_MODE (bit 7 of this register, see below) is set to '0', BUFFER_INDEX specifies to which buffer the data of this PID channel shall be stored.
**  If data from multiple PID channels shall be stored in the same buffer, these PID channels' BUFFER_INDEX shall be set to the same value.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "BufferIndex" consists of the bits 12..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00001F00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_603"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_603" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_603")))
#endif

void FREG_TSD2_SetPidConfig_1_BufferIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00001F00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD2_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OffsetMode" of register "PidConfig_1".
**
** This bit is ONLY active for PSI packets.
**
** - '1': the section data of this PID channel will be stored
** to the buffer with the index K, where k =
** BUFFER_INDEX + offset. Here offset = (matched
** filter target index). If more than one filter targets
** match the incoming section, the lowest target index
** will be used as offset.
** - '0':  the section data will be stored to buffer specified with
** BUFFER_INDEX.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OffsetMode" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_604"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_604" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_604")))
#endif

void FREG_TSD2_SetPidConfig_1_OffsetMode( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD2_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pcr1AfLt7IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** PCR flag is 1 (PCR_1), but adaptation field length is less than 7 (AF_LT_7).
**  In this case, no PCR will be extracted even if the bit EXTRACT_PCR is set to 1. The adapation field will be handeled as if the PCR flag is 0.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pcr1AfLt7IrqEn" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_605"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_605" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_605")))
#endif

void FREG_TSD2_SetPidConfig_1_Pcr1AfLt7IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000040UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    value |= FREG_TSD2_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pl1AfGt183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field byte number is greater than 183 (AF_GT183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pl1AfGt183IrqEn" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_606"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_606" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_606")))
#endif

void FREG_TSD2_SetPidConfig_1_Pl1AfGt183IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    value |= FREG_TSD2_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pl0AfNe183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field length is not equal 183 (AF_NE183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pl0AfNe183IrqEn" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_607"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_607" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_607")))
#endif

void FREG_TSD2_SetPidConfig_1_Pl0AfNe183IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    value |= FREG_TSD2_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NullPacketIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for NULL packet IRQ.
**  Null packets (both of the adapation field flag and payload flag in packet header are 0) are alway removed. If this bit is set to 1, a NULL_PACKET_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NullPacketIrqEn" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_608"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_608" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_608")))
#endif

void FREG_TSD2_SetPidConfig_1_NullPacketIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 3 ) & mask;
    value |= FREG_TSD2_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DescramblerIndex" of register "PidConfig_1".
**
** Ranges from 0 to 7.
**  Indicates which one of the 8 descramlbers shall be used to descramble this PID channel. The descramble keys are definded through the register DSC_ODD_KEY_UPPER, DSC_ODD_KEY_LOWER, DSC_EVEN_KEY_UPPER and DSC_EVEN_KEY_LOWER. The odd/even flag of scrambling control field in the TS packet header decides if the odd or the even key of the corresponding descrambler is used to descramble the actual TS-packet.
**
** To activate the selected descrambler, the bit BYPASS_DSC in the register PID_CONFIG_2 must be set to 0.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DescramblerIndex" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_609"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_609" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_609")))
#endif

void FREG_TSD2_SetPidConfig_1_DescramblerIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000007UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidConfig_1".
**
** This function reads the value from the index-th entry of the register
** array PidConfig_1.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_610"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_610" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_610")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DuplicateIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for duplicate packet IRQ.
**  If the bit DUPLICATE_CHECK in TS1_PID_config_2 is set to 1, duplicate packets will be removed. If the bit DUPLICATE_IRQ_EN is also set to 1, a DUPLICATE_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DuplicateIrqEn" consists of the bits 16..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00010000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_611"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_611" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_611")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_1_DuplicateIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_1Mirror[index];
    value = ( value & 0x00010000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "BufferIndex" of register "PidConfig_1".
**
** If the OFFSET_MODE (bit 7 of this register, see below) is set to '0', BUFFER_INDEX specifies to which buffer the data of this PID channel shall be stored.
**  If data from multiple PID channels shall be stored in the same buffer, these PID channels' BUFFER_INDEX shall be set to the same value.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "BufferIndex" consists of the bits 12..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00001F00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_612"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_612" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_612")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_1_BufferIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_1Mirror[index];
    value = ( value & 0x00001F00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OffsetMode" of register "PidConfig_1".
**
** This bit is ONLY active for PSI packets.
**
** - '1': the section data of this PID channel will be stored
** to the buffer with the index K, where k =
** BUFFER_INDEX + offset. Here offset = (matched
** filter target index). If more than one filter targets
** match the incoming section, the lowest target index
** will be used as offset.
** - '0':  the section data will be stored to buffer specified with
** BUFFER_INDEX.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OffsetMode" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_613"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_613" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_613")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_1_OffsetMode( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_1Mirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pcr1AfLt7IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** PCR flag is 1 (PCR_1), but adaptation field length is less than 7 (AF_LT_7).
**  In this case, no PCR will be extracted even if the bit EXTRACT_PCR is set to 1. The adapation field will be handeled as if the PCR flag is 0.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pcr1AfLt7IrqEn" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_614"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_614" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_614")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_1_Pcr1AfLt7IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_1Mirror[index];
    value = ( value & 0x00000040UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pl1AfGt183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field byte number is greater than 183 (AF_GT183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pl1AfGt183IrqEn" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_615"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_615" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_615")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_1_Pl1AfGt183IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_1Mirror[index];
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pl0AfNe183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field length is not equal 183 (AF_NE183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pl0AfNe183IrqEn" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_616"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_616" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_616")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_1_Pl0AfNe183IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_1Mirror[index];
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NullPacketIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for NULL packet IRQ.
**  Null packets (both of the adapation field flag and payload flag in packet header are 0) are alway removed. If this bit is set to 1, a NULL_PACKET_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NullPacketIrqEn" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_617"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_617" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_617")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_1_NullPacketIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_1Mirror[index];
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DescramblerIndex" of register "PidConfig_1".
**
** Ranges from 0 to 7.
**  Indicates which one of the 8 descramlbers shall be used to descramble this PID channel. The descramble keys are definded through the register DSC_ODD_KEY_UPPER, DSC_ODD_KEY_LOWER, DSC_EVEN_KEY_UPPER and DSC_EVEN_KEY_LOWER. The odd/even flag of scrambling control field in the TS packet header decides if the odd or the even key of the corresponding descrambler is used to descramble the actual TS-packet.
**
** To activate the selected descrambler, the bit BYPASS_DSC in the register PID_CONFIG_2 must be set to 0.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DescramblerIndex" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_618"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_618" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_618")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_1_DescramblerIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_1Mirror[index];
    value = ( value & 0x00000007UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidConfig_2".
**
** This function writes the given value to the index-th entry of the register
** array PidConfig_2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_619"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_619" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_619")))
#endif

void FREG_TSD2_SetPidConfig_2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PtrTarget" of register "PidConfig_2".
**
** Pointer to the first target in SF_target_RAM.
**
** PTR_TARGET ranges from 0 through127. This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0.
**
** For example, if the first target is stored in line 25 of SF_target_RAM, then PTR_TARGET shall be set to 25.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PtrTarget" consists of the bits 31..25,
**       the given bitgroup value will be shifted left by 25 bits and
**       masked using the bitmask 0xFE000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_620"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_620" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_620")))
#endif

void FREG_TSD2_SetPidConfig_2_PtrTarget( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFE000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 25 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NTarget" of register "PidConfig_2".
**
** Number of filter target.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. Let the number of target be k. k is coded and stored to N_TARGET. Attention: N_TARGET is not binary-coded decimal format of k (see below)!! For example, if k = 4, N_TARGET is '1000' (decimal 8) not '0100' (decimal 4).
** - k= 1: N_TARGET='0001'
** - k= 2: N_TARGET='0010'
** - k= 4: N_TARGET='1000'
** - k= 8: N_TARGET='1001'
** - k=12: N_TARGET='1010'
** - k=16: N_TARGET='1011'
** - k=20: N_TARGET='1100'
** - k=24: N_TARGET='1101'
** - k=28: N_TARGET='1110'
** - k=32: N_TARGET='1111'
** (Coding rules:
** N_TARGET[3] = 0 and N_TARGET[2:0] = k, if k<4.
** N_TARGET[3] = 1 and N_TARGET[2:0] = (k/4)-1, if k4.)
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NTarget" consists of the bits 24..21,
**       the given bitgroup value will be shifted left by 21 bits and
**       masked using the bitmask 0x01E00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_621"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_621" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_621")))
#endif

void FREG_TSD2_SetPidConfig_2_NTarget( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x01E00000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 21 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TargetLength" of register "PidConfig_2".
**
** Filter target length.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. All filter targets of a PID channel shall have the same length. TARGET_LENGTH ranges from 1 to 25 (including table ID byte, but excluding the two section length bytes).
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TargetLength" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_622"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_622" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_622")))
#endif

void FREG_TSD2_SetPidConfig_2_TargetLength( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x001F0000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "StoreCompletePacket" of register "PidConfig_2".
**
** Indicate if TS packets header (4 bytes) and adaptation field shall be stored.
**
** - '0': Only payload shall be stored (packet header and adaptation field shall be removed).
** - '1': The complete packet (packet header, adaptation field and payload) shall be stored.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "StoreCompletePacket" consists of the bits 15..15,
**       the given bitgroup value will be shifted left by 15 bits and
**       masked using the bitmask 0x00008000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_623"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_623" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_623")))
#endif

void FREG_TSD2_SetPidConfig_2_StoreCompletePacket( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00008000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 15 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PusIrqEn" of register "PidConfig_2".
**
** Payload Unit Start (PUS) interrupt enable:
** - '0': disabled.
**
** - '1': enabled.
** If the Payload Unit Start Indicator of a transport stream packet is '1' and PUS_IRQ_EN is '1' then a PUS_IRQ will be triggered.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PusIrqEn" consists of the bits 14..14,
**       the given bitgroup value will be shifted left by 14 bits and
**       masked using the bitmask 0x00004000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_624"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_624" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_624")))
#endif

void FREG_TSD2_SetPidConfig_2_PusIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00004000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 14 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no packet is received during a certain time (defined in the register INPUT_TIMEOUT), an INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InputTimeoutIrqEn" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_625"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_625" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_625")))
#endif

void FREG_TSD2_SetPidConfig_2_InputTimeoutIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00002000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 13 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ValidInputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no valid packet is received during a certain time (defined the in register VALID_INPUT_TIMEOUT), an VALID_INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ValidInputTimeoutIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_626"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_626" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_626")))
#endif

void FREG_TSD2_SetPidConfig_2_ValidInputTimeoutIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00001000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 12 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NewPcrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for NEW_PCR_IRQ.
**  If a  new PCR is extracted, a NEW_PCR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NewPcrIrqEn" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_627"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_627" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_627")))
#endif

void FREG_TSD2_SetPidConfig_2_NewPcrIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000800UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 11 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CcIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CONTINUITY_COUNTER_ERROR_IRQ.
**  If CC_CHECK is set and a continuity counter error is found,  a CONTINUITY_COUNTER_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CcIrqEn" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_628"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_628" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_628")))
#endif

void FREG_TSD2_SetPidConfig_2_CcIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000400UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 10 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SectionEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for SECTION_END_IRQ.
**  If an incoming section matches at least one filter target and its end is detected, a SECTION_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SectionEndIrqEn" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_629"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_629" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_629")))
#endif

void FREG_TSD2_SetPidConfig_2_SectionEndIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000200UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 9 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PACKET_END_IRQ.
**  If the PID of an incoming packet matches the PID of this channel and all bytes in this packet was sent to Buffer Mangager, a PACKET_END_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt..
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketEndIrqEn" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_630"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_630" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_630")))
#endif

void FREG_TSD2_SetPidConfig_2_PacketEndIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000100UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ScrambledPacketIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for scrambled transport packet.
**  If the scrambling controll flag in TS packet header is set to 1, a SCRAMBLED_PACKET_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ScrambledPacketIrqEn" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_631"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_631" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_631")))
#endif

void FREG_TSD2_SetPidConfig_2_ScrambledPacketIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CcCheck" of register "PidConfig_2".
**
** Continuity Counter error  check.
**  If a TS packet has payload, its continuity counter shall be incremented by 1 or equals to that of the previous packet. If a TS packet has only adaptation field, its continuity counter shall not be incremented. If any of the conditions is not filled, the TS packet will be discarded and the corresponding PID channel will be disabled.
** - '0': don't check.
** - '1': if CC error detected, discard the packet and disable the corresponding PID channel will be deactivated.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CcCheck" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_632"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_632" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_632")))
#endif

void FREG_TSD2_SetPidConfig_2_CcCheck( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000040UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DuplicateCheck" of register "PidConfig_2".
**
** Duplicate packet check.
**  If a TS packet has payload but its continuity counter is equal to that of the previous packet, then this packet is a duplicate packet. If this bit is set, such packets will be discarded.
** - '0': don't check.
** - '1': discard duplicate packet.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DuplicateCheck" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_633"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_633" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_633")))
#endif

void FREG_TSD2_SetPidConfig_2_DuplicateCheck( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PesPayload" of register "PidConfig_2".
**
** Specifies type of transport packet payload
** - '0': PSI payload (section data)
** - '1': PES payload (video, MPEG audio,
** teletext, closed caption)
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PesPayload" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_634"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_634" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_634")))
#endif

void FREG_TSD2_SetPidConfig_2_PesPayload( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ExtractPcr" of register "PidConfig_2".
**
** Enable the extraction of PCR field from adaptation field:
** - '0': PCR should be skipped
** - '1': PCR should be extracted.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ExtractPcr" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_635"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_635" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_635")))
#endif

void FREG_TSD2_SetPidConfig_2_ExtractPcr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 3 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PsiCcCheckMode" of register "PidConfig_2".
**
** Specify the Continuity Counter (CC) Check Mode for PSI packets (therefore ONLY active for PSI packets):
** - '1': always check continuity counter if CC_CHECK is
** enabled.
**
** - '0': only check continuity counter if check is enabled and section filter is active.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PsiCcCheckMode" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_636"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_636" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_636")))
#endif

void FREG_TSD2_SetPidConfig_2_PsiCcCheckMode( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000004UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 2 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CrcErrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CRC error.
**  If the syntax indicator in a section is set to 1 and the CRC  in this section is wrong, a CRC_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CrcErrIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_637"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_637" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_637")))
#endif

void FREG_TSD2_SetPidConfig_2_CrcErrIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "BypassDsc" of register "PidConfig_2".
**
** Bypass DVB descrambler.
**
** - '0': DVB descrambler not bypassed. Descramlbe key and the DESCRAMBLER_INDEX in CONFIG_1 must be programmed. If the scrambling control flag in the TS packet header is not set, the descrambler will not be activated even if this bit is set to 0. Therefore, this bit can be set to 0 in all default configuration and it shall be set to 1 only if descrambler must be deactivated.
** - '1': DVB descrambler is bypassed.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "BypassDsc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_638"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_638" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_638")))
#endif

void FREG_TSD2_SetPidConfig_2_BypassDsc( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD2_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidConfig_2".
**
** This function reads the value from the index-th entry of the register
** array PidConfig_2.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_639"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_639" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_639")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PtrTarget" of register "PidConfig_2".
**
** Pointer to the first target in SF_target_RAM.
**
** PTR_TARGET ranges from 0 through127. This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0.
**
** For example, if the first target is stored in line 25 of SF_target_RAM, then PTR_TARGET shall be set to 25.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PtrTarget" consists of the bits 31..25,
**       the given bitgroup value will be shifted left by 25 bits and
**       masked using the bitmask 0xFE000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_640"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_640" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_640")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_PtrTarget( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0xFE000000UL ) >> 25;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NTarget" of register "PidConfig_2".
**
** Number of filter target.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. Let the number of target be k. k is coded and stored to N_TARGET. Attention: N_TARGET is not binary-coded decimal format of k (see below)!! For example, if k = 4, N_TARGET is '1000' (decimal 8) not '0100' (decimal 4).
** - k= 1: N_TARGET='0001'
** - k= 2: N_TARGET='0010'
** - k= 4: N_TARGET='1000'
** - k= 8: N_TARGET='1001'
** - k=12: N_TARGET='1010'
** - k=16: N_TARGET='1011'
** - k=20: N_TARGET='1100'
** - k=24: N_TARGET='1101'
** - k=28: N_TARGET='1110'
** - k=32: N_TARGET='1111'
** (Coding rules:
** N_TARGET[3] = 0 and N_TARGET[2:0] = k, if k<4.
** N_TARGET[3] = 1 and N_TARGET[2:0] = (k/4)-1, if k4.)
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NTarget" consists of the bits 24..21,
**       the given bitgroup value will be shifted left by 21 bits and
**       masked using the bitmask 0x01E00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_641"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_641" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_641")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_NTarget( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x01E00000UL ) >> 21;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TargetLength" of register "PidConfig_2".
**
** Filter target length.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. All filter targets of a PID channel shall have the same length. TARGET_LENGTH ranges from 1 to 25 (including table ID byte, but excluding the two section length bytes).
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TargetLength" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_642"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_642" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_642")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_TargetLength( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x001F0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "StoreCompletePacket" of register "PidConfig_2".
**
** Indicate if TS packets header (4 bytes) and adaptation field shall be stored.
**
** - '0': Only payload shall be stored (packet header and adaptation field shall be removed).
** - '1': The complete packet (packet header, adaptation field and payload) shall be stored.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "StoreCompletePacket" consists of the bits 15..15,
**       the given bitgroup value will be shifted left by 15 bits and
**       masked using the bitmask 0x00008000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_643"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_643" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_643")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_StoreCompletePacket( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00008000UL ) >> 15;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PusIrqEn" of register "PidConfig_2".
**
** Payload Unit Start (PUS) interrupt enable:
** - '0': disabled.
**
** - '1': enabled.
** If the Payload Unit Start Indicator of a transport stream packet is '1' and PUS_IRQ_EN is '1' then a PUS_IRQ will be triggered.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PusIrqEn" consists of the bits 14..14,
**       the given bitgroup value will be shifted left by 14 bits and
**       masked using the bitmask 0x00004000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_644"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_644" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_644")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_PusIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00004000UL ) >> 14;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no packet is received during a certain time (defined in the register INPUT_TIMEOUT), an INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "InputTimeoutIrqEn" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_645"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_645" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_645")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_InputTimeoutIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00002000UL ) >> 13;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ValidInputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no valid packet is received during a certain time (defined the in register VALID_INPUT_TIMEOUT), an VALID_INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ValidInputTimeoutIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_646"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_646" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_646")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_ValidInputTimeoutIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00001000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NewPcrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for NEW_PCR_IRQ.
**  If a  new PCR is extracted, a NEW_PCR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NewPcrIrqEn" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_647"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_647" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_647")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_NewPcrIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000800UL ) >> 11;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CcIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CONTINUITY_COUNTER_ERROR_IRQ.
**  If CC_CHECK is set and a continuity counter error is found,  a CONTINUITY_COUNTER_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CcIrqEn" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_648"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_648" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_648")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_CcIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000400UL ) >> 10;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SectionEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for SECTION_END_IRQ.
**  If an incoming section matches at least one filter target and its end is detected, a SECTION_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SectionEndIrqEn" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_649"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_649" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_649")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_SectionEndIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PACKET_END_IRQ.
**  If the PID of an incoming packet matches the PID of this channel and all bytes in this packet was sent to Buffer Mangager, a PACKET_END_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt..
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketEndIrqEn" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_650"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_650" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_650")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_PacketEndIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000100UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ScrambledPacketIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for scrambled transport packet.
**  If the scrambling controll flag in TS packet header is set to 1, a SCRAMBLED_PACKET_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ScrambledPacketIrqEn" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_651"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_651" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_651")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_ScrambledPacketIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CcCheck" of register "PidConfig_2".
**
** Continuity Counter error  check.
**  If a TS packet has payload, its continuity counter shall be incremented by 1 or equals to that of the previous packet. If a TS packet has only adaptation field, its continuity counter shall not be incremented. If any of the conditions is not filled, the TS packet will be discarded and the corresponding PID channel will be disabled.
** - '0': don't check.
** - '1': if CC error detected, discard the packet and disable the corresponding PID channel will be deactivated.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CcCheck" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_652"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_652" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_652")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_CcCheck( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000040UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DuplicateCheck" of register "PidConfig_2".
**
** Duplicate packet check.
**  If a TS packet has payload but its continuity counter is equal to that of the previous packet, then this packet is a duplicate packet. If this bit is set, such packets will be discarded.
** - '0': don't check.
** - '1': discard duplicate packet.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DuplicateCheck" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_653"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_653" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_653")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_DuplicateCheck( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PesPayload" of register "PidConfig_2".
**
** Specifies type of transport packet payload
** - '0': PSI payload (section data)
** - '1': PES payload (video, MPEG audio,
** teletext, closed caption)
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PesPayload" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_654"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_654" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_654")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_PesPayload( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ExtractPcr" of register "PidConfig_2".
**
** Enable the extraction of PCR field from adaptation field:
** - '0': PCR should be skipped
** - '1': PCR should be extracted.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ExtractPcr" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_655"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_655" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_655")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_ExtractPcr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PsiCcCheckMode" of register "PidConfig_2".
**
** Specify the Continuity Counter (CC) Check Mode for PSI packets (therefore ONLY active for PSI packets):
** - '1': always check continuity counter if CC_CHECK is
** enabled.
**
** - '0': only check continuity counter if check is enabled and section filter is active.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PsiCcCheckMode" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_656"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_656" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_656")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_PsiCcCheckMode( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000004UL ) >> 2;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CrcErrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CRC error.
**  If the syntax indicator in a section is set to 1 and the CRC  in this section is wrong, a CRC_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CrcErrIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_657"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_657" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_657")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_CrcErrIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "BypassDsc" of register "PidConfig_2".
**
** Bypass DVB descrambler.
**
** - '0': DVB descrambler not bypassed. Descramlbe key and the DESCRAMBLER_INDEX in CONFIG_1 must be programmed. If the scrambling control flag in the TS packet header is not set, the descrambler will not be activated even if this bit is set to 0. Therefore, this bit can be set to 0 in all default configuration and it shall be set to 1 only if descrambler must be deactivated.
** - '1': DVB descrambler is bypassed.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "BypassDsc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_658"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_658" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_658")))
#endif

uint32_t FREG_TSD2_GetmPidConfig_2_BypassDsc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_PidConfig_2Mirror[index];
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscOddKeyUpper".
**
** This function writes the given value to the index-th entry of the register
** array DscOddKeyUpper.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_659"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_659" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_659")))
#endif

void FREG_TSD2_SetDscOddKeyUpper( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD2_DscOddKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_DSCODDKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_DSCODDKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OddKeyUpper" of register "DscOddKeyUpper".
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OddKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_660"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_660" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_660")))
#endif

void FREG_TSD2_SetDscOddKeyUpper_OddKeyUpper( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_DscOddKeyUpperMirror[index] & ~mask;
    FREG_TSD2_DscOddKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_DSCODDKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_DSCODDKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscOddKeyUpper".
**
** This function reads the value from the index-th entry of the register
** array DscOddKeyUpper.
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_661"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_661" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_661")))
#endif

uint32_t FREG_TSD2_GetmDscOddKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_DscOddKeyUpperMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OddKeyUpper" of register "DscOddKeyUpper".
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OddKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_662"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_662" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_662")))
#endif

uint32_t FREG_TSD2_GetmDscOddKeyUpper_OddKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_DscOddKeyUpperMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscOddKeyLower".
**
** This function writes the given value to the index-th entry of the register
** array DscOddKeyLower.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_663"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_663" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_663")))
#endif

void FREG_TSD2_SetDscOddKeyLower( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD2_DscOddKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_DSCODDKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_DSCODDKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OddKeyLower" of register "DscOddKeyLower".
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OddKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_664"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_664" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_664")))
#endif

void FREG_TSD2_SetDscOddKeyLower_OddKeyLower( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_DscOddKeyLowerMirror[index] & ~mask;
    FREG_TSD2_DscOddKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_DSCODDKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_DSCODDKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscOddKeyLower".
**
** This function reads the value from the index-th entry of the register
** array DscOddKeyLower.
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_665"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_665" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_665")))
#endif

uint32_t FREG_TSD2_GetmDscOddKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_DscOddKeyLowerMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OddKeyLower" of register "DscOddKeyLower".
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OddKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_666"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_666" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_666")))
#endif

uint32_t FREG_TSD2_GetmDscOddKeyLower_OddKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_DscOddKeyLowerMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscEvenKeyUpper".
**
** This function writes the given value to the index-th entry of the register
** array DscEvenKeyUpper.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_667"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_667" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_667")))
#endif

void FREG_TSD2_SetDscEvenKeyUpper( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD2_DscEvenKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_DSCEVENKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_DSCEVENKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "EvenKeyUpper" of register "DscEvenKeyUpper".
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "EvenKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_668"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_668" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_668")))
#endif

void FREG_TSD2_SetDscEvenKeyUpper_EvenKeyUpper( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_DscEvenKeyUpperMirror[index] & ~mask;
    FREG_TSD2_DscEvenKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_DSCEVENKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_DSCEVENKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscEvenKeyUpper".
**
** This function reads the value from the index-th entry of the register
** array DscEvenKeyUpper.
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_669"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_669" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_669")))
#endif

uint32_t FREG_TSD2_GetmDscEvenKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_DscEvenKeyUpperMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "EvenKeyUpper" of register "DscEvenKeyUpper".
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "EvenKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_670"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_670" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_670")))
#endif

uint32_t FREG_TSD2_GetmDscEvenKeyUpper_EvenKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_DscEvenKeyUpperMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscEvenKeyLower".
**
** This function writes the given value to the index-th entry of the register
** array DscEvenKeyLower.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_671"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_671" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_671")))
#endif

void FREG_TSD2_SetDscEvenKeyLower( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD2_DscEvenKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_DSCEVENKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_DSCEVENKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "EvenKeyLower" of register "DscEvenKeyLower".
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "EvenKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_672"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_672" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_672")))
#endif

void FREG_TSD2_SetDscEvenKeyLower_EvenKeyLower( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_DscEvenKeyLowerMirror[index] & ~mask;
    FREG_TSD2_DscEvenKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_DSCEVENKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_DSCEVENKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscEvenKeyLower".
**
** This function reads the value from the index-th entry of the register
** array DscEvenKeyLower.
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_673"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_673" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_673")))
#endif

uint32_t FREG_TSD2_GetmDscEvenKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_DscEvenKeyLowerMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "EvenKeyLower" of register "DscEvenKeyLower".
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "EvenKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_674"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_674" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_674")))
#endif

uint32_t FREG_TSD2_GetmDscEvenKeyLower_EvenKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_DscEvenKeyLowerMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidValue".
**
** This function writes the given value to the index-th entry of the register
** array PidValue.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_675"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_675" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_675")))
#endif

void FREG_TSD3_SetPidValue( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return;
    #endif
    FREG_TSD3_PidValueMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDVALUE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDVALUE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PidBit" of register "PidValue".
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PidBit" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_676"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_676" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_676")))
#endif

void FREG_TSD3_SetPidValue_PidBit( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_PidValueMirror[index] & ~mask;
    FREG_TSD3_PidValueMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDVALUE+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDVALUE+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidValue".
**
** This function reads the value from the index-th entry of the register
** array PidValue.
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_677"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_677" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_677")))
#endif

uint32_t FREG_TSD3_GetmPidValue( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 13 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidValueMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidBit" of register "PidValue".
**
** Bit k corresponds to PID channel k.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidBit" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_678"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_678" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_678")))
#endif

uint32_t FREG_TSD3_GetmPidValue_PidBit( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 13 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidValueMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidConfig_1".
**
** This function writes the given value to the index-th entry of the register
** array PidConfig_1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_679"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_679" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_679")))
#endif

void FREG_TSD3_SetPidConfig_1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    FREG_TSD3_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DuplicateIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for duplicate packet IRQ.
**  If the bit DUPLICATE_CHECK in TSD3_PID_config_2 is set to 1, duplicate packets will be removed. If the bit DUPLICATE_IRQ_EN is also set to 1, a DUPLICATE_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DuplicateIrqEn" consists of the bits 16..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00010000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_680"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_680" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_680")))
#endif

void FREG_TSD3_SetPidConfig_1_DuplicateIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00010000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD3_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "BufferIndex" of register "PidConfig_1".
**
** If the OFFSET_MODE (bit 7 of this register, see below) is set to 0, BUFFER_INDEX specifies to which buffer the data of this PID channel shall be stored.
**  If data from multiple PID channels shall be stored in the same buffer, these PID channels' BUFFER_INDEX shall be set to the same value.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "BufferIndex" consists of the bits 12..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00001F00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_681"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_681" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_681")))
#endif

void FREG_TSD3_SetPidConfig_1_BufferIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00001F00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD3_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OffsetMode" of register "PidConfig_1".
**
** This bit is ONLY active for PSI packets.
**
** - '1': the section data of this PID channel will be stored
** to the buffer with the index K, where k =
** BUFFER_INDEX + offset. Here offset = (matched
** filter target index). If more than one filter targets
** match the incoming section, the lowest target index
** will be used as offset.
** - '0':  the section data will be stored to buffer specified
** with BUFFER_INDEX.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OffsetMode" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_682"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_682" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_682")))
#endif

void FREG_TSD3_SetPidConfig_1_OffsetMode( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD3_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pcr1AfLt7IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** PCR flag is 1 (PCR_1), but adaptation field length is less than 7 (AF_LT_7).
**  In this case, no PCR will be extracted even if the bit EXTRACT_PCR is set to 1. The adapation field will be handeled as if the PCR flag is 0.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pcr1AfLt7IrqEn" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_683"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_683" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_683")))
#endif

void FREG_TSD3_SetPidConfig_1_Pcr1AfLt7IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000040UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    value |= FREG_TSD3_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pl1AfGt183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 1 (PL_1), but adaptation field byte number is greater than 183 (AF_GT183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pl1AfGt183IrqEn" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_684"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_684" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_684")))
#endif

void FREG_TSD3_SetPidConfig_1_Pl1AfGt183IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    value |= FREG_TSD3_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Pl0AfNe183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field length is not equal 183 (AF_NE183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Pl0AfNe183IrqEn" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_685"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_685" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_685")))
#endif

void FREG_TSD3_SetPidConfig_1_Pl0AfNe183IrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    value |= FREG_TSD3_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NullPacketIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for NULL packet IRQ.
**  Null packets (both of the adapation field flag and payload flag in packet header are 0) are alway removed. If this bit is set to 1, a NULL_PACKET_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NullPacketIrqEn" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_686"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_686" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_686")))
#endif

void FREG_TSD3_SetPidConfig_1_NullPacketIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 3 ) & mask;
    value |= FREG_TSD3_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DescramblerIndex" of register "PidConfig_1".
**
** Ranges from 0 to 7.
**  Indicates which one of the 8 descramlbers shall be used to descramble this PID channel. The descramble keys are definded through the register DSC_ODD_KEY_UPPER, DSC_ODD_KEY_LOWER, DSC_EVEN_KEY_UPPER and DSC_EVEN_KEY_LOWER. The odd/even flag of scrambling control field in the TS packet header decides if the odd or the even key of the corresponding descrambler is used to descramble the actual TS-packet.
**
** To activate the selected descrambler, the bit BYPASS_DSC in the register PID_CONFIG_2 must be set to 0.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DescramblerIndex" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_687"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_687" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_687")))
#endif

void FREG_TSD3_SetPidConfig_1_DescramblerIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000007UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_PidConfig_1Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_1+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_1+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidConfig_1".
**
** This function reads the value from the index-th entry of the register
** array PidConfig_1.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_688"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_688" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_688")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DuplicateIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for duplicate packet IRQ.
**  If the bit DUPLICATE_CHECK in TSD3_PID_config_2 is set to 1, duplicate packets will be removed. If the bit DUPLICATE_IRQ_EN is also set to 1, a DUPLICATE_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DuplicateIrqEn" consists of the bits 16..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00010000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_689"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_689" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_689")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_1_DuplicateIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_1Mirror[index];
    value = ( value & 0x00010000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "BufferIndex" of register "PidConfig_1".
**
** If the OFFSET_MODE (bit 7 of this register, see below) is set to 0, BUFFER_INDEX specifies to which buffer the data of this PID channel shall be stored.
**  If data from multiple PID channels shall be stored in the same buffer, these PID channels' BUFFER_INDEX shall be set to the same value.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "BufferIndex" consists of the bits 12..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00001F00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_690"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_690" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_690")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_1_BufferIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_1Mirror[index];
    value = ( value & 0x00001F00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OffsetMode" of register "PidConfig_1".
**
** This bit is ONLY active for PSI packets.
**
** - '1': the section data of this PID channel will be stored
** to the buffer with the index K, where k =
** BUFFER_INDEX + offset. Here offset = (matched
** filter target index). If more than one filter targets
** match the incoming section, the lowest target index
** will be used as offset.
** - '0':  the section data will be stored to buffer specified
** with BUFFER_INDEX.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OffsetMode" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_691"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_691" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_691")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_1_OffsetMode( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_1Mirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pcr1AfLt7IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** PCR flag is 1 (PCR_1), but adaptation field length is less than 7 (AF_LT_7).
**  In this case, no PCR will be extracted even if the bit EXTRACT_PCR is set to 1. The adapation field will be handeled as if the PCR flag is 0.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pcr1AfLt7IrqEn" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_692"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_692" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_692")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_1_Pcr1AfLt7IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_1Mirror[index];
    value = ( value & 0x00000040UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pl1AfGt183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 1 (PL_1), but adaptation field byte number is greater than 183 (AF_GT183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pl1AfGt183IrqEn" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_693"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_693" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_693")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_1_Pl1AfGt183IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_1Mirror[index];
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Pl0AfNe183IrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for adaptation field syntax error:
** payload flag is 0 (PL_0), but adaptation field length is not equal 183 (AF_NE183).
**  In this case all data bytes in this TS packet will be taken as adaptation field data.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Pl0AfNe183IrqEn" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_694"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_694" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_694")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_1_Pl0AfNe183IrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_1Mirror[index];
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NullPacketIrqEn" of register "PidConfig_1".
**
** Interrupt enable bit for NULL packet IRQ.
**  Null packets (both of the adapation field flag and payload flag in packet header are 0) are alway removed. If this bit is set to 1, a NULL_PACKET_IRQ will be generated.
** - '0': disable interrupt
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NullPacketIrqEn" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_695"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_695" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_695")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_1_NullPacketIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_1Mirror[index];
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DescramblerIndex" of register "PidConfig_1".
**
** Ranges from 0 to 7.
**  Indicates which one of the 8 descramlbers shall be used to descramble this PID channel. The descramble keys are definded through the register DSC_ODD_KEY_UPPER, DSC_ODD_KEY_LOWER, DSC_EVEN_KEY_UPPER and DSC_EVEN_KEY_LOWER. The odd/even flag of scrambling control field in the TS packet header decides if the odd or the even key of the corresponding descrambler is used to descramble the actual TS-packet.
**
** To activate the selected descrambler, the bit BYPASS_DSC in the register PID_CONFIG_2 must be set to 0.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DescramblerIndex" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_696"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_696" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_696")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_1_DescramblerIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_1Mirror[index];
    value = ( value & 0x00000007UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PidConfig_2".
**
** This function writes the given value to the index-th entry of the register
** array PidConfig_2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_697"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_697" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_697")))
#endif

void FREG_TSD3_SetPidConfig_2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PtrTarget" of register "PidConfig_2".
**
** Pointer to the first target in SF_target_RAM.
**
** PTR_TARGET ranges from 0 to 127. This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0.
**
** For example, if the first target is stored in line 25 of SF_target_RAM, then PTR_TARGET shall be set to 25.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PtrTarget" consists of the bits 31..25,
**       the given bitgroup value will be shifted left by 25 bits and
**       masked using the bitmask 0xFE000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_698"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_698" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_698")))
#endif

void FREG_TSD3_SetPidConfig_2_PtrTarget( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFE000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 25 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NTarget" of register "PidConfig_2".
**
** Number of filter target.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. Let the number of target be k. k is coded and stored to N_TARGET. Attention: N_TARGET is not binary-coded decimal format of k (see below)!! For example, if k = 4, N_TARGET is '1000' (decimal 8) not '0100' (decimal 4).
** - k= 1: N_TARGET='0001'
** - k= 2: N_TARGET='0010'
** - k= 4: N_TARGET='1000'
** - k= 8: N_TARGET='1001'
** - k=12: N_TARGET='1010'
** - k=16: N_TARGET='1011'
** - k=20: N_TARGET='1100'
** - k=24: N_TARGET='1101'
** - k=28: N_TARGET='1110'
** - k=32: N_TARGET='1111'
** (Coding rules:
** N_TARGET[3] = 0 and N_TARGET[2:0] = k, if k<4.
** N_TARGET[3] = 1 and N_TARGET[2:0] = (k/4)-1, if k4.)
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NTarget" consists of the bits 24..21,
**       the given bitgroup value will be shifted left by 21 bits and
**       masked using the bitmask 0x01E00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_699"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_699" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_699")))
#endif

void FREG_TSD3_SetPidConfig_2_NTarget( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x01E00000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 21 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TargetLength" of register "PidConfig_2".
**
** Filter target length.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. All filter targets of a PID channel shall have the same length. TARGET_LENGTH ranges from 1 to 15 (including table ID byte, but excluding the two section length bytes).
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TargetLength" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_700"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_700" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_700")))
#endif

void FREG_TSD3_SetPidConfig_2_TargetLength( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x001F0000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "StoreCompletePacket" of register "PidConfig_2".
**
** Indicate if TS packets header (4 bytes) and adaptation field shall be stored.
**
** - '0': Only payload shall be stored (packet header and adaptation field shall be removed).
** - '1': The complete packet (packet header, adaptation field and payload) shall be stored.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "StoreCompletePacket" consists of the bits 15..15,
**       the given bitgroup value will be shifted left by 15 bits and
**       masked using the bitmask 0x00008000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_701"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_701" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_701")))
#endif

void FREG_TSD3_SetPidConfig_2_StoreCompletePacket( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00008000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 15 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PusIrqEn" of register "PidConfig_2".
**
** Payload Unit Start (PUS) interrupt enable:
** - '0': disabled.
**
** - '1': enabled.
** If the Payload Unit Start Indicator of a transport stream packet is '1' and PUS_IRQ_EN is '1' then a PUS_IRQ will be triggered.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PusIrqEn" consists of the bits 14..14,
**       the given bitgroup value will be shifted left by 14 bits and
**       masked using the bitmask 0x00004000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_702"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_702" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_702")))
#endif

void FREG_TSD3_SetPidConfig_2_PusIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00004000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 14 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no packet is received during a certain time (defined in the register INPUT_TIMEOUT), an INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt.
** -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InputTimeoutIrqEn" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_703"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_703" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_703")))
#endif

void FREG_TSD3_SetPidConfig_2_InputTimeoutIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00002000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 13 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ValidInputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no valid packet is received during a certain time (defined the in register VALID_INPUT_TIMEOUT), an VALID_INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ValidInputTimeoutIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_704"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_704" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_704")))
#endif

void FREG_TSD3_SetPidConfig_2_ValidInputTimeoutIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00001000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 12 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NewPcrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PCR handling (new PCR available)
** - '1': enable interrupt.
**
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NewPcrIrqEn" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_705"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_705" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_705")))
#endif

void FREG_TSD3_SetPidConfig_2_NewPcrIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000800UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 11 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CcIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CONTINUITY_COUNTER_ERROR_IRQ.
**  If CC_CHECK is set and a continuity counter error is found,  a CONTINUITY_COUNTER_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CcIrqEn" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_706"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_706" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_706")))
#endif

void FREG_TSD3_SetPidConfig_2_CcIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000400UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 10 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SectionEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for SECTION_END_IRQ.
**  If an incoming section matches at least one filter target and its end is detected, a SECTION_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SectionEndIrqEn" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_707"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_707" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_707")))
#endif

void FREG_TSD3_SetPidConfig_2_SectionEndIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000200UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 9 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PACKET_END_IRQ.
**  If the PID of an incoming packet matches the PID of this channel and all bytes in this packet was sent to Buffer Mangager, a PACKET_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketEndIrqEn" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_708"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_708" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_708")))
#endif

void FREG_TSD3_SetPidConfig_2_PacketEndIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000100UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ScrambledPacketIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for scrambled transport packet.
**  If the scrambling controll flag in TS packet header is set to 1, a SCRAMBLED_PACKET_IRQ will be generated.
** - '1': enable interrupt
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ScrambledPacketIrqEn" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_709"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_709" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_709")))
#endif

void FREG_TSD3_SetPidConfig_2_ScrambledPacketIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CcCheck" of register "PidConfig_2".
**
** Continuity Counter error  check.
**  If a TS packet has payload, its continuity counter shall be incremented by 1 or equals to that of the previous packet. If a TS packet has only adaptation field, its continuity counter shall not be incremented. If any of the conditions is not filled, the TS packet will be discarded and the corresponding PID channel will be disabled.
** - '0': don't check
** - '1': if CC error detected, discard the packet and disable the corresponding PID channel will be deactivated.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CcCheck" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_710"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_710" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_710")))
#endif

void FREG_TSD3_SetPidConfig_2_CcCheck( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000040UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DuplicateCheck" of register "PidConfig_2".
**
** Duplicate packet check.
**  If a TS packet has payload but its continuity counter is equal to that of the previous packet, then this packet is a duplicate packet. If this bit is set, such packets will be discarded.
** - '0': don't check
** - '1': discard duplicate packet.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DuplicateCheck" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_711"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_711" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_711")))
#endif

void FREG_TSD3_SetPidConfig_2_DuplicateCheck( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PesPayload" of register "PidConfig_2".
**
** Specifies type of transport packet payload
** - '0': PSI payload (section data)
** - '1': PES payload (video, MPEG audio,
** teletext, closed caption)
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PesPayload" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_712"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_712" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_712")))
#endif

void FREG_TSD3_SetPidConfig_2_PesPayload( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000010UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 4 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ExtractPcr" of register "PidConfig_2".
**
** Enable the extraction of PCR field from adaptation field:
** - '0': PCR should be skipped
** - '1': PCR should be extracted.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ExtractPcr" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_713"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_713" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_713")))
#endif

void FREG_TSD3_SetPidConfig_2_ExtractPcr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000008UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 3 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PsiCcCheckMode" of register "PidConfig_2".
**
** Specify the Continuity Counter (CC) Check Mode for PSI packets (therefore ONLY active for PSI packets):
** - '1': always check continuity counter if CC_CHECK is
** enabled.
**
** - '0': only check continuity counter if check is enabled and section filter is active.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PsiCcCheckMode" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_714"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_714" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_714")))
#endif

void FREG_TSD3_SetPidConfig_2_PsiCcCheckMode( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000004UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 2 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "CrcErrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CRC error.
**  If the syntax indicator in a section is set to 1 and the CRC  in this section is wrong, a CRC_ERROR_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "CrcErrIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_715"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_715" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_715")))
#endif

void FREG_TSD3_SetPidConfig_2_CrcErrIrqEn( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000002UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 1 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "BypassDsc" of register "PidConfig_2".
**
** Bypass DVB descrambler.
**
** - '0': DVB descrambler not bypassed. Descramlbe key and the DESCRAMBLER_INDEX in CONFIG_1 must be programmed. If the scrambling control flag in the TS packet header is not set, the descrambler will not be activated even if this bit is set to 0. Therefore, this bit can be set to 0 in all default configuration and it shall be set to 1 only if descrambler must be deactivated.
** - '1': DVB descrambler is bypassed.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "BypassDsc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_716"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_716" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_716")))
#endif

void FREG_TSD3_SetPidConfig_2_BypassDsc( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000001UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_PidConfig_2Mirror[index] & ~mask;
    FREG_TSD3_PidConfig_2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PIDCONFIG_2+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PIDCONFIG_2+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PidConfig_2".
**
** This function reads the value from the index-th entry of the register
** array PidConfig_2.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_717"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_717" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_717")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PtrTarget" of register "PidConfig_2".
**
** Pointer to the first target in SF_target_RAM.
**
** PTR_TARGET ranges from 0 to 127. This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0.
**
** For example, if the first target is stored in line 25 of SF_target_RAM, then PTR_TARGET shall be set to 25.
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PtrTarget" consists of the bits 31..25,
**       the given bitgroup value will be shifted left by 25 bits and
**       masked using the bitmask 0xFE000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_718"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_718" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_718")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_PtrTarget( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0xFE000000UL ) >> 25;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NTarget" of register "PidConfig_2".
**
** Number of filter target.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. Let the number of target be k. k is coded and stored to N_TARGET. Attention: N_TARGET is not binary-coded decimal format of k (see below)!! For example, if k = 4, N_TARGET is '1000' (decimal 8) not '0100' (decimal 4).
** - k= 1: N_TARGET='0001'
** - k= 2: N_TARGET='0010'
** - k= 4: N_TARGET='1000'
** - k= 8: N_TARGET='1001'
** - k=12: N_TARGET='1010'
** - k=16: N_TARGET='1011'
** - k=20: N_TARGET='1100'
** - k=24: N_TARGET='1101'
** - k=28: N_TARGET='1110'
** - k=32: N_TARGET='1111'
** (Coding rules:
** N_TARGET[3] = 0 and N_TARGET[2:0] = k, if k<4.
** N_TARGET[3] = 1 and N_TARGET[2:0] = (k/4)-1, if k4.)
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NTarget" consists of the bits 24..21,
**       the given bitgroup value will be shifted left by 21 bits and
**       masked using the bitmask 0x01E00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_719"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_719" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_719")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_NTarget( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x01E00000UL ) >> 21;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TargetLength" of register "PidConfig_2".
**
** Filter target length.
**  This bit group is used to configure section filter. Therefore the bit PES_PAYLOAD in this register must be set to 0. All filter targets of a PID channel shall have the same length. TARGET_LENGTH ranges from 1 to 15 (including table ID byte, but excluding the two section length bytes).
**
** To transfer all sections received to Buffer Manager without filtering, use the following configuration:
** 1) Set all enable bits of Data-Enable-Pairs (DEPs) at line 0 of SF_target_RAM to 0 (The value 0 stands for 'don't care').
** 2) Set PTR_TARGET = 0, that means, pointer to the first target to line 0 of SF_target_RAM.
** 3) Set N_TARGET = '1000'.
** 4) Set TARGET_LENGTH =  1.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TargetLength" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_720"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_720" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_720")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_TargetLength( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x001F0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "StoreCompletePacket" of register "PidConfig_2".
**
** Indicate if TS packets header (4 bytes) and adaptation field shall be stored.
**
** - '0': Only payload shall be stored (packet header and adaptation field shall be removed).
** - '1': The complete packet (packet header, adaptation field and payload) shall be stored.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "StoreCompletePacket" consists of the bits 15..15,
**       the given bitgroup value will be shifted left by 15 bits and
**       masked using the bitmask 0x00008000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_721"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_721" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_721")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_StoreCompletePacket( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00008000UL ) >> 15;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PusIrqEn" of register "PidConfig_2".
**
** Payload Unit Start (PUS) interrupt enable:
** - '0': disabled.
**
** - '1': enabled.
** If the Payload Unit Start Indicator of a transport stream packet is '1' and PUS_IRQ_EN is '1' then a PUS_IRQ will be triggered.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PusIrqEn" consists of the bits 14..14,
**       the given bitgroup value will be shifted left by 14 bits and
**       masked using the bitmask 0x00004000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_722"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_722" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_722")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_PusIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00004000UL ) >> 14;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no packet is received during a certain time (defined in the register INPUT_TIMEOUT), an INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt.
** -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "InputTimeoutIrqEn" consists of the bits 13..13,
**       the given bitgroup value will be shifted left by 13 bits and
**       masked using the bitmask 0x00002000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_723"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_723" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_723")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_InputTimeoutIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00002000UL ) >> 13;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ValidInputTimeoutIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for INPUT_TIMEOUT_IRQ.
**  If no valid packet is received during a certain time (defined the in register VALID_INPUT_TIMEOUT), an VALID_INPUT_TIMEOUT_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ValidInputTimeoutIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_724"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_724" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_724")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_ValidInputTimeoutIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00001000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NewPcrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PCR handling (new PCR available)
** - '1': enable interrupt.
**
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NewPcrIrqEn" consists of the bits 11..11,
**       the given bitgroup value will be shifted left by 11 bits and
**       masked using the bitmask 0x00000800UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_725"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_725" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_725")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_NewPcrIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000800UL ) >> 11;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CcIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CONTINUITY_COUNTER_ERROR_IRQ.
**  If CC_CHECK is set and a continuity counter error is found,  a CONTINUITY_COUNTER_ERROR_IRQ will be generated.
** - '1': enable interrupt -'0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CcIrqEn" consists of the bits 10..10,
**       the given bitgroup value will be shifted left by 10 bits and
**       masked using the bitmask 0x00000400UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_726"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_726" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_726")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_CcIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000400UL ) >> 10;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SectionEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for SECTION_END_IRQ.
**  If an incoming section matches at least one filter target and its end is detected, a SECTION_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SectionEndIrqEn" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_727"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_727" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_727")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_SectionEndIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketEndIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for PACKET_END_IRQ.
**  If the PID of an incoming packet matches the PID of this channel and all bytes in this packet was sent to Buffer Mangager, a PACKET_END_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketEndIrqEn" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_728"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_728" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_728")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_PacketEndIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000100UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ScrambledPacketIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for scrambled transport packet.
**  If the scrambling controll flag in TS packet header is set to 1, a SCRAMBLED_PACKET_IRQ will be generated.
** - '1': enable interrupt
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ScrambledPacketIrqEn" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_729"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_729" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_729")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_ScrambledPacketIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CcCheck" of register "PidConfig_2".
**
** Continuity Counter error  check.
**  If a TS packet has payload, its continuity counter shall be incremented by 1 or equals to that of the previous packet. If a TS packet has only adaptation field, its continuity counter shall not be incremented. If any of the conditions is not filled, the TS packet will be discarded and the corresponding PID channel will be disabled.
** - '0': don't check
** - '1': if CC error detected, discard the packet and disable the corresponding PID channel will be deactivated.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CcCheck" consists of the bits 6..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x00000040UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_730"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_730" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_730")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_CcCheck( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000040UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DuplicateCheck" of register "PidConfig_2".
**
** Duplicate packet check.
**  If a TS packet has payload but its continuity counter is equal to that of the previous packet, then this packet is a duplicate packet. If this bit is set, such packets will be discarded.
** - '0': don't check
** - '1': discard duplicate packet.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "DuplicateCheck" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_731"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_731" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_731")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_DuplicateCheck( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PesPayload" of register "PidConfig_2".
**
** Specifies type of transport packet payload
** - '0': PSI payload (section data)
** - '1': PES payload (video, MPEG audio,
** teletext, closed caption)
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PesPayload" consists of the bits 4..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000010UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_732"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_732" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_732")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_PesPayload( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000010UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ExtractPcr" of register "PidConfig_2".
**
** Enable the extraction of PCR field from adaptation field:
** - '0': PCR should be skipped
** - '1': PCR should be extracted.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ExtractPcr" consists of the bits 3..3,
**       the given bitgroup value will be shifted left by 3 bits and
**       masked using the bitmask 0x00000008UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_733"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_733" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_733")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_ExtractPcr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000008UL ) >> 3;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PsiCcCheckMode" of register "PidConfig_2".
**
** Specify the Continuity Counter (CC) Check Mode for PSI packets (therefore ONLY active for PSI packets):
** - '1': always check continuity counter if CC_CHECK is
** enabled.
**
** - '0': only check continuity counter if check is enabled and section filter is active.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PsiCcCheckMode" consists of the bits 2..2,
**       the given bitgroup value will be shifted left by 2 bits and
**       masked using the bitmask 0x00000004UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_734"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_734" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_734")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_PsiCcCheckMode( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000004UL ) >> 2;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "CrcErrIrqEn" of register "PidConfig_2".
**
** Interrupt enable bit for CRC error.
**  If the syntax indicator in a section is set to 1 and the CRC  in this section is wrong, a CRC_ERROR_IRQ will be generated.
** - '1': enable interrupt.
** - '0': disable interrupt.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "CrcErrIrqEn" consists of the bits 1..1,
**       the given bitgroup value will be shifted left by 1 bits and
**       masked using the bitmask 0x00000002UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_735"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_735" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_735")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_CrcErrIrqEn( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000002UL ) >> 1;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "BypassDsc" of register "PidConfig_2".
**
** Bypass DVB descrambler.
**
** - '0': DVB descrambler not bypassed. Descramlbe key and the DESCRAMBLER_INDEX in CONFIG_1 must be programmed. If the scrambling control flag in the TS packet header is not set, the descrambler will not be activated even if this bit is set to 0. Therefore, this bit can be set to 0 in all default configuration and it shall be set to 1 only if descrambler must be deactivated.
** - '1': DVB descrambler is bypassed.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "BypassDsc" consists of the bits 0..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000001UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_736"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_736" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_736")))
#endif

uint32_t FREG_TSD3_GetmPidConfig_2_BypassDsc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 32 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_PidConfig_2Mirror[index];
    value = ( value & 0x00000001UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscOddKeyUpper".
**
** This function writes the given value to the index-th entry of the register
** array DscOddKeyUpper.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_737"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_737" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_737")))
#endif

void FREG_TSD3_SetDscOddKeyUpper( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD3_DscOddKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_DSCODDKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_DSCODDKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OddKeyUpper" of register "DscOddKeyUpper".
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OddKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_738"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_738" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_738")))
#endif

void FREG_TSD3_SetDscOddKeyUpper_OddKeyUpper( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_DscOddKeyUpperMirror[index] & ~mask;
    FREG_TSD3_DscOddKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_DSCODDKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_DSCODDKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscOddKeyUpper".
**
** This function reads the value from the index-th entry of the register
** array DscOddKeyUpper.
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_739"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_739" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_739")))
#endif

uint32_t FREG_TSD3_GetmDscOddKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_DscOddKeyUpperMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OddKeyUpper" of register "DscOddKeyUpper".
**
** The upper 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OddKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_740"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_740" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_740")))
#endif

uint32_t FREG_TSD3_GetmDscOddKeyUpper_OddKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_DscOddKeyUpperMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscOddKeyLower".
**
** This function writes the given value to the index-th entry of the register
** array DscOddKeyLower.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_741"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_741" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_741")))
#endif

void FREG_TSD3_SetDscOddKeyLower( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD3_DscOddKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_DSCODDKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_DSCODDKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "OddKeyLower" of register "DscOddKeyLower".
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "OddKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_742"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_742" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_742")))
#endif

void FREG_TSD3_SetDscOddKeyLower_OddKeyLower( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_DscOddKeyLowerMirror[index] & ~mask;
    FREG_TSD3_DscOddKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_DSCODDKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_DSCODDKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscOddKeyLower".
**
** This function reads the value from the index-th entry of the register
** array DscOddKeyLower.
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_743"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_743" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_743")))
#endif

uint32_t FREG_TSD3_GetmDscOddKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_DscOddKeyLowerMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "OddKeyLower" of register "DscOddKeyLower".
**
** The lower 32 bit of the odd descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "OddKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_744"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_744" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_744")))
#endif

uint32_t FREG_TSD3_GetmDscOddKeyLower_OddKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_DscOddKeyLowerMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscEvenKeyUpper".
**
** This function writes the given value to the index-th entry of the register
** array DscEvenKeyUpper.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_745"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_745" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_745")))
#endif

void FREG_TSD3_SetDscEvenKeyUpper( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD3_DscEvenKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_DSCEVENKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_DSCEVENKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "EvenKeyUpper" of register "DscEvenKeyUpper".
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "EvenKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_746"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_746" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_746")))
#endif

void FREG_TSD3_SetDscEvenKeyUpper_EvenKeyUpper( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_DscEvenKeyUpperMirror[index] & ~mask;
    FREG_TSD3_DscEvenKeyUpperMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_DSCEVENKEYUPPER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_DSCEVENKEYUPPER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscEvenKeyUpper".
**
** This function reads the value from the index-th entry of the register
** array DscEvenKeyUpper.
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_747"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_747" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_747")))
#endif

uint32_t FREG_TSD3_GetmDscEvenKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_DscEvenKeyUpperMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "EvenKeyUpper" of register "DscEvenKeyUpper".
**
** The upper 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "EvenKeyUpper" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_748"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_748" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_748")))
#endif

uint32_t FREG_TSD3_GetmDscEvenKeyUpper_EvenKeyUpper( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_DscEvenKeyUpperMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "DscEvenKeyLower".
**
** This function writes the given value to the index-th entry of the register
** array DscEvenKeyLower.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_749"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_749" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_749")))
#endif

void FREG_TSD3_SetDscEvenKeyLower( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    FREG_TSD3_DscEvenKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_DSCEVENKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_DSCEVENKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "EvenKeyLower" of register "DscEvenKeyLower".
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "EvenKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_750"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_750" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_750")))
#endif

void FREG_TSD3_SetDscEvenKeyLower_EvenKeyLower( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_DscEvenKeyLowerMirror[index] & ~mask;
    FREG_TSD3_DscEvenKeyLowerMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_DSCEVENKEYLOWER+(index*0x10), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_DSCEVENKEYLOWER+(index*0x10))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "DscEvenKeyLower".
**
** This function reads the value from the index-th entry of the register
** array DscEvenKeyLower.
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_751"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_751" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_751")))
#endif

uint32_t FREG_TSD3_GetmDscEvenKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 8 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_DscEvenKeyLowerMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "EvenKeyLower" of register "DscEvenKeyLower".
**
** The lower 32 bit of the even descramble key.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "EvenKeyLower" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_752"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_752" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_752")))
#endif

uint32_t FREG_TSD3_GetmDscEvenKeyLower_EvenKeyLower( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 8 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_DscEvenKeyLowerMirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket0".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_753"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_753" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_753")))
#endif

void FREG_TSD2_SetLinPacket0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_LinPacket0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_754"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_754" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_754")))
#endif

void FREG_TSD2_SetLinPacket0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_LinPacket0Mirror[index] & ~mask;
    FREG_TSD2_LinPacket0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket0".
**
** This function reads the value from the index-th entry of the register
** array LinPacket0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_755"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_755" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_755")))
#endif

uint32_t FREG_TSD2_GetmLinPacket0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacket0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_756"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_756" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_756")))
#endif

uint32_t FREG_TSD2_GetmLinPacket0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacket0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket1".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_757"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_757" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_757")))
#endif

void FREG_TSD2_SetLinPacket1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_LinPacket1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_758"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_758" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_758")))
#endif

void FREG_TSD2_SetLinPacket1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_LinPacket1Mirror[index] & ~mask;
    FREG_TSD2_LinPacket1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket1".
**
** This function reads the value from the index-th entry of the register
** array LinPacket1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_759"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_759" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_759")))
#endif

uint32_t FREG_TSD2_GetmLinPacket1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacket1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_760"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_760" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_760")))
#endif

uint32_t FREG_TSD2_GetmLinPacket1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacket1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket2".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_761"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_761" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_761")))
#endif

void FREG_TSD2_SetLinPacket2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_LinPacket2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_762"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_762" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_762")))
#endif

void FREG_TSD2_SetLinPacket2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_LinPacket2Mirror[index] & ~mask;
    FREG_TSD2_LinPacket2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket2".
**
** This function reads the value from the index-th entry of the register
** array LinPacket2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_763"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_763" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_763")))
#endif

uint32_t FREG_TSD2_GetmLinPacket2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacket2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_764"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_764" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_764")))
#endif

uint32_t FREG_TSD2_GetmLinPacket2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacket2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket3".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_765"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_765" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_765")))
#endif

void FREG_TSD2_SetLinPacket3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_LinPacket3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_766"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_766" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_766")))
#endif

void FREG_TSD2_SetLinPacket3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_LinPacket3Mirror[index] & ~mask;
    FREG_TSD2_LinPacket3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket3".
**
** This function reads the value from the index-th entry of the register
** array LinPacket3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_767"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_767" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_767")))
#endif

uint32_t FREG_TSD2_GetmLinPacket3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacket3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_768"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_768" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_768")))
#endif

uint32_t FREG_TSD2_GetmLinPacket3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacket3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket0".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_769"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_769" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_769")))
#endif

void FREG_TSD3_SetLinPacket0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_LinPacket0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_770"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_770" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_770")))
#endif

void FREG_TSD3_SetLinPacket0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_LinPacket0Mirror[index] & ~mask;
    FREG_TSD3_LinPacket0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket0".
**
** This function reads the value from the index-th entry of the register
** array LinPacket0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_771"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_771" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_771")))
#endif

uint32_t FREG_TSD3_GetmLinPacket0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacket0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_772"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_772" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_772")))
#endif

uint32_t FREG_TSD3_GetmLinPacket0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacket0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket1".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_773"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_773" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_773")))
#endif

void FREG_TSD3_SetLinPacket1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_LinPacket1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_774"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_774" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_774")))
#endif

void FREG_TSD3_SetLinPacket1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_LinPacket1Mirror[index] & ~mask;
    FREG_TSD3_LinPacket1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket1".
**
** This function reads the value from the index-th entry of the register
** array LinPacket1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_775"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_775" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_775")))
#endif

uint32_t FREG_TSD3_GetmLinPacket1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacket1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_776"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_776" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_776")))
#endif

uint32_t FREG_TSD3_GetmLinPacket1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacket1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket2".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_777"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_777" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_777")))
#endif

void FREG_TSD3_SetLinPacket2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_LinPacket2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_778"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_778" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_778")))
#endif

void FREG_TSD3_SetLinPacket2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_LinPacket2Mirror[index] & ~mask;
    FREG_TSD3_LinPacket2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket2".
**
** This function reads the value from the index-th entry of the register
** array LinPacket2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_779"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_779" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_779")))
#endif

uint32_t FREG_TSD3_GetmLinPacket2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacket2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_780"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_780" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_780")))
#endif

uint32_t FREG_TSD3_GetmLinPacket2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacket2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacket3".
**
** This function writes the given value to the index-th entry of the register
** array LinPacket3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_781"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_781" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_781")))
#endif

void FREG_TSD3_SetLinPacket3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_LinPacket3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacket3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_782"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_782" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_782")))
#endif

void FREG_TSD3_SetLinPacket3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_LinPacket3Mirror[index] & ~mask;
    FREG_TSD3_LinPacket3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacket3".
**
** This function reads the value from the index-th entry of the register
** array LinPacket3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_783"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_783" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_783")))
#endif

uint32_t FREG_TSD3_GetmLinPacket3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacket3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacket3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_784"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_784" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_784")))
#endif

uint32_t FREG_TSD3_GetmLinPacket3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacket3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto0".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_785"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_785" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_785")))
#endif

void FREG_TSD2_SetLinPacketAuto0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_LinPacketAuto0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKETAUTO0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKETAUTO0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_786"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_786" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_786")))
#endif

void FREG_TSD2_SetLinPacketAuto0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_LinPacketAuto0Mirror[index] & ~mask;
    FREG_TSD2_LinPacketAuto0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKETAUTO0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKETAUTO0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto0".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_787"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_787" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_787")))
#endif

uint32_t FREG_TSD2_GetmLinPacketAuto0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacketAuto0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_788"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_788" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_788")))
#endif

uint32_t FREG_TSD2_GetmLinPacketAuto0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacketAuto0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto1".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_789"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_789" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_789")))
#endif

void FREG_TSD2_SetLinPacketAuto1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_LinPacketAuto1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKETAUTO1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKETAUTO1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_790"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_790" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_790")))
#endif

void FREG_TSD2_SetLinPacketAuto1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_LinPacketAuto1Mirror[index] & ~mask;
    FREG_TSD2_LinPacketAuto1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKETAUTO1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKETAUTO1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto1".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_791"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_791" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_791")))
#endif

uint32_t FREG_TSD2_GetmLinPacketAuto1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacketAuto1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_792"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_792" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_792")))
#endif

uint32_t FREG_TSD2_GetmLinPacketAuto1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacketAuto1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto2".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_793"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_793" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_793")))
#endif

void FREG_TSD2_SetLinPacketAuto2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_LinPacketAuto2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKETAUTO2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKETAUTO2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_794"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_794" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_794")))
#endif

void FREG_TSD2_SetLinPacketAuto2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_LinPacketAuto2Mirror[index] & ~mask;
    FREG_TSD2_LinPacketAuto2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKETAUTO2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKETAUTO2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto2".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_795"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_795" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_795")))
#endif

uint32_t FREG_TSD2_GetmLinPacketAuto2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacketAuto2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_796"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_796" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_796")))
#endif

uint32_t FREG_TSD2_GetmLinPacketAuto2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacketAuto2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto3".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_797"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_797" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_797")))
#endif

void FREG_TSD2_SetLinPacketAuto3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_LinPacketAuto3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKETAUTO3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKETAUTO3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_798"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_798" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_798")))
#endif

void FREG_TSD2_SetLinPacketAuto3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_LinPacketAuto3Mirror[index] & ~mask;
    FREG_TSD2_LinPacketAuto3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_LINPACKETAUTO3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_LINPACKETAUTO3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto3".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_799"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_799" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_799")))
#endif

uint32_t FREG_TSD2_GetmLinPacketAuto3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacketAuto3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_800"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_800" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_800")))
#endif

uint32_t FREG_TSD2_GetmLinPacketAuto3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_LinPacketAuto3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto0".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_801"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_801" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_801")))
#endif

void FREG_TSD3_SetLinPacketAuto0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_LinPacketAuto0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKETAUTO0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKETAUTO0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_802"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_802" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_802")))
#endif

void FREG_TSD3_SetLinPacketAuto0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_LinPacketAuto0Mirror[index] & ~mask;
    FREG_TSD3_LinPacketAuto0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKETAUTO0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKETAUTO0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto0".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_803"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_803" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_803")))
#endif

uint32_t FREG_TSD3_GetmLinPacketAuto0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacketAuto0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_804"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_804" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_804")))
#endif

uint32_t FREG_TSD3_GetmLinPacketAuto0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacketAuto0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto1".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_805"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_805" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_805")))
#endif

void FREG_TSD3_SetLinPacketAuto1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_LinPacketAuto1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKETAUTO1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKETAUTO1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_806"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_806" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_806")))
#endif

void FREG_TSD3_SetLinPacketAuto1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_LinPacketAuto1Mirror[index] & ~mask;
    FREG_TSD3_LinPacketAuto1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKETAUTO1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKETAUTO1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto1".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_807"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_807" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_807")))
#endif

uint32_t FREG_TSD3_GetmLinPacketAuto1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacketAuto1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_808"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_808" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_808")))
#endif

uint32_t FREG_TSD3_GetmLinPacketAuto1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacketAuto1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto2".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_809"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_809" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_809")))
#endif

void FREG_TSD3_SetLinPacketAuto2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_LinPacketAuto2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKETAUTO2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKETAUTO2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_810"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_810" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_810")))
#endif

void FREG_TSD3_SetLinPacketAuto2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_LinPacketAuto2Mirror[index] & ~mask;
    FREG_TSD3_LinPacketAuto2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKETAUTO2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKETAUTO2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto2".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_811"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_811" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_811")))
#endif

uint32_t FREG_TSD3_GetmLinPacketAuto2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacketAuto2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_812"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_812" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_812")))
#endif

uint32_t FREG_TSD3_GetmLinPacketAuto2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacketAuto2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "LinPacketAuto3".
**
** This function writes the given value to the index-th entry of the register
** array LinPacketAuto3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_813"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_813" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_813")))
#endif

void FREG_TSD3_SetLinPacketAuto3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_LinPacketAuto3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKETAUTO3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKETAUTO3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "LinPacketAuto3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_814"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_814" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_814")))
#endif

void FREG_TSD3_SetLinPacketAuto3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_LinPacketAuto3Mirror[index] & ~mask;
    FREG_TSD3_LinPacketAuto3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_LINPACKETAUTO3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_LINPACKETAUTO3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "LinPacketAuto3".
**
** This function reads the value from the index-th entry of the register
** array LinPacketAuto3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_815"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_815" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_815")))
#endif

uint32_t FREG_TSD3_GetmLinPacketAuto3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacketAuto3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "LinPacketAuto3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_816"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_816" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_816")))
#endif

uint32_t FREG_TSD3_GetmLinPacketAuto3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_LinPacketAuto3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet0".
**
** This function writes the given value to the index-th entry of the register
** array Packet0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_817"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_817" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_817")))
#endif

void FREG_TSD2_SetPacket0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_Packet0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_818"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_818" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_818")))
#endif

void FREG_TSD2_SetPacket0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_Packet0Mirror[index] & ~mask;
    FREG_TSD2_Packet0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet0".
**
** This function reads the value from the index-th entry of the register
** array Packet0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_819"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_819" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_819")))
#endif

uint32_t FREG_TSD2_GetmPacket0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_Packet0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_820"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_820" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_820")))
#endif

uint32_t FREG_TSD2_GetmPacket0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_Packet0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet1".
**
** This function writes the given value to the index-th entry of the register
** array Packet1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_821"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_821" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_821")))
#endif

void FREG_TSD2_SetPacket1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_Packet1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_822"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_822" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_822")))
#endif

void FREG_TSD2_SetPacket1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_Packet1Mirror[index] & ~mask;
    FREG_TSD2_Packet1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet1".
**
** This function reads the value from the index-th entry of the register
** array Packet1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_823"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_823" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_823")))
#endif

uint32_t FREG_TSD2_GetmPacket1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_Packet1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_824"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_824" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_824")))
#endif

uint32_t FREG_TSD2_GetmPacket1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_Packet1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet2".
**
** This function writes the given value to the index-th entry of the register
** array Packet2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_825"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_825" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_825")))
#endif

void FREG_TSD2_SetPacket2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_Packet2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_826"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_826" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_826")))
#endif

void FREG_TSD2_SetPacket2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_Packet2Mirror[index] & ~mask;
    FREG_TSD2_Packet2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet2".
**
** This function reads the value from the index-th entry of the register
** array Packet2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_827"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_827" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_827")))
#endif

uint32_t FREG_TSD2_GetmPacket2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_Packet2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_828"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_828" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_828")))
#endif

uint32_t FREG_TSD2_GetmPacket2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_Packet2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet3".
**
** This function writes the given value to the index-th entry of the register
** array Packet3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_829"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_829" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_829")))
#endif

void FREG_TSD2_SetPacket3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD2_Packet3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_830"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_830" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_830")))
#endif

void FREG_TSD2_SetPacket3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_Packet3Mirror[index] & ~mask;
    FREG_TSD2_Packet3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet3".
**
** This function reads the value from the index-th entry of the register
** array Packet3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_831"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_831" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_831")))
#endif

uint32_t FREG_TSD2_GetmPacket3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_Packet3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_832"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_832" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_832")))
#endif

uint32_t FREG_TSD2_GetmPacket3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_Packet3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet0".
**
** This function writes the given value to the index-th entry of the register
** array Packet0.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_833"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_833" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_833")))
#endif

void FREG_TSD3_SetPacket0( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_Packet0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_834"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_834" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_834")))
#endif

void FREG_TSD3_SetPacket0_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_Packet0Mirror[index] & ~mask;
    FREG_TSD3_Packet0Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKET0+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKET0+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet0".
**
** This function reads the value from the index-th entry of the register
** array Packet0.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_835"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_835" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_835")))
#endif

uint32_t FREG_TSD3_GetmPacket0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_Packet0Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet0".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_836"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_836" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_836")))
#endif

uint32_t FREG_TSD3_GetmPacket0_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_Packet0Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet1".
**
** This function writes the given value to the index-th entry of the register
** array Packet1.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_837"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_837" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_837")))
#endif

void FREG_TSD3_SetPacket1( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_Packet1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_838"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_838" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_838")))
#endif

void FREG_TSD3_SetPacket1_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_Packet1Mirror[index] & ~mask;
    FREG_TSD3_Packet1Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKET1+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKET1+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet1".
**
** This function reads the value from the index-th entry of the register
** array Packet1.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_839"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_839" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_839")))
#endif

uint32_t FREG_TSD3_GetmPacket1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_Packet1Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet1".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_840"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_840" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_840")))
#endif

uint32_t FREG_TSD3_GetmPacket1_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_Packet1Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet2".
**
** This function writes the given value to the index-th entry of the register
** array Packet2.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_841"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_841" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_841")))
#endif

void FREG_TSD3_SetPacket2( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_Packet2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_842"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_842" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_842")))
#endif

void FREG_TSD3_SetPacket2_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_Packet2Mirror[index] & ~mask;
    FREG_TSD3_Packet2Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKET2+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKET2+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet2".
**
** This function reads the value from the index-th entry of the register
** array Packet2.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_843"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_843" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_843")))
#endif

uint32_t FREG_TSD3_GetmPacket2( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_Packet2Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet2".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_844"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_844" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_844")))
#endif

uint32_t FREG_TSD3_GetmPacket2_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_Packet2Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Packet3".
**
** This function writes the given value to the index-th entry of the register
** array Packet3.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_845"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_845" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_845")))
#endif

void FREG_TSD3_SetPacket3( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    FREG_TSD3_Packet3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TspWord" of register "Packet3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_846"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_846" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_846")))
#endif

void FREG_TSD3_SetPacket3_TspWord( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_Packet3Mirror[index] & ~mask;
    FREG_TSD3_Packet3Mirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKET3+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKET3+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Packet3".
**
** This function reads the value from the index-th entry of the register
** array Packet3.
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_847"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_847" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_847")))
#endif

uint32_t FREG_TSD3_GetmPacket3( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 47 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_Packet3Mirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TspWord" of register "Packet3".
**
** The register addresses 0 to 46 corresponds to 47 words in a transport stream packet (TSP).
**  The data word is in big endian format.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "TspWord" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_848"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_848" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_848")))
#endif

uint32_t FREG_TSD3_GetmPacket3_TspWord( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 47 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_Packet3Mirror[index];
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PacketCtrl".
**
** This function writes the given value to the register "PacketCtrl".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_849"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_849" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_849")))
#endif

void FREG_TSD2_SetPacketCtrl( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid3" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_3 is valid.
**
** If the packet is valid, this bit group must be set to '111' to enable read out of PACKET_BUFFER_3.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_3.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid3" consists of the bits 14..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00007000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_850"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_850" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_850")))
#endif

void FREG_TSD2_SetPacketCtrl_PacketBufValid3( uint32_t value )
{
    register uint32_t mask = 0x00007000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid2" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_2 is valid.
**
** If the packet is valid, this bit group must be set to '110' to enable read out of PACKET_BUFFER_2.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_2.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid2" consists of the bits 10..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000700UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_851"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_851" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_851")))
#endif

void FREG_TSD2_SetPacketCtrl_PacketBufValid2( uint32_t value )
{
    register uint32_t mask = 0x00000700UL;
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid1" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_1 is valid.
**
** If the packet is valid, this bit group must be set to '101' to enable read out of PACKET_BUFFER_1.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_1.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid1" consists of the bits 6..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000070UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_852"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_852" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_852")))
#endif

void FREG_TSD2_SetPacketCtrl_PacketBufValid1( uint32_t value )
{
    register uint32_t mask = 0x00000070UL;
    value = ( value << 4 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid0" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_0 is valid.
**
** If the packet is valid, this bit group must be set to '100' to enable read out of PACKET_BUFFER_0.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_0.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid0" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_853"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_853" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_853")))
#endif

void FREG_TSD2_SetPacketCtrl_PacketBufValid0( uint32_t value )
{
    register uint32_t mask = 0x00000007UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketCtrl".
**
** This function reads the value from the register "PacketCtrl".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_854"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_854" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_854")))
#endif

uint32_t FREG_TSD2_GetPacketCtrl( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid3" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_3 is valid.
**
** If the packet is valid, this bit group must be set to '111' to enable read out of PACKET_BUFFER_3.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_3.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid3" consists of the bits 14..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00007000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_855"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_855" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_855")))
#endif

uint32_t FREG_TSD2_GetPacketCtrl_PacketBufValid3( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL));
    value = ( value & 0x00007000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid2" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_2 is valid.
**
** If the packet is valid, this bit group must be set to '110' to enable read out of PACKET_BUFFER_2.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_2.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid2" consists of the bits 10..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000700UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_856"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_856" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_856")))
#endif

uint32_t FREG_TSD2_GetPacketCtrl_PacketBufValid2( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL));
    value = ( value & 0x00000700UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid1" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_1 is valid.
**
** If the packet is valid, this bit group must be set to '101' to enable read out of PACKET_BUFFER_1.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_1.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid1" consists of the bits 6..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000070UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_857"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_857" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_857")))
#endif

uint32_t FREG_TSD2_GetPacketCtrl_PacketBufValid1( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL));
    value = ( value & 0x00000070UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid0" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_0 is valid.
**
** If the packet is valid, this bit group must be set to '100' to enable read out of PACKET_BUFFER_0.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_0.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid0" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_858"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_858" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_858")))
#endif

uint32_t FREG_TSD2_GetPacketCtrl_PacketBufValid0( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD2_PACKETCTRL));
    value = ( value & 0x00000007UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "PacketCtrl".
**
** This function writes the given value to the register "PacketCtrl".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_859"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_859" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_859")))
#endif

void FREG_TSD3_SetPacketCtrl( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid3" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_3 is valid.
**
** If the packet is valid, this bit group must be set to '111' to enable read out of PACKET_BUFFER_3.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_3.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid3" consists of the bits 14..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00007000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_860"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_860" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_860")))
#endif

void FREG_TSD3_SetPacketCtrl_PacketBufValid3( uint32_t value )
{
    register uint32_t mask = 0x00007000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid2" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_2 is valid.
**
** If the packet is valid, this bit group must be set to '110' to enable read out of PACKET_BUFFER_2.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_2.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid2" consists of the bits 10..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000700UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_861"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_861" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_861")))
#endif

void FREG_TSD3_SetPacketCtrl_PacketBufValid2( uint32_t value )
{
    register uint32_t mask = 0x00000700UL;
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid1" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_1 is valid.
**
** If the packet is valid, this bit group must be set to '101' to enable read out of PACKET_BUFFER_1.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_1.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid1" consists of the bits 6..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000070UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_862"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_862" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_862")))
#endif

void FREG_TSD3_SetPacketCtrl_PacketBufValid1( uint32_t value )
{
    register uint32_t mask = 0x00000070UL;
    value = ( value << 4 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PacketBufValid0" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_0 is valid.
**
** If the packet is valid, this bit group must be set to '100' to enable read out of PACKET_BUFFER_0.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_0.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PacketBufValid0" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_863"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_863" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_863")))
#endif

void FREG_TSD3_SetPacketCtrl_PacketBufValid0( uint32_t value )
{
    register uint32_t mask = 0x00000007UL;
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 4
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_PACKETCTRL, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "PacketCtrl".
**
** This function reads the value from the register "PacketCtrl".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_864"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_864" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_864")))
#endif

uint32_t FREG_TSD3_GetPacketCtrl( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid3" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_3 is valid.
**
** If the packet is valid, this bit group must be set to '111' to enable read out of PACKET_BUFFER_3.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_3.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid3" consists of the bits 14..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00007000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_865"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_865" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_865")))
#endif

uint32_t FREG_TSD3_GetPacketCtrl_PacketBufValid3( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL));
    value = ( value & 0x00007000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid2" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_2 is valid.
**
** If the packet is valid, this bit group must be set to '110' to enable read out of PACKET_BUFFER_2.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_2.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid2" consists of the bits 10..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000700UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_866"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_866" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_866")))
#endif

uint32_t FREG_TSD3_GetPacketCtrl_PacketBufValid2( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL));
    value = ( value & 0x00000700UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid1" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_1 is valid.
**
** If the packet is valid, this bit group must be set to '101' to enable read out of PACKET_BUFFER_1.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_1.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid1" consists of the bits 6..4,
**       the given bitgroup value will be shifted left by 4 bits and
**       masked using the bitmask 0x00000070UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_867"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_867" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_867")))
#endif

uint32_t FREG_TSD3_GetPacketCtrl_PacketBufValid1( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL));
    value = ( value & 0x00000070UL ) >> 4;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PacketBufValid0" of register "PacketCtrl".
**
** Indicates if the packet in PACKET_BUFFER_0 is valid.
**
** If the packet is valid, this bit group must be set to '100' to enable read out of PACKET_BUFFER_0.
** If the read value of this bit group is '000', new data can be written to PACKET_BUFFER_0.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "PacketBufValid0" consists of the bits 2..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x00000007UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_868"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_868" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_868")))
#endif

uint32_t FREG_TSD3_GetPacketCtrl_PacketBufValid0( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD3_PACKETCTRL));
    value = ( value & 0x00000007UL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Irq".
**
** This function reads the value from the register "Irq".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_869"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_869" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_869")))
#endif

uint32_t FREG_TSD23_GetIrq( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_IRQ));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "IrqFifoOvf" of register "Irq".
**
** Indicates if this IRQ FIFO overflows:
** - '0': not overflow.
**
** - '1': overflow.
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqFifoOvf" consists of the bits 29..29,
**       the given bitgroup value will be shifted left by 29 bits and
**       masked using the bitmask 0x20000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_870"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_870" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_870")))
#endif

uint32_t FREG_TSD23_ExtractIrq_IrqFifoOvf( uint32_t value )
{
    value = ( value & 0x20000000UL ) >> 29;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "IrqAvailable" of register "Irq".
**
** Indicates if IRQ is available:
** - '0': not available (IRQ FIFO is empty).
**
** - '1': available (IRQ FIFO is not empty).
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqAvailable" consists of the bits 28..28,
**       the given bitgroup value will be shifted left by 28 bits and
**       masked using the bitmask 0x10000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_871"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_871" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_871")))
#endif

uint32_t FREG_TSD23_ExtractIrq_IrqAvailable( uint32_t value )
{
    value = ( value & 0x10000000UL ) >> 28;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "FilterTargetIndex" of register "Irq".
**
** For SECTION_END_IRQ and CRC_ERROR_IRQ the FILTER_TARGET_INDEX indicates to which filter target the corresponding IRQ belongs.
**
** If N (N<=32) filter targets are defined for a PID channel (these filter targets are indexed from 0 to N-1) and the current section matches the filter target N, then the FILTER_TARGET_INDEX is set to N.
** For example, 32 filter targets are defined for a PID channel (these filter targets are indexed from 0 to 31).
** If the current section matches the filter target 0, then the FILTER_TARGET_INDEX is set to '00000' (decimal 0).
** If the current section matches the filter target 15, then the FILTER_TARGET_INDEX is set to '01111' (decimal 15).
**
** If the current section matches more than one filter targets,  then the FILTER_TARGET_INDEX is set to the lowest target index.
** For example, if a section matches the filter target 1, 2, 3, then the FILTER_TARGET_INDEX is set to '00001' (decimal 1).
**
** For all other IRQs the FILTER_TARGET_INDEX are constant '00000'.
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterTargetIndex" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_872"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_872" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_872")))
#endif

uint32_t FREG_TSD23_ExtractIrq_FilterTargetIndex( uint32_t value )
{
    value = ( value & 0x001F0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "IrqValue" of register "Irq".
**
** IRQ of TSD23
** Read access: return the next IRQ in the FIFO, the read pointer will be incremented.
**
**
** The IRQ  value and priority are defined below (the smaller the priority number is, the higher the priority. This means, TRANSPORT_ERROR_IRQ has the highest priority.)
** IRQ                                            Value      Priority
** SCRAMBLED_PACKET_IRQ      : 0xF2         8
** DUPLICATE_IRQ                       : 0xF1         8
** PCR_1_AF_LT_7_IRQ                : 0xF0        8
** PL_1_AF_GT183_IRQ                : 0xEF        8
** PL_0_AF_NE183_IRQ                : 0xEE        8
** TRANSPORT_ERROR_IRQ        : 0xED        0
** NULL_PACKET_IRQ                  : 0xEC        8
** NEW_PTS_IRQ_3                      : 0xEB        8
** NEW_PTS_IRQ_2                      : 0xEA        8
** NEW_PTS_IRQ_1                      : 0xE9        8
** NEW_PTS_IRQ_0                      : 0xE8        8
** PUS_IRQ                                  : 0xE7         8
** CRC_ERROR_IRQ                     : 0xE6         6
** NEW_PCR_IRQ                         : 0xE5         2
** CONTINUITY_CNT_ERROR_IRQ : 0xE4         1
** INPUT_TIMEOUT_IRQ                : 0xE3         5
** VALID_INPUT_TIMEOUT_IRQ      : 0xE2        4
** SECTION_END_IRQ                   : 0xE1         7
** PACKET_END_IRQ                    : 0xE0         3
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqValue" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_873"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_873" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_873")))
#endif

uint32_t FREG_TSD23_ExtractIrq_IrqValue( uint32_t value )
{
    value = ( value & 0x0000FF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "Tsd3Select" of register "Irq".
**
** Indicates if this IRQ is generated by TSD2 or TSD3.
**
** - '0': TSD2.
** - '1': TSD3.
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd3Select" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_874"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_874" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_874")))
#endif

uint32_t FREG_TSD23_ExtractIrq_Tsd3Select( uint32_t value )
{
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Extracts the bitgroup "PidIndex" of register "Irq".
**
** PID_INDEX, ranges from 0 to 31.
**
** \param value Register value to extract bitgroup from.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_875"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_875" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_875")))
#endif

uint32_t FREG_TSD23_ExtractIrq_PidIndex( uint32_t value )
{
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "IrqDbg".
**
** This function reads the value from the index-th entry of the register
** array IrqDbg.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_876"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_876" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_876")))
#endif

uint32_t FREG_TSD23_GetIrqDbg( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_IRQDBG+(index*0x4)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqFifoOvf" of register "IrqDbg".
**
** Indicates if this IRQ FIFO overflows:
** - '0': not overflow.
**
** - '1': overflow.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqFifoOvf" consists of the bits 29..29,
**       the given bitgroup value will be shifted left by 29 bits and
**       masked using the bitmask 0x20000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_877"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_877" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_877")))
#endif

uint32_t FREG_TSD23_GetIrqDbg_IrqFifoOvf( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_IRQDBG+(index*0x4)));
    value = ( value & 0x20000000UL ) >> 29;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqAvailable" of register "IrqDbg".
**
** Indicates if IRQ is available:
** - '0': not available (IRQ FIFO is empty).
**
** - '1': available (IRQ FIFO is not empty).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqAvailable" consists of the bits 28..28,
**       the given bitgroup value will be shifted left by 28 bits and
**       masked using the bitmask 0x10000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_878"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_878" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_878")))
#endif

uint32_t FREG_TSD23_GetIrqDbg_IrqAvailable( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_IRQDBG+(index*0x4)));
    value = ( value & 0x10000000UL ) >> 28;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterTargetIndex" of register "IrqDbg".
**
** For SECTION_END_IRQ and CRC_ERROR_IRQ the FILTER_TARGET_INDEX indicates to which filter target the corresponding IRQ belongs.
**
** If N (N<=32) filter targets are defined for a PID channel (these filter targets are indexed from 0 to N-1) and the current section matches the filter target N, then the FILTER_TARGET_INDEX is set to N.
** For example, 32 filter targets are defined for a PID channel (these filter targets are indexed from 0 to 31).
** If the current section matches the filter target 0, then the FILTER_TARGET_INDEX is set to '00000' (decimal 0).
** If the current section matches the filter target 15, then the FILTER_TARGET_INDEX is set to '01111' (decimal 15).
**
** If the current section matches more than one filter targets,  then the FILTER_TARGET_INDEX is set to the lowest target index.
** For example, if a section matches the filter target 1, 2, 3, then the FILTER_TARGET_INDEX is set to '00001' (decimal 1).
**
** For all other IRQs the FILTER_TARGET_INDEX are constant '00000'.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterTargetIndex" consists of the bits 20..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x001F0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_879"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_879" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_879")))
#endif

uint32_t FREG_TSD23_GetIrqDbg_FilterTargetIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_IRQDBG+(index*0x4)));
    value = ( value & 0x001F0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqValue" of register "IrqDbg".
**
** IRQ of TSD23.
**  Read the TSD23_IRQ for debug. The internal read pointer will NOT be incremented
**
** The IRQ  value and priority are defined below (the smaller the priority number is, the higher the priority. This means, TRANSPORT_ERROR_IRQ has the highest priority.)
** IRQ                                            Value      Priority
** SCRAMBLED_PACKET_IRQ      : 0xF2         8
** DUPLICATE_IRQ                       : 0xF1         8
** PCR_1_AF_LT_7_IRQ                : 0xF0         8
** PL_1_AF_GT183_IRQ                : 0xEF         8
** PL_0_AF_NE183_IRQ                : 0xEE         8
** TRANSPORT_ERROR_IRQ        : 0xED         0
** NULL_PACKET_IRQ                  : 0xEC        8
** NEW_PTS_IRQ_3                      : 0xEB        8
** NEW_PTS_IRQ_2                      : 0xEA        8
** NEW_PTS_IRQ_1                      : 0xE9        8
** NEW_PTS_IRQ_0                      : 0xE8        8
** PUS_IRQ                                  : 0xE7         8
** CRC_ERROR_IRQ                     : 0xE6         6
** NEW_PCR_IRQ                         : 0xE5         2
** CONTINUITY_CNT_ERROR_IRQ : 0xE4         1
** INPUT_TIMEOUT_IRQ                : 0xE3         5
** VALID_INPUT_TIMEOUT_IRQ      : 0xE2        4
** SECTION_END_IRQ                   : 0xE1         7
** PACKET_END_IRQ                    : 0xE0         3
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqValue" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_880"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_880" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_880")))
#endif

uint32_t FREG_TSD23_GetIrqDbg_IrqValue( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_IRQDBG+(index*0x4)));
    value = ( value & 0x0000FF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Tsd3Select" of register "IrqDbg".
**
** Indicates if this IRQ is generated by TSD2 or TSD3.
**
** - '0': TSD2.
** - '1': TSD3.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Tsd3Select" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_881"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_881" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_881")))
#endif

uint32_t FREG_TSD23_GetIrqDbg_Tsd3Select( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_IRQDBG+(index*0x4)));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PidIndex" of register "IrqDbg".
**
** PID_INDEX, ranges from 0 to 31.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PidIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_882"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_882" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_882")))
#endif

uint32_t FREG_TSD23_GetIrqDbg_PidIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 64 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD23_IRQDBG+(index*0x4)));
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "IrqRdPtr".
**
** This function reads the value from the register "IrqRdPtr".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_883"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_883" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_883")))
#endif

uint32_t FREG_TSD23_GetIrqRdPtr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_IRQRDPTR));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqRdPtr" of register "IrqRdPtr".
**
** The read pointer of the TSD23 IRQ FIFO.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqRdPtr" consists of the bits 5..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000003FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_884"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_884" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_884")))
#endif

uint32_t FREG_TSD23_GetIrqRdPtr_IrqRdPtr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_IRQRDPTR));
    value = ( value & 0x0000003FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "IrqWrPtr".
**
** This function reads the value from the register "IrqWrPtr".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_885"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_885" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_885")))
#endif

uint32_t FREG_TSD23_GetIrqWrPtr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_IRQWRPTR));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "IrqWrPtr" of register "IrqWrPtr".
**
** The write pointer of the TSD23 IRQ FIFO.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "IrqWrPtr" consists of the bits 5..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000003FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_886"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_886" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_886")))
#endif

uint32_t FREG_TSD23_GetIrqWrPtr_IrqWrPtr( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_IRQWRPTR));
    value = ( value & 0x0000003FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "IrqClear".
**
** This function writes the given value to the register "IrqClear".
**
** All IRQs in the IRQ-FIFO will be cleared if this register is written (no matter what value).
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_887"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_887" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_887")))
#endif

void FREG_TSD23_SetIrqClear( uint32_t value )
{
    FREG_TSD23_IrqClearMirror = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_IRQCLEAR, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_IRQCLEAR)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ClearAllIrq" of register "IrqClear".
**
** All IRQs in the IRQ-FIFO will be cleared if this register is written (no matter what value).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ClearAllIrq" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_888"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_888" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_888")))
#endif

void FREG_TSD23_SetIrqClear_ClearAllIrq( uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    value = ( value << 0 ) & mask;
    value |= FREG_TSD23_IrqClearMirror & ~mask;
    FREG_TSD23_IrqClearMirror = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_IRQCLEAR, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_IRQCLEAR)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "IrqClear".
**
** This function reads the value from the register "IrqClear".
**
** All IRQs in the IRQ-FIFO will be cleared if this register is written (no matter what value).
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_889"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_889" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_889")))
#endif

uint32_t FREG_TSD23_GetmIrqClear( void )
{
    register uint32_t value = FREG_TSD23_IrqClearMirror;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ClearAllIrq" of register "IrqClear".
**
** All IRQs in the IRQ-FIFO will be cleared if this register is written (no matter what value).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "ClearAllIrq" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_890"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_890" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_890")))
#endif

uint32_t FREG_TSD23_GetmIrqClear_ClearAllIrq( void )
{
    register uint32_t value = FREG_TSD23_IrqClearMirror;
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SbCtrl".
**
** This function writes the given value to the index-th entry of the register
** array SbCtrl.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_891"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_891" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_891")))
#endif

void FREG_TSD2_SetSbCtrl( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "WrPtr" of register "SbCtrl".
**
** Write pointer of the section header buffer
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "WrPtr" consists of the bits 31..26,
**       the given bitgroup value will be shifted left by 26 bits and
**       masked using the bitmask 0xFC000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_892"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_892" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_892")))
#endif

void FREG_TSD2_SetSbCtrl_WrPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFC000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 26 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "RdPtr" of register "SbCtrl".
**
** Read pointer of the section header buffer
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "RdPtr" consists of the bits 25..20,
**       the given bitgroup value will be shifted left by 20 bits and
**       masked using the bitmask 0x03F00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_893"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_893" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_893")))
#endif

void FREG_TSD2_SetSbCtrl_RdPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x03F00000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 20 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ResidueCnt" of register "SbCtrl".
**
** The number of remaining data bytes of the corresponding target.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ResidueCnt" consists of the bits 19..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x000FFF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_894"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_894" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_894")))
#endif

void FREG_TSD2_SetSbCtrl_ResidueCnt( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000FFF00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PaddingCnt" of register "SbCtrl".
**
** The number of padding bytes needed for the current section.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PaddingCnt" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_895"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_895" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_895")))
#endif

void FREG_TSD2_SetSbCtrl_PaddingCnt( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000000C0UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterMatch" of register "SbCtrl".
**
** Indicates if the current section matches any filter target.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterMatch" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_896"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_896" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_896")))
#endif

void FREG_TSD2_SetSbCtrl_FilterMatch( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterIndex" of register "SbCtrl".
**
** The index of the matched filter.
**  If a section matches multiple filter targets, the smallest filter target indext is stored. For example, if a section matches the target 3, target 7 and target 15, FILTER_INDEX is set to 00011 (decimal 3).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_897"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_897" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_897")))
#endif

void FREG_TSD2_SetSbCtrl_FilterIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000001FUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SbCtrl".
**
** This function reads the value from the index-th entry of the register
** array SbCtrl.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_898"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_898" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_898")))
#endif

uint32_t FREG_TSD2_GetSbCtrl( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "WrPtr" of register "SbCtrl".
**
** Write pointer of the section header buffer
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "WrPtr" consists of the bits 31..26,
**       the given bitgroup value will be shifted left by 26 bits and
**       masked using the bitmask 0xFC000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_899"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_899" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_899")))
#endif

uint32_t FREG_TSD2_GetSbCtrl_WrPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8)));
    value = ( value & 0xFC000000UL ) >> 26;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "RdPtr" of register "SbCtrl".
**
** Read pointer of the section header buffer
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "RdPtr" consists of the bits 25..20,
**       the given bitgroup value will be shifted left by 20 bits and
**       masked using the bitmask 0x03F00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_900"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_900" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_900")))
#endif

uint32_t FREG_TSD2_GetSbCtrl_RdPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8)));
    value = ( value & 0x03F00000UL ) >> 20;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ResidueCnt" of register "SbCtrl".
**
** The number of remaining data bytes of the corresponding target.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ResidueCnt" consists of the bits 19..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x000FFF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_901"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_901" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_901")))
#endif

uint32_t FREG_TSD2_GetSbCtrl_ResidueCnt( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8)));
    value = ( value & 0x000FFF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PaddingCnt" of register "SbCtrl".
**
** The number of padding bytes needed for the current section.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PaddingCnt" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_902"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_902" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_902")))
#endif

uint32_t FREG_TSD2_GetSbCtrl_PaddingCnt( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8)));
    value = ( value & 0x000000C0UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterMatch" of register "SbCtrl".
**
** Indicates if the current section matches any filter target.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterMatch" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_903"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_903" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_903")))
#endif

uint32_t FREG_TSD2_GetSbCtrl_FilterMatch( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8)));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterIndex" of register "SbCtrl".
**
** The index of the matched filter.
**  If a section matches multiple filter targets, the smallest filter target indext is stored. For example, if a section matches the target 3, target 7 and target 15, FILTER_INDEX is set to 00011 (decimal 3).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_904"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_904" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_904")))
#endif

uint32_t FREG_TSD2_GetSbCtrl_FilterIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_SBCTRL+(index*0x8)));
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Crc".
**
** This function writes the given value to the index-th entry of the register
** array Crc.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_905"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_905" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_905")))
#endif

void FREG_TSD2_SetCrc( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_CRC+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_CRC+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Crc" of register "Crc".
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Crc" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_906"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_906" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_906")))
#endif

void FREG_TSD2_SetCrc_Crc( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD2_CRC+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_CRC+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_CRC+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Crc".
**
** This function reads the value from the index-th entry of the register
** array Crc.
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_907"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_907" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_907")))
#endif

uint32_t FREG_TSD2_GetCrc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_CRC+(index*0x8)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Crc" of register "Crc".
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Crc" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_908"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_908" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_908")))
#endif

uint32_t FREG_TSD2_GetCrc_Crc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD2_CRC+(index*0x8)));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfActive".
**
** This function reads the value from the register "SfActive".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_909"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_909" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_909")))
#endif

uint32_t FREG_TSD2_GetSfActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD2_SFACTIVE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SfActive" of register "SfActive".
**
** Each bit indicates if Section Filter (SF) of the corresponding PID in TSD2 is active (bit n corresponds to PID channel n).
**
** - '0': not active.
** - '1': active.
** Section Filter is active, if the section comparison can't be started because the so far collected section bytes are not enough (less than the configured section filter Target Length) or the section comparison is finished but the section end is not reached yet.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "SfActive" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_910"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_910" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_910")))
#endif

uint32_t FREG_TSD2_GetSfActive_SfActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD2_SFACTIVE));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SbCtrl".
**
** This function writes the given value to the index-th entry of the register
** array SbCtrl.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_911"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_911" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_911")))
#endif

void FREG_TSD3_SetSbCtrl( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "WrPtr" of register "SbCtrl".
**
** Write pointer of the section header buffer
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "WrPtr" consists of the bits 31..26,
**       the given bitgroup value will be shifted left by 26 bits and
**       masked using the bitmask 0xFC000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_912"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_912" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_912")))
#endif

void FREG_TSD3_SetSbCtrl_WrPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFC000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 26 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "RdPtr" of register "SbCtrl".
**
** Read pointer of the section header buffer
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "RdPtr" consists of the bits 25..20,
**       the given bitgroup value will be shifted left by 20 bits and
**       masked using the bitmask 0x03F00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_913"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_913" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_913")))
#endif

void FREG_TSD3_SetSbCtrl_RdPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x03F00000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 20 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "ResidueCnt" of register "SbCtrl".
**
** The number of remaining data bytes of the corresponding target.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "ResidueCnt" consists of the bits 19..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x000FFF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_914"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_914" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_914")))
#endif

void FREG_TSD3_SetSbCtrl_ResidueCnt( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000FFF00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "PaddingCnt" of register "SbCtrl".
**
** The number of padding bytes needed for the current section.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "PaddingCnt" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_915"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_915" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_915")))
#endif

void FREG_TSD3_SetSbCtrl_PaddingCnt( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000000C0UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 6 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterMatch" of register "SbCtrl".
**
** Indicates if the current section matches any filter target.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterMatch" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_916"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_916" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_916")))
#endif

void FREG_TSD3_SetSbCtrl_FilterMatch( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000020UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 5 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterIndex" of register "SbCtrl".
**
** The index of the matched filter.
**  If a section matches multiple filter targets, the smallest filter target indext is stored. For example, if a section matches the target 3, target 7 and target 15, FILTER_INDEX is set to 00011 (decimal 3).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_917"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_917" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_917")))
#endif

void FREG_TSD3_SetSbCtrl_FilterIndex( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000001FUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 6
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SBCTRL+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SbCtrl".
**
** This function reads the value from the index-th entry of the register
** array SbCtrl.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_918"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_918" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_918")))
#endif

uint32_t FREG_TSD3_GetSbCtrl( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "WrPtr" of register "SbCtrl".
**
** Write pointer of the section header buffer
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "WrPtr" consists of the bits 31..26,
**       the given bitgroup value will be shifted left by 26 bits and
**       masked using the bitmask 0xFC000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_919"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_919" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_919")))
#endif

uint32_t FREG_TSD3_GetSbCtrl_WrPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8)));
    value = ( value & 0xFC000000UL ) >> 26;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "RdPtr" of register "SbCtrl".
**
** Read pointer of the section header buffer
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "RdPtr" consists of the bits 25..20,
**       the given bitgroup value will be shifted left by 20 bits and
**       masked using the bitmask 0x03F00000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_920"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_920" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_920")))
#endif

uint32_t FREG_TSD3_GetSbCtrl_RdPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8)));
    value = ( value & 0x03F00000UL ) >> 20;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "ResidueCnt" of register "SbCtrl".
**
** The number of remaining data bytes of the corresponding target.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "ResidueCnt" consists of the bits 19..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x000FFF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_921"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_921" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_921")))
#endif

uint32_t FREG_TSD3_GetSbCtrl_ResidueCnt( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8)));
    value = ( value & 0x000FFF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "PaddingCnt" of register "SbCtrl".
**
** The number of padding bytes needed for the current section.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "PaddingCnt" consists of the bits 7..6,
**       the given bitgroup value will be shifted left by 6 bits and
**       masked using the bitmask 0x000000C0UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_922"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_922" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_922")))
#endif

uint32_t FREG_TSD3_GetSbCtrl_PaddingCnt( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8)));
    value = ( value & 0x000000C0UL ) >> 6;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterMatch" of register "SbCtrl".
**
** Indicates if the current section matches any filter target.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterMatch" consists of the bits 5..5,
**       the given bitgroup value will be shifted left by 5 bits and
**       masked using the bitmask 0x00000020UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_923"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_923" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_923")))
#endif

uint32_t FREG_TSD3_GetSbCtrl_FilterMatch( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8)));
    value = ( value & 0x00000020UL ) >> 5;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterIndex" of register "SbCtrl".
**
** The index of the matched filter.
**  If a section matches multiple filter targets, the smallest filter target indext is stored. For example, if a section matches the target 3, target 7 and target 15, FILTER_INDEX is set to 00011 (decimal 3).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterIndex" consists of the bits 4..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000001FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_924"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_924" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_924")))
#endif

uint32_t FREG_TSD3_GetSbCtrl_FilterIndex( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_SBCTRL+(index*0x8)));
    value = ( value & 0x0000001FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "Crc".
**
** This function writes the given value to the index-th entry of the register
** array Crc.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_925"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_925" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_925")))
#endif

void FREG_TSD3_SetCrc( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_CRC+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_CRC+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Crc" of register "Crc".
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Crc" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_926"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_926" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_926")))
#endif

void FREG_TSD3_SetCrc_Crc( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFFFFFFFFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    #define REGISTER_BITGROUP_COUNT 1
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD3_CRC+(index*0x8))) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_CRC+(index*0x8), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_CRC+(index*0x8))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "Crc".
**
** This function reads the value from the index-th entry of the register
** array Crc.
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_927"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_927" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_927")))
#endif

uint32_t FREG_TSD3_GetCrc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_CRC+(index*0x8)));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Crc" of register "Crc".
**
** The CRC calculated for the section bytes received so far.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Crc" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_928"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_928" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_928")))
#endif

uint32_t FREG_TSD3_GetCrc_Crc( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 32 )
            return( 0xFFFFFFFFUL );
    #endif
    value = *((volatile uint32_t*)(FREG_TSD3_CRC+(index*0x8)));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfActive".
**
** This function reads the value from the register "SfActive".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_929"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_929" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_929")))
#endif

uint32_t FREG_TSD3_GetSfActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD3_SFACTIVE));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SfActive" of register "SfActive".
**
** Each bit indicates if Section Filter (SF) of the corresponding PID in TSD3 is active (bit n corresponds to PID channel n).
**
** - '0': not active.
** - '1': active.
** Section Filter is active, if the section comparison can't be started because the so far collected section bytes are not enough (less than the configured section filter Target Length) or the section comparison is finished but the section end is not reached yet.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "SfActive" consists of the bits 31..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0xFFFFFFFFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_930"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_930" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_930")))
#endif

uint32_t FREG_TSD3_GetSfActive_SfActive( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD3_SFACTIVE));
    value = ( value & 0xFFFFFFFFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SfTargets".
**
** This function writes the given value to the index-th entry of the register
** array SfTargets.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_931"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_931" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_931")))
#endif

void FREG_TSD2_SetSfTargets( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    FREG_TSD2_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SecData0" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SecData0" consists of the bits 31..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0xFF000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_932"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_932" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_932")))
#endif

void FREG_TSD2_SetSfTargets_SecData0( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFF000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 24 ) & mask;
    value |= FREG_TSD2_SfTargetsMirror[index] & ~mask;
    FREG_TSD2_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterEnable0" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_0 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [31:24] are DATA and [23:16] are ENABLE, these 16 bits together ([31:16]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterEnable0" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_933"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_933" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_933")))
#endif

void FREG_TSD2_SetSfTargets_FilterEnable0( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00FF0000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD2_SfTargetsMirror[index] & ~mask;
    FREG_TSD2_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SecData1" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SecData1" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_934"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_934" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_934")))
#endif

void FREG_TSD2_SetSfTargets_SecData1( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000FF00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD2_SfTargetsMirror[index] & ~mask;
    FREG_TSD2_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterEnable1" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_1 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [15:8] are DATA and [7:0] are ENABLE, these 16 bits together ([15:0]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterEnable1" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_935"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_935" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_935")))
#endif

void FREG_TSD2_SetSfTargets_FilterEnable1( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000000FFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_SfTargetsMirror[index] & ~mask;
    FREG_TSD2_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfTargets".
**
** This function reads the value from the index-th entry of the register
** array SfTargets.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_936"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_936" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_936")))
#endif

uint32_t FREG_TSD2_GetmSfTargets( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_SfTargetsMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SecData0" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SecData0" consists of the bits 31..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0xFF000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_937"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_937" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_937")))
#endif

uint32_t FREG_TSD2_GetmSfTargets_SecData0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_SfTargetsMirror[index];
    value = ( value & 0xFF000000UL ) >> 24;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterEnable0" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_0 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [31:24] are DATA and [23:16] are ENABLE, these 16 bits together ([31:16]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterEnable0" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_938"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_938" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_938")))
#endif

uint32_t FREG_TSD2_GetmSfTargets_FilterEnable0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_SfTargetsMirror[index];
    value = ( value & 0x00FF0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SecData1" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SecData1" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_939"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_939" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_939")))
#endif

uint32_t FREG_TSD2_GetmSfTargets_SecData1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_SfTargetsMirror[index];
    value = ( value & 0x0000FF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterEnable1" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_1 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [15:8] are DATA and [7:0] are ENABLE, these 16 bits together ([15:0]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterEnable1" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_940"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_940" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_940")))
#endif

uint32_t FREG_TSD2_GetmSfTargets_FilterEnable1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_SfTargetsMirror[index];
    value = ( value & 0x000000FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SfPtr".
**
** This function writes the given value to the index-th entry of the register
** array SfPtr.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_941"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_941" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_941")))
#endif

void FREG_TSD2_SetSfPtr( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    FREG_TSD2_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Eol" of register "SfPtr".
**
** End of List flag.
**
** - '1': The corresponding RAM line is the End of filter
** target.
** - '0': Not End of List. The NXT_DEP_PTR below points
** to the next DEP (Data Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Eol" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_942"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_942" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_942")))
#endif

void FREG_TSD2_SetSfPtr_Eol( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD2_SfPtrMirror[index] & ~mask;
    FREG_TSD2_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NxtDepPtr" of register "SfPtr".
**
** If EOL = '1', NXT_DEP_PTR must be set to 0x00.
**
** If EOL = '0', set NXT_DEP_PTR to the line number of next DEP. If NXT_DEP_PTR is set to 0, this means the corresponding RAM line is availabe.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NxtDepPtr" consists of the bits 6..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000007FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_943"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_943" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_943")))
#endif

void FREG_TSD2_SetSfPtr_NxtDepPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000007FUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD2_SfPtrMirror[index] & ~mask;
    FREG_TSD2_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD2_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD2_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfPtr".
**
** This function reads the value from the index-th entry of the register
** array SfPtr.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_944"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_944" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_944")))
#endif

uint32_t FREG_TSD2_GetmSfPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_SfPtrMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Eol" of register "SfPtr".
**
** End of List flag.
**
** - '1': The corresponding RAM line is the End of filter
** target.
** - '0': Not End of List. The NXT_DEP_PTR below points
** to the next DEP (Data Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Eol" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_945"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_945" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_945")))
#endif

uint32_t FREG_TSD2_GetmSfPtr_Eol( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 128 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_SfPtrMirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NxtDepPtr" of register "SfPtr".
**
** If EOL = '1', NXT_DEP_PTR must be set to 0x00.
**
** If EOL = '0', set NXT_DEP_PTR to the line number of next DEP. If NXT_DEP_PTR is set to 0, this means the corresponding RAM line is availabe.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NxtDepPtr" consists of the bits 6..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000007FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_946"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_946" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_946")))
#endif

uint32_t FREG_TSD2_GetmSfPtr_NxtDepPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 128 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD2_SfPtrMirror[index];
    value = ( value & 0x0000007FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SfTargets".
**
** This function writes the given value to the index-th entry of the register
** array SfTargets.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_947"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_947" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_947")))
#endif

void FREG_TSD3_SetSfTargets( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    FREG_TSD3_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SecData0" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SecData0" consists of the bits 31..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0xFF000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_948"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_948" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_948")))
#endif

void FREG_TSD3_SetSfTargets_SecData0( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0xFF000000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 24 ) & mask;
    value |= FREG_TSD3_SfTargetsMirror[index] & ~mask;
    FREG_TSD3_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterEnable0" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_0 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [31:24] are DATA and [23:16] are ENABLE, these 16 bits together ([31:16]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterEnable0" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_949"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_949" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_949")))
#endif

void FREG_TSD3_SetSfTargets_FilterEnable0( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00FF0000UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 16 ) & mask;
    value |= FREG_TSD3_SfTargetsMirror[index] & ~mask;
    FREG_TSD3_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "SecData1" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "SecData1" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_950"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_950" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_950")))
#endif

void FREG_TSD3_SetSfTargets_SecData1( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000FF00UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 8 ) & mask;
    value |= FREG_TSD3_SfTargetsMirror[index] & ~mask;
    FREG_TSD3_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "FilterEnable1" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_1 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [15:8] are DATA and [7:0] are ENABLE, these 16 bits together ([15:0]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "FilterEnable1" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_951"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_951" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_951")))
#endif

void FREG_TSD3_SetSfTargets_FilterEnable1( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x000000FFUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_SfTargetsMirror[index] & ~mask;
    FREG_TSD3_SfTargetsMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SFTARGETS+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SFTARGETS+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfTargets".
**
** This function reads the value from the index-th entry of the register
** array SfTargets.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_952"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_952" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_952")))
#endif

uint32_t FREG_TSD3_GetmSfTargets( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 256 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_SfTargetsMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SecData0" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SecData0" consists of the bits 31..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0xFF000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_953"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_953" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_953")))
#endif

uint32_t FREG_TSD3_GetmSfTargets_SecData0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_SfTargetsMirror[index];
    value = ( value & 0xFF000000UL ) >> 24;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterEnable0" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_0 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [31:24] are DATA and [23:16] are ENABLE, these 16 bits together ([31:16]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterEnable0" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_954"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_954" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_954")))
#endif

uint32_t FREG_TSD3_GetmSfTargets_FilterEnable0( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_SfTargetsMirror[index];
    value = ( value & 0x00FF0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "SecData1" of register "SfTargets".
**
** Section data expected.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "SecData1" consists of the bits 15..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x0000FF00UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_955"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_955" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_955")))
#endif

uint32_t FREG_TSD3_GetmSfTargets_SecData1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_SfTargetsMirror[index];
    value = ( value & 0x0000FF00UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "FilterEnable1" of register "SfTargets".
**
**  - '1': Enables the corresponding SEC_DATA_1 bit to be
** compared with the incoming section data bit.
**
** - '0': Disable the comparison.
**
** Bits [15:8] are DATA and [7:0] are ENABLE, these 16 bits together ([15:0]) are referred to as a DEP (Data-Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "FilterEnable1" consists of the bits 7..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x000000FFUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_956"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_956" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_956")))
#endif

uint32_t FREG_TSD3_GetmSfTargets_FilterEnable1( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 256 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_SfTargetsMirror[index];
    value = ( value & 0x000000FFUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "SfPtr".
**
** This function writes the given value to the index-th entry of the register
** array SfPtr.
**
** \param index Array index to access.
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_957"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_957" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_957")))
#endif

void FREG_TSD3_SetSfPtr( uint32_t index, uint32_t value )
{
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    FREG_TSD3_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "Eol" of register "SfPtr".
**
** End of List flag.
**
** - '1': The corresponding RAM line is the End of filter
** target.
** - '0': Not End of List. The corresponding NXT_DEP_PTR
** points to the next DEP (Data Enable Pair).
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "Eol" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_958"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_958" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_958")))
#endif

void FREG_TSD3_SetSfPtr_Eol( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x00000080UL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    value = ( value << 7 ) & mask;
    value |= FREG_TSD3_SfPtrMirror[index] & ~mask;
    FREG_TSD3_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "NxtDepPtr" of register "SfPtr".
**
** If EOL = '1', NXT_DEP_PTR must be set to 0x00.
**
** If EOL = '0', set NXT_DEP_PTR to the line number of next DEP. If NXT_DEP_PTR is set to 0, this means the corresponding RAM line is availabe.
**
** \param index Array index to access.
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "NxtDepPtr" consists of the bits 6..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000007FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_959"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_959" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_959")))
#endif

void FREG_TSD3_SetSfPtr_NxtDepPtr( uint32_t index, uint32_t value )
{
    register uint32_t mask = 0x0000007FUL;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return;
    #endif
    value = ( value << 0 ) & mask;
    value |= FREG_TSD3_SfPtrMirror[index] & ~mask;
    FREG_TSD3_SfPtrMirror[index] = value;
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD3_SFPTR+(index*0x4), value );
    #endif
    *((volatile uint32_t*)(FREG_TSD3_SFPTR+(index*0x4))) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "SfPtr".
**
** This function reads the value from the index-th entry of the register
** array SfPtr.
**
**
**
** \param index Array index to access.
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_960"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_960" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_960")))
#endif

uint32_t FREG_TSD3_GetmSfPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
        if( index >= 128 )
            return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_SfPtrMirror[index];
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "Eol" of register "SfPtr".
**
** End of List flag.
**
** - '1': The corresponding RAM line is the End of filter
** target.
** - '0': Not End of List. The corresponding NXT_DEP_PTR
** points to the next DEP (Data Enable Pair).
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "Eol" consists of the bits 7..7,
**       the given bitgroup value will be shifted left by 7 bits and
**       masked using the bitmask 0x00000080UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_961"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_961" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_961")))
#endif

uint32_t FREG_TSD3_GetmSfPtr_Eol( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 128 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_SfPtrMirror[index];
    value = ( value & 0x00000080UL ) >> 7;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "NxtDepPtr" of register "SfPtr".
**
** If EOL = '1', NXT_DEP_PTR must be set to 0x00.
**
** If EOL = '0', set NXT_DEP_PTR to the line number of next DEP. If NXT_DEP_PTR is set to 0, this means the corresponding RAM line is availabe.
**
** \param index Array index to access.
** \return Read bitgroup value.
**
** \note internally the bitgroup "NxtDepPtr" consists of the bits 6..0,
**       the given bitgroup value will be shifted left by 0 bits and
**       masked using the bitmask 0x0000007FUL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_962"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_962" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_962")))
#endif

uint32_t FREG_TSD3_GetmSfPtr_NxtDepPtr( uint32_t index )
{
    register uint32_t value;
    #if defined(FREG_CHECK_INDEX)
    if( index >= 128 )
        return( 0xFFFFFFFFUL );
    #endif
    value = FREG_TSD3_SfPtrMirror[index];
    value = ( value & 0x0000007FUL ) >> 0;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "InRamCfg".
**
** This function writes the given value to the register "InRamCfg".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_963"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_963" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_963")))
#endif

void FREG_TSD01_SetInRamCfg( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TsOutMode" of register "InRamCfg".
**
** TS output generation mode.
**  This bit group selects the source for TS_OUT_CLK, TS_OUT_EN, TS_OUT_START and TS_OUT_DATA:
** - '00': Normal mode. Select data from TSD1_input_buffer and generate TS_OUT_CLK, TS_OUT_EN and TS_OUT_START. (In this mode, the bit group GENERATE_SYNC_SIGNAL must be set to '11').
** - '01': TSD0 pass mode. Select data from TS_input_0. All data fed into TSD0_input_buffer (including TS_CLK, TS_EN, TS_START) will be directly sent to TS_OUT.
** - '10': TSD1 pass mode. Select data from TS_input_1. All data fed into TSD1_input_buffer (including TS_CLK, TS_EN, TS_START) will be directly sent to TS_OUT.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TsOutMode" consists of the bits 31..30,
**       the given bitgroup value will be shifted left by 30 bits and
**       masked using the bitmask 0xC0000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_964"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_964" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_964")))
#endif

void FREG_TSD01_SetInRamCfg_TsOutMode( uint32_t value )
{
    register uint32_t mask = 0xC0000000UL;
    value = ( value << 30 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InvertTsOutClk" of register "InRamCfg".
**
** Indicates if TS_OUT_CLK shall be inverted.
**
** - '0': Don't invert.
** - '1': Invert.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InvertTsOutClk" consists of the bits 29..29,
**       the given bitgroup value will be shifted left by 29 bits and
**       masked using the bitmask 0x20000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_965"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_965" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_965")))
#endif

void FREG_TSD01_SetInRamCfg_InvertTsOutClk( uint32_t value )
{
    register uint32_t mask = 0x20000000UL;
    value = ( value << 29 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "GenerateSyncSignal" of register "InRamCfg".
**
** Enables the geneation of TS synchronization signals like TS_OUT_EN, TS_OUT_START and TS_OUT_CLK.
**
** - '00': Don't generate TS_OUT_EN, TS_OUT_START.
** - '11': Generate TS_OUT_EN, TS_OUT_START.
** This bit group must be set to '11' in normal mode. It is not necessary to set this bit group in TSD0 pass mode and TSD1 pass mode.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "GenerateSyncSignal" consists of the bits 25..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0x03000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_966"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_966" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_966")))
#endif

void FREG_TSD01_SetInRamCfg_GenerateSyncSignal( uint32_t value )
{
    register uint32_t mask = 0x03000000UL;
    value = ( value << 24 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TsOutClkPrescaler" of register "InRamCfg".
**
** Prescaler to generate TS_OUT_CLK based upon the clock domain 162MHz.
**  The frequency of TS_OUT_CLK equals to 162/[2*(TS_OUT_CLK_PRESCALER+1)] MHz. For example, if TS_OUT_CLK_PRESCALER is set to 80, the TS_OUT_CLK will be 162/[2*(80+1)] = 162/162 = 1MHz. This bit group is only considered in normal mode (i.e., it is not necessary to set this bit group in TSD0 pass mode and TSD1 pass mode).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TsOutClkPrescaler" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_967"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_967" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_967")))
#endif

void FREG_TSD01_SetInRamCfg_TsOutClkPrescaler( uint32_t value )
{
    register uint32_t mask = 0x00FF0000UL;
    value = ( value << 16 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InputBufferOfIrqEn" of register "InRamCfg".
**
** Input buffer overflow IRQ enable.
**
** - '0': disabled.
** - '1': enabled.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InputBufferOfIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_968"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_968" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_968")))
#endif

void FREG_TSD01_SetInRamCfg_InputBufferOfIrqEn( uint32_t value )
{
    register uint32_t mask = 0x00001000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DisableTsInput1" of register "InRamCfg".
**
** Indicates if TS_input_1 shall be disabled.
**
** - '0': enabled.
** - '1': disabled.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DisableTsInput1" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_969"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_969" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_969")))
#endif

void FREG_TSD01_SetInRamCfg_DisableTsInput1( uint32_t value )
{
    register uint32_t mask = 0x00000200UL;
    value = ( value << 9 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DisableTsInput0" of register "InRamCfg".
**
** Indicates if TS_input_0 shall be disabled.
**
** - '0': enabled.
** - '1': disabled.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DisableTsInput0" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_970"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_970" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_970")))
#endif

void FREG_TSD01_SetInRamCfg_DisableTsInput0( uint32_t value )
{
    register uint32_t mask = 0x00000100UL;
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD01_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD01_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "InRamCfg".
**
** This function reads the value from the register "InRamCfg".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_971"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_971" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_971")))
#endif

uint32_t FREG_TSD01_GetInRamCfg( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INRAMCFG));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TsOutMode" of register "InRamCfg".
**
** TS output generation mode.
**  This bit group selects the source for TS_OUT_CLK, TS_OUT_EN, TS_OUT_START and TS_OUT_DATA:
** - '00': Normal mode. Select data from TSD1_input_buffer and generate TS_OUT_CLK, TS_OUT_EN and TS_OUT_START. (In this mode, the bit group GENERATE_SYNC_SIGNAL must be set to '11').
** - '01': TSD0 pass mode. Select data from TS_input_0. All data fed into TSD0_input_buffer (including TS_CLK, TS_EN, TS_START) will be directly sent to TS_OUT.
** - '10': TSD1 pass mode. Select data from TS_input_1. All data fed into TSD1_input_buffer (including TS_CLK, TS_EN, TS_START) will be directly sent to TS_OUT.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "TsOutMode" consists of the bits 31..30,
**       the given bitgroup value will be shifted left by 30 bits and
**       masked using the bitmask 0xC0000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_972"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_972" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_972")))
#endif

uint32_t FREG_TSD01_GetInRamCfg_TsOutMode( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INRAMCFG));
    value = ( value & 0xC0000000UL ) >> 30;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InvertTsOutClk" of register "InRamCfg".
**
** Indicates if TS_OUT_CLK shall be inverted.
**
** - '0': Don't invert.
** - '1': Invert.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "InvertTsOutClk" consists of the bits 29..29,
**       the given bitgroup value will be shifted left by 29 bits and
**       masked using the bitmask 0x20000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_973"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_973" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_973")))
#endif

uint32_t FREG_TSD01_GetInRamCfg_InvertTsOutClk( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INRAMCFG));
    value = ( value & 0x20000000UL ) >> 29;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "GenerateSyncSignal" of register "InRamCfg".
**
** Enables the geneation of TS synchronization signals like TS_OUT_EN, TS_OUT_START and TS_OUT_CLK.
**
** - '00': Don't generate TS_OUT_EN, TS_OUT_START.
** - '11': Generate TS_OUT_EN, TS_OUT_START.
** This bit group must be set to '11' in normal mode. It is not necessary to set this bit group in TSD0 pass mode and TSD1 pass mode.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "GenerateSyncSignal" consists of the bits 25..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0x03000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_974"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_974" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_974")))
#endif

uint32_t FREG_TSD01_GetInRamCfg_GenerateSyncSignal( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INRAMCFG));
    value = ( value & 0x03000000UL ) >> 24;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TsOutClkPrescaler" of register "InRamCfg".
**
** Prescaler to generate TS_OUT_CLK based upon the clock domain 162MHz.
**  The frequency of TS_OUT_CLK equals to 162/[2*(TS_OUT_CLK_PRESCALER+1)] MHz. For example, if TS_OUT_CLK_PRESCALER is set to 80, the TS_OUT_CLK will be 162/[2*(80+1)] = 162/162 = 1MHz. This bit group is only considered in normal mode (i.e., it is not necessary to set this bit group in TSD0 pass mode and TSD1 pass mode).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "TsOutClkPrescaler" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_975"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_975" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_975")))
#endif

uint32_t FREG_TSD01_GetInRamCfg_TsOutClkPrescaler( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INRAMCFG));
    value = ( value & 0x00FF0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InputBufferOfIrqEn" of register "InRamCfg".
**
** Input buffer overflow IRQ enable.
**
** - '0': disabled.
** - '1': enabled.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "InputBufferOfIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_976"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_976" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_976")))
#endif

uint32_t FREG_TSD01_GetInRamCfg_InputBufferOfIrqEn( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INRAMCFG));
    value = ( value & 0x00001000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DisableTsInput1" of register "InRamCfg".
**
** Indicates if TS_input_1 shall be disabled.
**
** - '0': enabled.
** - '1': disabled.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "DisableTsInput1" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_977"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_977" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_977")))
#endif

uint32_t FREG_TSD01_GetInRamCfg_DisableTsInput1( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INRAMCFG));
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DisableTsInput0" of register "InRamCfg".
**
** Indicates if TS_input_0 shall be disabled.
**
** - '0': enabled.
** - '1': disabled.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "DisableTsInput0" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_978"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_978" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_978")))
#endif

uint32_t FREG_TSD01_GetInRamCfg_DisableTsInput0( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD01_INRAMCFG));
    value = ( value & 0x00000100UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the entire register "InRamCfg".
**
** This function writes the given value to the register "InRamCfg".
**
**
**
** \param value Register value to write.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_979"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_979" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_979")))
#endif

void FREG_TSD23_SetInRamCfg( uint32_t value )
{
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TsOutMode" of register "InRamCfg".
**
** TS output generation mode.
**  This bit group selects the source for TS_OUT_CLK, TS_OUT_EN, TS_OUT_START and TS_OUT_DATA:
** - '00': Normal mode. Select data from TSD3_input_buffer and generate TS_OUT_CLK, TS_OUT_EN and TS_OUT_START. (In this mode, the bit group GENERATE_SYNC_SIGNAL must be set to '11').
** - '01': TSD2 pass mode. Select data from TS_input_2. All data fed into TSD2_input_buffer (including TS_CLK, TS_EN, TS_START) will be directly sent to TS_OUT.
** - '10': TSD3 pass mode. Select data from TS_input_3. All data fed into TSD3_input_buffer (including TS_CLK, TS_EN, TS_START) will be directly sent to TS_OUT.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TsOutMode" consists of the bits 31..30,
**       the given bitgroup value will be shifted left by 30 bits and
**       masked using the bitmask 0xC0000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_980"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_980" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_980")))
#endif

void FREG_TSD23_SetInRamCfg_TsOutMode( uint32_t value )
{
    register uint32_t mask = 0xC0000000UL;
    value = ( value << 30 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InvertTsOutClk" of register "InRamCfg".
**
** Indicates if TS_OUT_CLK shall be inverted.
**
** - '0': Don't invert.
** - '1': Invert.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InvertTsOutClk" consists of the bits 29..29,
**       the given bitgroup value will be shifted left by 29 bits and
**       masked using the bitmask 0x20000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_981"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_981" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_981")))
#endif

void FREG_TSD23_SetInRamCfg_InvertTsOutClk( uint32_t value )
{
    register uint32_t mask = 0x20000000UL;
    value = ( value << 29 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "GenerateSyncSignal" of register "InRamCfg".
**
** Enables the geneation of TS synchronization signals like TS_OUT_EN, TS_OUT_START and TS_OUT_CLK.
**
** - '00': Don't generate TS_OUT_EN, TS_OUT_START.
** - '11': Generate TS_OUT_EN, TS_OUT_START.
** This bit group must be set to '11' in normal mode. It is not necessary to set this bit group in TSD2 pass mode and TSD3 pass mode.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "GenerateSyncSignal" consists of the bits 25..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0x03000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_982"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_982" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_982")))
#endif

void FREG_TSD23_SetInRamCfg_GenerateSyncSignal( uint32_t value )
{
    register uint32_t mask = 0x03000000UL;
    value = ( value << 24 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "TsOutClkPrescaler" of register "InRamCfg".
**
** Prescaler to generate TS_OUT_CLK based upon the clock domain 162MHz.
**  The frequency of TS_OUT_CLK equals to 162/[2*(TS_OUT_CLK_PRESCALER+1)] MHz. For example, if TS_OUT_CLK_PRESCALER is set to 80, the TS_OUT_CLK will be 162/[2*(80+1)] = 162/162 = 1MHz. This bit group is only considered in normal mode (i.e., it is not necessary to set this bit group in TSD2 pass mode and TSD3 pass mode).
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "TsOutClkPrescaler" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_983"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_983" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_983")))
#endif

void FREG_TSD23_SetInRamCfg_TsOutClkPrescaler( uint32_t value )
{
    register uint32_t mask = 0x00FF0000UL;
    value = ( value << 16 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "InputBufferOfIrqEn" of register "InRamCfg".
**
** Input buffer overflow IRQ enable.
**
** - '0': disabled.
** - '1': enabled.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "InputBufferOfIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_984"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_984" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_984")))
#endif

void FREG_TSD23_SetInRamCfg_InputBufferOfIrqEn( uint32_t value )
{
    register uint32_t mask = 0x00001000UL;
    value = ( value << 12 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DisableTsInput3" of register "InRamCfg".
**
** Indicates if TS_input_3 shall be disabled.
**
** - '0': enabled.
** - '1': disabled.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DisableTsInput3" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_985"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_985" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_985")))
#endif

void FREG_TSD23_SetInRamCfg_DisableTsInput3( uint32_t value )
{
    register uint32_t mask = 0x00000200UL;
    value = ( value << 9 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Writes the bitgroup "DisableTsInput2" of register "InRamCfg".
**
** Indicates if TS_input_2 shall be disabled.
**
** - '0': enabled.
** - '1': disabled.
**
** \param value Bitgroup value to write.
**
** \note internally the bitgroup "DisableTsInput2" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_986"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_986" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_986")))
#endif

void FREG_TSD23_SetInRamCfg_DisableTsInput2( uint32_t value )
{
    register uint32_t mask = 0x00000100UL;
    value = ( value << 8 ) & mask;
    #define REGISTER_BITGROUP_COUNT 7
    #if REGISTER_BITGROUP_COUNT > 1
        value |= ( *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) & ~mask );
    #endif
    #undef REGISTER_BITGROUP_COUNT
    #if FREG_TSD_ENABLE_DEBUG_PRINT == 1
        FREG_TSD_DEBUG_PRINT_FUNCTION( "[%s] 0x%08x <- 0x%08x\n", "FREG_TSD", FREG_TSD23_INRAMCFG, value );
    #endif
    *((volatile uint32_t*)(FREG_TSD23_INRAMCFG)) = value;
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the entire register "InRamCfg".
**
** This function reads the value from the register "InRamCfg".
**
**
**
** \return Read register value.
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_987"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_987" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_987")))
#endif

uint32_t FREG_TSD23_GetInRamCfg( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INRAMCFG));
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TsOutMode" of register "InRamCfg".
**
** TS output generation mode.
**  This bit group selects the source for TS_OUT_CLK, TS_OUT_EN, TS_OUT_START and TS_OUT_DATA:
** - '00': Normal mode. Select data from TSD3_input_buffer and generate TS_OUT_CLK, TS_OUT_EN and TS_OUT_START. (In this mode, the bit group GENERATE_SYNC_SIGNAL must be set to '11').
** - '01': TSD2 pass mode. Select data from TS_input_2. All data fed into TSD2_input_buffer (including TS_CLK, TS_EN, TS_START) will be directly sent to TS_OUT.
** - '10': TSD3 pass mode. Select data from TS_input_3. All data fed into TSD3_input_buffer (including TS_CLK, TS_EN, TS_START) will be directly sent to TS_OUT.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "TsOutMode" consists of the bits 31..30,
**       the given bitgroup value will be shifted left by 30 bits and
**       masked using the bitmask 0xC0000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_988"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_988" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_988")))
#endif

uint32_t FREG_TSD23_GetInRamCfg_TsOutMode( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INRAMCFG));
    value = ( value & 0xC0000000UL ) >> 30;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InvertTsOutClk" of register "InRamCfg".
**
** Indicates if TS_OUT_CLK shall be inverted.
**
** - '0': Don't invert.
** - '1': Invert.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "InvertTsOutClk" consists of the bits 29..29,
**       the given bitgroup value will be shifted left by 29 bits and
**       masked using the bitmask 0x20000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_989"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_989" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_989")))
#endif

uint32_t FREG_TSD23_GetInRamCfg_InvertTsOutClk( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INRAMCFG));
    value = ( value & 0x20000000UL ) >> 29;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "GenerateSyncSignal" of register "InRamCfg".
**
** Enables the geneation of TS synchronization signals like TS_OUT_EN, TS_OUT_START and TS_OUT_CLK.
**
** - '00': Don't generate TS_OUT_EN, TS_OUT_START.
** - '11': Generate TS_OUT_EN, TS_OUT_START.
** This bit group must be set to '11' in normal mode. It is not necessary to set this bit group in TSD2 pass mode and TSD3 pass mode.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "GenerateSyncSignal" consists of the bits 25..24,
**       the given bitgroup value will be shifted left by 24 bits and
**       masked using the bitmask 0x03000000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_990"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_990" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_990")))
#endif

uint32_t FREG_TSD23_GetInRamCfg_GenerateSyncSignal( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INRAMCFG));
    value = ( value & 0x03000000UL ) >> 24;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "TsOutClkPrescaler" of register "InRamCfg".
**
** Prescaler to generate TS_OUT_CLK based upon the clock domain 162MHz.
**  The frequency of TS_OUT_CLK equals to 162/[2*(TS_OUT_CLK_PRESCALER+1)] MHz. For example, if TS_OUT_CLK_PRESCALER is set to 80, the TS_OUT_CLK will be 162/[2*(80+1)] = 162/162 = 1MHz. This bit group is only considered in normal mode (i.e., it is not necessary to set this bit group in TSD2 pass mode and TSD3 pass mode).
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "TsOutClkPrescaler" consists of the bits 23..16,
**       the given bitgroup value will be shifted left by 16 bits and
**       masked using the bitmask 0x00FF0000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_991"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_991" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_991")))
#endif

uint32_t FREG_TSD23_GetInRamCfg_TsOutClkPrescaler( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INRAMCFG));
    value = ( value & 0x00FF0000UL ) >> 16;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "InputBufferOfIrqEn" of register "InRamCfg".
**
** Input buffer overflow IRQ enable.
**
** - '0': disabled.
** - '1': enabled.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "InputBufferOfIrqEn" consists of the bits 12..12,
**       the given bitgroup value will be shifted left by 12 bits and
**       masked using the bitmask 0x00001000UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_992"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_992" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_992")))
#endif

uint32_t FREG_TSD23_GetInRamCfg_InputBufferOfIrqEn( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INRAMCFG));
    value = ( value & 0x00001000UL ) >> 12;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DisableTsInput3" of register "InRamCfg".
**
** Indicates if TS_input_3 shall be disabled.
**
** - '0': enabled.
** - '1': disabled.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "DisableTsInput3" consists of the bits 9..9,
**       the given bitgroup value will be shifted left by 9 bits and
**       masked using the bitmask 0x00000200UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_993"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_993" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_993")))
#endif

uint32_t FREG_TSD23_GetInRamCfg_DisableTsInput3( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INRAMCFG));
    value = ( value & 0x00000200UL ) >> 9;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

#if !defined(FREG_USE_INLINE)
/*!
********************************************************************************
**
** \brief Reads the bitgroup "DisableTsInput2" of register "InRamCfg".
**
** Indicates if TS_input_2 shall be disabled.
**
** - '0': enabled.
** - '1': disabled.
**
** \return Read bitgroup value.
**
** \note internally the bitgroup "DisableTsInput2" consists of the bits 8..8,
**       the given bitgroup value will be shifted left by 8 bits and
**       masked using the bitmask 0x00000100UL
**
********************************************************************************
*/

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code = ".text$$FREG_TSD_994"
#endif

#if defined(_ARC)
#pragma Code( ".text$$FREG_TSD_994" )
#endif

#if defined(__GNUC__)
__attribute__((section(".text$$FREG_TSD_994")))
#endif

uint32_t FREG_TSD23_GetInRamCfg_DisableTsInput2( void )
{
    register uint32_t value;
    value = *((volatile uint32_t*)(FREG_TSD23_INRAMCFG));
    value = ( value & 0x00000100UL ) >> 8;
    return( value );
}

#if defined(__arm__) && !defined(__GNUC__)
#pragma arm section code
#endif

#if defined(_ARC)
#pragma Code()
#endif

#endif

/*!
********************************************************************************
**
** \brief Initializes the "TSD" block.
**
** Initializes all required registers and mirror variables.
**
********************************************************************************
*/
void FREG_TSD_Init( void )
{
}
